(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_@okxconnect_universal-provider_src_36aa5e._.js", {

"[project]/node_modules/@okxconnect/universal-provider/src/provider/types/providers.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IJSONRpcProvider = exports.IJSONRpcConnection = void 0;
class IJSONRpcConnection {
}
exports.IJSONRpcConnection = IJSONRpcConnection;
class IJSONRpcProvider {
    constructor(opt){}
}
exports.IJSONRpcProvider = IJSONRpcProvider;
}}),
"[project]/node_modules/@okxconnect/universal-provider/src/provider/types/misc.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
}}),
"[project]/node_modules/@okxconnect/universal-provider/src/provider/types/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/types/providers.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/types/misc.js [app-client] (ecmascript)"), exports);
}}),
"[project]/node_modules/@okxconnect/universal-provider/src/provider/utils/misc.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getRpcUrl = getRpcUrl;
exports.getChainId = getChainId;
exports.fromAccountToAddress = fromAccountToAddress;
exports.convertChainIdToNumber = convertChainIdToNumber;
exports.parseChainId = parseChainId;
exports.mergeArrays = mergeArrays;
exports.syncAddressAvailable = syncAddressAvailable;
exports.syncAddressHostAvailable = syncAddressHostAvailable;
const core_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/index.js [app-client] (ecmascript)");
function getRpcUrl(chainId, rpc, projectId) {
    var _a;
    const chain = parseChainId(chainId);
    // no default
    return ((_a = rpc.rpcMap) === null || _a === void 0 ? void 0 : _a[chain.reference]) || ``;
}
function getChainId(chain) {
    return chain.includes(":") ? chain.split(":")[1] : chain;
}
function fromAccountToAddress(account) {
    if (!account) {
        return "";
    }
    try {
        let addressArr = account.split(":").slice(2);
        let address = addressArr.length > 0 ? addressArr.join(":") : "";
        (0, core_1.logDebug)("fromAccountToAddress address and account:", address, account);
        return address;
    } catch (e) {
        (0, core_1.logError)("fromAccountToAddress error:", account);
        return "";
    }
}
// export function validateChainApproval(chain: string, chains: string[]): void {
//   if (!chains.includes(chain)) {
//     throw new Error(
//       `Chain '${chain}' not approved. Please use one of the following: ${chains.toString()}`,
//     );
//   }
// }
// export function getChainsFromApprovedSession(accounts: string[]): string[] {
//   return accounts.map((address) => `${address.split(":")[0]}:${address.split(":")[1]}`);
// }
// export function getAccountsFromSession(namespace: string, session: SessionTypes.Struct): string[] {
//   // match namespaces e.g. eip155 with eip155:1
//   const matchedNamespaceKeys = Object.keys(session.namespaces).filter((key) =>
//     key.includes(namespace),
//   );
//   if (!matchedNamespaceKeys.length) return [];
//   const accounts: string[] = [];
//   matchedNamespaceKeys.forEach((key) => {
//     const accountsForNamespace = session.namespaces[key].accounts;
//     accounts.push(...accountsForNamespace);
//   });
//   return accounts;
// }
// export function mergeRequiredOptionalNamespaces(
//   required: NamespaceConfig = {},
//   optional: NamespaceConfig = {},
// ){
//   const requiredNamespaces = normalizeNamespaces(required);
//   const optionalNamespaces = normalizeNamespaces(optional);
//    return merge.merge(requiredNamespaces,optionalNamespaces)
// }
/**
 * Converts
 * {
 *  "eip155:1": {...},
 *  "eip155:2": {...},
 * }
 * into
 * {
 *  "eip155": {
 *      chains: ["eip155:1", "eip155:2"],
 *      ...
 *    }
 * }
 *
 */ // export function normalizeNamespaces(namespaces: NamespaceConfig): NamespaceConfig {
//   const normalizedNamespaces: NamespaceConfig = {};
//   if (!isValidObject(namespaces)) return normalizedNamespaces;
//
//   for (const [key, values] of Object.entries(namespaces)) {
//     const chains = isCaipNamespace(key) ? [key] : values.chains;
//     const rpcMap = values.rpcMap || {};
//     const normalizedKey = parseNamespaceKey(key);
//     normalizedNamespaces[normalizedKey] = {
//       ...normalizedNamespaces[normalizedKey],
//       ...values,
//       chains: mergeArrays(chains, normalizedNamespaces[normalizedKey]?.chains),
//       rpcMap: { ...rpcMap, ...normalizedNamespaces[normalizedKey]?.rpcMap },
//     };
//   }
//   return normalizedNamespaces;
// }
//
// export function parseCaip10Account(caip10Account: string): string {
//   return caip10Account.includes(":") ? caip10Account.split(":")[2] : caip10Account;
// }
/**
 * Populates the chains array for each namespace with the chains extracted from the accounts if are otherwise missing
 */ // export function populateNamespacesChains(
//   namespaces: SessionTypes.Namespaces,
// ): Record<string, SessionTypes.Namespace> {
//   const parsedNamespaces: Record<string, SessionTypes.Namespace> = {};
//   for (const [key, values] of Object.entries(namespaces)) {
//     const methods = values.methods || [];
//     const events = values.events || [];
//     const accounts = values.accounts || [];
//     // If the key includes a CAIP separator `:` we know it's a namespace + chainId (e.g. `eip155:1`)
//     const chains = isCaipNamespace(key)
//       ? [key]
//       : values.chains
//       ? values.chains
//       : getChainsFromApprovedSession(values.accounts);
//     parsedNamespaces[key] = {
//       chains,
//       methods,
//       events,
//       accounts,
//     };
//   }
//   return parsedNamespaces;
// }
function convertChainIdToNumber(chainId) {
    if (typeof chainId === "number") return chainId;
    if (chainId.includes("0x")) {
        return parseInt(chainId, 16);
    }
    chainId = chainId.includes(":") ? chainId.split(":")[1] : chainId;
    return isNaN(Number(chainId)) ? chainId : Number(chainId);
}
const CAIP_DELIMITER = ":";
function parseChainId(chain) {
    const [namespace, reference] = chain.split(CAIP_DELIMITER);
    return {
        namespace,
        reference
    };
}
function mergeArrays(a = [], b = []) {
    return [
        ...new Set([
            ...a,
            ...b
        ])
    ];
}
function syncAddressAvailable(wallet) {
    if (!wallet) {
        return false;
    }
    if (wallet.appName !== 'OKX Wallet') {
        return false;
    }
    if ((0, core_1.versionCompare)('6.97.0', wallet.appVersion) > 0) {
        return false;
    }
    return syncAddressHostAvailable();
}
function syncAddressHostAvailable() {
    try {
        return !!window.okxGlobal;
    } catch (e) {
        return false;
    }
}
}}),
"[project]/node_modules/@okxconnect/universal-provider/src/provider/utils/globals.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.setGlobal = exports.getGlobal = void 0;
const globals = {};
const getGlobal = (key)=>{
    return globals[key];
};
exports.getGlobal = getGlobal;
const setGlobal = (key, value)=>{
    globals[key] = value;
};
exports.setGlobal = setGlobal;
}}),
"[project]/node_modules/@okxconnect/universal-provider/src/provider/utils/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/utils/misc.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/utils/globals.js [app-client] (ecmascript)"), exports);
}}),
"[project]/node_modules/@okxconnect/universal-provider/src/provider/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/types/index.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/utils/index.js [app-client] (ecmascript)"), exports);
}}),
"[project]/node_modules/@okxconnect/universal-provider/src/packages/utils/ConnectMethodUtils.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.connectSupportMethods = void 0;
exports.creatNotSupportMethodItemReplay = creatNotSupportMethodItemReplay;
exports.connectMethodsAdaptOldVersion = connectMethodsAdaptOldVersion;
exports.connectMethodsResponseUpdate = connectMethodsResponseUpdate;
exports.connectMethodsToConnectWalletMethods = connectMethodsToConnectWalletMethods;
exports.syncResoonseToRequire = syncResoonseToRequire;
const core_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/index.js [app-client] (ecmascript)");
const bs58_1 = __importDefault(__turbopack_require__("[project]/node_modules/bs58/index.js [app-client] (ecmascript)"));
const uint8array_extras_1 = __turbopack_require__("[project]/node_modules/uint8array-extras/index.js [app-client] (ecmascript)");
const provider_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/index.js [app-client] (ecmascript)");
function isArray(value) {
    return typeof value === "object" && value !== null && Array.isArray(value);
}
function isRecord(value) {
    return typeof value === "object" && value !== null && !Array.isArray(value);
}
// "wallet_addEthereumChain",
// "solana_signMessage",  There are risks
exports.connectSupportMethods = Object.freeze([
    "personal_sign",
    "sui_signMessage",
    "sui_signPersonalMessage",
    "btc_signMessage",
    "aptos_signMessage",
    "cosmos_signArbitrary",
    "tron_signMessage",
    "tron_signMessageV2",
    "starknet_signMessage",
    "sync_all_addresses"
]);
function creatNotSupportMethodItemReplay(requestParams) {
    let notSupportError = new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.METHOD_NOT_SUPPORTED);
    var errorItem = {
        method: requestParams.method,
        chainId: requestParams.chainId,
        error: {
            code: notSupportError.code,
            message: notSupportError.message
        }
    };
    return errorItem;
}
function connectMethodsAdaptOldVersion(requestParams, session) {
    return __awaiter(this, void 0, void 0, function*() {
        var _a, _b, _c, _d, _e;
        try {
            (0, core_1.logDebug)("connectMethodsAdaptOldVersion start params :", JSON.stringify(requestParams));
            let callBackParams = {};
            if (requestParams.method === "solana_signMessage") {
                let solAccount = (_a = session.namespaces[core_1.NameSpaceKeySOL]) === null || _a === void 0 ? void 0 : _a.accounts.filter(function(account1) {
                    return account1.startsWith(requestParams.chainId);
                })[0];
                const solAddress = (0, provider_1.fromAccountToAddress)(solAccount);
                if (requestParams.params && solAddress && "message" in requestParams.params) {
                    let realMessage = requestParams.params.message;
                    if (((_b = session.wallet) === null || _b === void 0 ? void 0 : _b.appName) == "OKX Wallet") {
                        realMessage = bs58_1.default.encode((0, uint8array_extras_1.stringToUint8Array)(realMessage));
                    }
                    requestParams.params = {
                        message: realMessage,
                        "pubkey": solAddress
                    };
                    callBackParams = {
                        publicKey: solAddress
                    };
                    (0, core_1.logDebug)("solana_signMessage account and address:", JSON.stringify(solAccount), solAddress);
                    (0, core_1.logDebug)("solana_signMessage callBackParams:", JSON.stringify(callBackParams));
                    return callBackParams;
                } else {
                    throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.METHOD_NOT_SUPPORTED);
                }
            } else if (requestParams.method === "sui_signMessage" || requestParams.method === "sui_signPersonalMessage") {
                if ("message" in requestParams.params && requestParams.params.message) {
                    let suiMessage = JSON.parse(JSON.stringify(requestParams.params.message));
                    let convertedArray = Object.values(suiMessage);
                    let uint8Array = new Uint8Array(convertedArray);
                    let decoder = new TextDecoder("utf8");
                    let b64encoded = btoa(decoder.decode(uint8Array));
                    requestParams.params = {
                        message: atob(b64encoded)
                    };
                    console.log("sui_signMessag suiMessagee suiMessageb64:>>>>", JSON.stringify(requestParams.params), b64encoded);
                    if (requestParams.method === "sui_signMessage") {
                        callBackParams = {
                            "messageBytes": b64encoded,
                            "signature": ""
                        };
                    } else if (requestParams.method === "sui_signPersonalMessage") {
                        callBackParams = {
                            "bytes": b64encoded,
                            "signature": ""
                        };
                    }
                    (0, core_1.logDebug)("sui_signMessage/sui_signPersonalMessage callBackParams:", JSON.stringify(callBackParams));
                    return callBackParams;
                } else {
                    throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.METHOD_NOT_SUPPORTED);
                }
            } else if (requestParams.method === "btc_signMessage") {
                let btcAccounts = (_c = session.namespaces[core_1.NameSpaceKeyBtc]) === null || _c === void 0 ? void 0 : _c.accounts.filter(function(account2) {
                    return account2.startsWith(requestParams.chainId);
                });
                let btcAccount = btcAccounts[0];
                const btcAddress = (0, provider_1.fromAccountToAddress)(btcAccount);
                (0, core_1.logDebug)("btc_signMessage account and address:", JSON.stringify(btcAccount), btcAddress);
                if (btcAddress) {
                    if ("message" in requestParams.params && requestParams.params.message && typeof requestParams.params.message === 'string') {
                        requestParams.params = {
                            from: btcAddress,
                            signStr: requestParams.params.message
                        };
                    } else {
                        throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.METHOD_NOT_SUPPORTED);
                    }
                    requestParams.params["from"] = btcAddress;
                    (0, core_1.logDebug)("btc_signMessage callBackParams:", JSON.stringify(callBackParams));
                    return callBackParams;
                } else {
                    throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.METHOD_NOT_SUPPORTED);
                }
            } else if (requestParams.method === "aptos_signMessage") {
                let paramData = requestParams.params;
                let aptosAccount = (_d = session.namespaces[core_1.NameSpaceKeyAptos]) === null || _d === void 0 ? void 0 : _d.accounts.filter(function(account3) {
                    return account3.startsWith(requestParams.chainId);
                })[0];
                let aptosAddress = (0, provider_1.fromAccountToAddress)(aptosAccount);
                if (paramData && aptosAddress) {
                    let prefix = "APTOS";
                    let message = "", nonce = "";
                    var fullMessage = prefix;
                    let application = window.location.protocol + "//" + window.location.hostname;
                    if ("address" in paramData && paramData.address) {
                        fullMessage += "\naddress: " + aptosAddress;
                    }
                    if ("application" in paramData && paramData.application) {
                        fullMessage += "\napplication: " + application;
                    }
                    let aptosChainId = 1;
                    if ("chainId" in paramData && paramData.chainId) {
                        if (paramData.chainId == "aptos:mainnet") {
                            aptosChainId = 1;
                        } else if (paramData.chainId == "movement:testnet") {
                            aptosChainId = 2;
                        }
                        fullMessage += "\nchainId: " + aptosChainId;
                    }
                    if ("message" in paramData) {
                        fullMessage += "\nmessage: " + paramData.message;
                        message = paramData.message;
                    }
                    if ("nonce" in paramData) {
                        fullMessage += "\nnonce: " + paramData.nonce;
                        nonce = paramData.nonce;
                    }
                    const utf8Array = new TextEncoder().encode(fullMessage);
                    const hex = Array.from(utf8Array).map((byte)=>byte.toString(16).padStart(2, "0")).join("");
                    requestParams.params = {
                        "message": hex
                    };
                    (0, core_1.logDebug)("aptos_signMessage requestParams:", JSON.stringify(requestParams));
                    callBackParams = {
                        address: aptosAddress,
                        application: application,
                        chainId: aptosChainId,
                        fullMessage: fullMessage,
                        message: message,
                        nonce: nonce,
                        prefix: prefix,
                        signature: ""
                    };
                    (0, core_1.logDebug)("aptos_signMessage callBackParams:", JSON.stringify(callBackParams));
                    return callBackParams;
                } else {
                    throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.METHOD_NOT_SUPPORTED);
                }
            } else if (requestParams.method === "cosmos_signArbitrary") {
                let cosmosAccount = (_e = session === null || session === void 0 ? void 0 : session.namespaces[core_1.NameSpaceKeyCosmos]) === null || _e === void 0 ? void 0 : _e.accounts.filter(function(account_cosmos) {
                    return account_cosmos.startsWith(requestParams.chainId);
                })[0];
                const cosmosAddress = (0, provider_1.fromAccountToAddress)(cosmosAccount);
                let cosmosData = requestParams.params["message"];
                const cosmosBase64Encoded = (0, uint8array_extras_1.stringToBase64)(cosmosData);
                (0, core_1.logDebug)("cosmos_signArbitrary account and address:", JSON.stringify(cosmosAccount), cosmosAddress);
                (0, core_1.logDebug)("cosmos_signArbitrary cosmosBase64Encoded:", cosmosBase64Encoded);
                if (cosmosData && cosmosAddress) {
                    const signDoc = {
                        chain_id: "",
                        account_number: "0",
                        sequence: "0",
                        fee: {
                            gas: "0",
                            amount: []
                        },
                        msgs: [
                            {
                                "type": "sign/MsgSignData",
                                "value": {
                                    "signer": cosmosAddress,
                                    "data": cosmosBase64Encoded
                                }
                            }
                        ],
                        memo: ""
                    };
                    requestParams.params = {
                        "signer": cosmosAddress,
                        "chain_id": requestParams.chainId.split(":")[1],
                        "data": signDoc
                    };
                    (0, core_1.logDebug)("cosmos_signArbitrary callBackParams:", JSON.stringify(callBackParams));
                    return callBackParams;
                } else {
                    throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.METHOD_NOT_SUPPORTED);
                }
            }
            (0, core_1.logDebug)("sol_handleSignatureData end params:", JSON.stringify(requestParams));
        } catch (error) {
            throw error;
        }
    });
}
function connectMethodsResponseUpdate(session, requestParams) {
    return __awaiter(this, void 0, void 0, function*() {
        var _a;
        try {
            if (session.signResponse) {
                (0, core_1.logDebug)("connectMethodsResponseUpdate signResponse:", JSON.stringify(session.signResponse));
                (0, core_1.logDebug)("connectMethodsResponseUpdate session.namespaces:", JSON.stringify(session.namespaces));
                for (const methodItem of session.signResponse){
                    (0, core_1.logDebug)("connectMethodsResponseUpdate methodItem:", JSON.stringify(methodItem));
                    if ("result" in methodItem) {
                        if (methodItem.method === "solana_signMessage") {
                            let solanaSuccessData = methodItem.result;
                            (0, core_1.logDebug)("solana_signMessage methodItem.chainId:", methodItem.chainId);
                            let account = (_a = session.namespaces[core_1.NameSpaceKeySOL]) === null || _a === void 0 ? void 0 : _a.accounts.filter(function(account) {
                                (0, core_1.logDebug)("solana_signMessage account:", account);
                                return account.startsWith(methodItem.chainId);
                            })[0];
                            (0, core_1.logDebug)("solana_signMessage result account:", solanaSuccessData, account);
                            if (solanaSuccessData && account) {
                                methodItem.result = {
                                    "signature": bs58_1.default.decode(solanaSuccessData),
                                    "publicKey": (0, provider_1.fromAccountToAddress)(account)
                                };
                            }
                        } else if (methodItem.method === "sui_signMessage" || methodItem.method === "sui_signPersonalMessage") {
                            let suiMethod = requestParams.filter(function(requestMethod) {
                                return requestMethod.method === methodItem.method;
                            })[0];
                            if (suiMethod && suiMethod.params && "message" in suiMethod.params) {
                                let suiMessage = suiMethod.params.message;
                                let suiMessageb64 = btoa(suiMessage);
                                console.log("sui_signMessag suiMessagee suiMessageb64:>>>>", suiMessage, suiMessageb64);
                                if (methodItem.method === "sui_signMessage") {
                                    methodItem.result = {
                                        "messageBytes": suiMessageb64,
                                        "signature": methodItem.result
                                    };
                                } else if (methodItem.method === "sui_signPersonalMessage") {
                                    methodItem.result = {
                                        "bytes": suiMessageb64,
                                        "signature": methodItem.result
                                    };
                                }
                            }
                        } else if (methodItem.method === "aptos_signMessage") {
                            if (methodItem.chainId === "aptos:637") {
                                methodItem.chainId = "aptos:mainnet";
                            } else if (methodItem.chainId === "aptos:70000060") {
                                methodItem.chainId = "movement:testnet";
                            }
                            methodItem.result = JSON.parse(methodItem.result);
                            console.log("aptos_signMessage result methodItem.result before:>>>>", JSON.stringify(methodItem.result));
                            if (methodItem.result && "signature" in methodItem.result) {
                                let aptosSignature = methodItem.result.signature;
                                if (aptosSignature && aptosSignature.startsWith("0x")) {
                                    aptosSignature = aptosSignature.slice(2, aptosSignature.length);
                                    methodItem.result.signature = aptosSignature;
                                }
                            }
                            console.log("aptos_signMessage result methodItem.result after:>>>>", JSON.stringify(methodItem.result));
                        } else if (methodItem.method === "cosmos_signArbitrary") {
                            methodItem.result = JSON.parse(methodItem.result);
                        } else if (methodItem.method == 'starknet_signMessage') {
                            let results = methodItem.result;
                            if (typeof results == 'string') {
                                results = JSON.parse(results);
                            }
                            methodItem.result = [
                                results["signedDataR"],
                                results["signedDataS"]
                            ];
                        } else if (methodItem.method == 'sync_all_addresses') {
                            methodItem.result = syncResoonseToRequire(methodItem.result);
                        }
                    }
                }
            }
        } catch (error) {
            (0, core_1.logDebug)("connectMethodsResponseUpdate signResponse Error:", JSON.stringify(error));
            throw error;
        }
    });
}
function connectMethodsToConnectWalletMethods(params, requireNameSpace) {
    return __awaiter(this, void 0, void 0, function*() {
        try {
            (0, core_1.logDebug)("connectMethodsToConnectWalletMethods requestMethods:", JSON.stringify(params));
            const result = [];
            //TODO  后面需要打开限制
            if (params && params.length > 1) {
                throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `connectAndSign/openModalAndSign signRequest only support one data`);
            }
            if (!requireNameSpace && params && params.length > 0) {
                throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `Connect request params error , RequestMethods cannot be added when the NameSpace is empty`);
            }
            // check chianId
            for (const methodItem of params){
                if (methodItem.method === "aptos_signMessage") {
                    if (methodItem.chainId === "aptos:mainnet") {
                        methodItem.chainId = "aptos:637";
                    } else if (methodItem.chainId === "movement:testnet") {
                        methodItem.chainId = "aptos:70000060";
                    }
                }
                // check chianId
                if (methodItem.method === "wallet_addEthereumChain") {
                    var includeEip155 = requireNameSpace === null || requireNameSpace === void 0 ? void 0 : requireNameSpace.some((space)=>space.namespace.includes("eip155"));
                    if (!includeEip155) {
                        throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `Connect request params error, When using '${methodItem.method}', the EVM chain needs to be included in the NameSpace`);
                    }
                } else if (methodItem.method === "sync_all_addresses") {
                    if ((0, provider_1.syncAddressHostAvailable)()) {
                        methodItem.chainId = "";
                    } else {
                        throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.METHOD_NOT_SUPPORTED);
                    }
                } else {
                    const includeChain = !!(requireNameSpace === null || requireNameSpace === void 0 ? void 0 : requireNameSpace.some((space)=>space.chains.some((chain)=>chain.includes(`${methodItem.chainId}`))));
                    if (!includeChain) {
                        throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `Connect request params error, When using '${methodItem.method}', NameSpace must contain '${methodItem.chainId}'`);
                    }
                }
            }
            for (const item of params){
                if (!exports.connectSupportMethods.includes(item.method)) {
                    throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `connect requestMethods not support method, method: '${item.method}'`);
                }
                if (item.method === "wallet_addEthereumChain") {
                    if (Array.isArray(item.params)) {
                        const paramsArr = item.params;
                        if (paramsArr && paramsArr.length === 1) {
                            const firstParam = paramsArr[0];
                            if (isRecord(firstParam)) {
                                item.params = firstParam;
                            }
                        } else if (paramsArr && paramsArr.length > 1) {
                            throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `connect request params only support one data, method: '${item.method}'`);
                        } else {
                            throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `connect request params is nil, method: '${item.method}'`);
                        }
                    }
                } else if (item.method === "personal_sign") {
                    if (isArray(item.params)) {
                        if (item.params && item.params.length !== 1) {
                            throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `connect request params error,  method: '${item.method}' `);
                        }
                        let firstObj = item.params[0];
                        if (firstObj && typeof firstObj === 'string') {
                            item.params = {
                                message: firstObj
                            };
                        } else {
                            throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `connect request params is error,  method: '${item.method}' `);
                        }
                    }
                } else if (item.method === "sui_signMessage" || item.method === "sui_signPersonalMessage") {
                    if (isRecord(item.params) && 'message' in item.params) {
                        if (item.params.message) {
                            (0, core_1.logDebug)("sui_signMessage item.params.message :", item.params.message);
                            let message = JSON.parse(JSON.stringify(item.params.message));
                            let convertedArray = Object.values(message);
                            let uint8Array = new Uint8Array(convertedArray);
                            let decoder = new TextDecoder("utf8");
                            let b64encoded = btoa(decoder.decode(uint8Array));
                            item.params.message = atob(b64encoded);
                        } else {
                            throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `connect request params is error,  method: '${item.method}' `);
                        }
                    } else {
                        throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `connect request params is error,  method: '${item.method}' `);
                    }
                } else if (item.method === "solana_signMessage") {
                    if (isRecord(item.params) && 'message' in item.params) {
                        if (item.params.message && typeof item.params.message === 'string') {
                            item.params["bs58Message"] = bs58_1.default.encode((0, uint8array_extras_1.stringToUint8Array)(item.params.message));
                        } else {
                            throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `connect request params is error,  method: '${item.method}' `);
                        }
                    } else {
                        throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `connect request params is error,  method: '${item.method}' `);
                    }
                } else if (item.method === "aptos_signMessage") {
                    if (isRecord(item.params)) {
                        if (item.chainId && (item.chainId === "aptos:637" || item.chainId === "aptos:70000060")) {
                            var aptosParams = item.params;
                            var currentURL = window.location.protocol + "//" + window.location.hostname;
                            let signChainId = 1;
                            if (item.chainId === "aptos:637") {} else if (item.chainId === "aptos:70000060") {
                                signChainId = 2;
                            }
                            item.params = {
                                data: aptosParams,
                                applicationUrl: currentURL,
                                prefix: "APTOS",
                                aptosChainId: signChainId
                            };
                        } else {
                            throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `connect request params chainId is error,  method: '${item.method}' `);
                        }
                    } else {
                        throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `connect request params is error,  method: '${item.method}' `);
                    }
                } else if (item.method === "cosmos_signArbitrary") {
                    if (isRecord(item.params)) {
                        if (item.params.message && typeof item.params.message === 'string') {
                            const base64Encoded = (0, uint8array_extras_1.stringToBase64)(item.params.message);
                            let cosmosChain = item.chainId.split(":")[1];
                            if (cosmosChain) {
                                item.params = {
                                    chain_id: cosmosChain,
                                    data: {
                                        chain_id: "",
                                        account_number: "0",
                                        sequence: "0",
                                        fee: {
                                            gas: "0",
                                            amount: []
                                        },
                                        msgs: [
                                            {
                                                "type": "sign/MsgSignData",
                                                "value": {
                                                    "signer": "",
                                                    "data": base64Encoded
                                                }
                                            }
                                        ],
                                        memo: ""
                                    }
                                };
                            } else {
                                throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `connect request params chainId is error,  method: '${item.method}' `);
                            }
                        } else {
                            throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `connect request params message is error,  method: '${item.method}' `);
                        }
                    } else {
                        throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `connect request params is error,  method: '${item.method}' `);
                    }
                } else if (item.method == "tron_signMessage") {
                    if (isRecord(item.params)) {
                        if ("message" in item.params && item.params.message && typeof item.params.message === 'string') {
                            item.params.message = stringToHex(item.params.message);
                        } else {
                            throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `connect request params is error,  method: '${item.method}' `);
                        }
                    } else {
                        throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `connect request params is error,  method: '${item.method}' `);
                    }
                } else if (item.method == "btc_signMessage") {
                    if (isRecord(item.params)) {
                        if ("message" in item.params && item.params.message && typeof item.params.message === 'string') {
                            item.params = {
                                signStr: item.params.message
                            };
                        } else {
                            throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `connect request params is error,  method: '${item.method}' `);
                        }
                    } else {
                        throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `connect request params is error,  method: '${item.method}' `);
                    }
                }
                (0, core_1.logDebug)("connectMethodsToConnectWalletMethods item:", JSON.stringify(item));
                result.push(item);
            }
            return result;
        } catch (error) {
            throw error;
        }
    });
}
function stringToHex(str) {
    let hex = '';
    for(let i = 0; i < str.length; i++){
        hex += str.charCodeAt(i).toString(16).padStart(2, '0');
    }
    return hex;
}
function syncResoonseToRequire(responseAddressStr) {
    const allAddress = JSON.parse(responseAddressStr);
    const result = {
        type: allAddress.type,
        isEvm: allAddress.isEvm,
        walletName: allAddress.walletName,
        deriveName: allAddress.deriveName,
        addresses: allAddress.addresses.map((addr)=>({
                coinId: addr.ci,
                address: addr.a && addr.a !== 'null' ? addr.a : allAddress.evmAddress
            }))
    };
    return result;
}
}}),
"[project]/node_modules/@okxconnect/universal-provider/src/packages/utils/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.creatNotSupportMethodItemReplay = exports.connectMethodsAdaptOldVersion = void 0;
var ConnectMethodUtils_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/packages/utils/ConnectMethodUtils.js [app-client] (ecmascript)");
Object.defineProperty(exports, "connectMethodsAdaptOldVersion", {
    enumerable: true,
    get: function() {
        return ConnectMethodUtils_1.connectMethodsAdaptOldVersion;
    }
});
Object.defineProperty(exports, "creatNotSupportMethodItemReplay", {
    enumerable: true,
    get: function() {
        return ConnectMethodUtils_1.creatNotSupportMethodItemReplay;
    }
});
}}),
"[project]/node_modules/@okxconnect/universal-provider/src/packages/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/packages/utils/index.js [app-client] (ecmascript)"), exports);
}}),
"[project]/node_modules/@okxconnect/universal-provider/src/provider/constants/values.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GENERIC_SUBPROVIDER_NAME = exports.RPC_URL = exports.STORAGE = exports.CONTEXT = exports.WC_VERSION = exports.PROTOCOL = exports.RELAY_URL = exports.LOGGER = void 0;
exports.LOGGER = "error";
exports.RELAY_URL = "wss://relay.walletconnect.com";
exports.PROTOCOL = "wc";
exports.WC_VERSION = 2;
exports.CONTEXT = "universal_provider";
exports.STORAGE = `${exports.PROTOCOL}@${exports.WC_VERSION}:${exports.CONTEXT}:`;
exports.RPC_URL = "https://rpc.walletconnect.com/v1/";
exports.GENERIC_SUBPROVIDER_NAME = "generic";
}}),
"[project]/node_modules/@okxconnect/universal-provider/src/provider/constants/events.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PROVIDER_EVENTS = void 0;
exports.PROVIDER_EVENTS = {
    DEFAULT_CHAIN_CHANGED: "default_chain_changed",
    UPDATE_NAMESPACES: "update_name_spaces",
    SESSION_CONNECTING: "session_connecting"
};
}}),
"[project]/node_modules/@okxconnect/universal-provider/src/provider/constants/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/constants/values.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/constants/events.js [app-client] (ecmascript)"), exports);
}}),
"[project]/node_modules/@okxconnect/universal-provider/src/provider/providers/rpc/JsonRpcProvider.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.JsonRpcProvider = void 0;
const eventemitter3_1 = __turbopack_require__("[project]/node_modules/eventemitter3/index.js [app-client] (ecmascript)");
const types_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/types/index.js [app-client] (ecmascript)");
const core_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/index.js [app-client] (ecmascript)");
const core_2 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/index.js [app-client] (ecmascript)");
class JsonRpcProvider extends types_1.IJSONRpcProvider {
    constructor(connection){
        super(connection);
        this.events = new eventemitter3_1.EventEmitter();
        this.connected = false;
        this.connecting = false;
        this.hasRegisteredEventListeners = false;
        this.connection = this.setConnection(connection);
        if (this.connection.connected) {
            this.registerEventListeners();
        }
    }
    connect() {
        return __awaiter(this, arguments, void 0, function*(connection = this.connection) {
            yield this.open(connection);
        });
    }
    disconnect() {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.close();
        });
    }
    on(event, listener) {
        this.events.on(event, listener);
    }
    once(event, listener) {
        this.events.once(event, listener);
    }
    off(event, listener) {
        this.events.off(event, listener);
    }
    removeListener(event, listener) {
        this.events.removeListener(event, listener);
    }
    request(request, context) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.requestStrict((0, core_1.formatJsonRpcRequest)(request.method, request.params || [], (0, core_1.getBigIntRpcId)().toString()), context);
        });
    }
    // ---------- Protected ----------------------------------------------- //
    requestStrict(request, context) {
        return __awaiter(this, void 0, void 0, function*() {
            return new Promise((resolve, reject)=>__awaiter(this, void 0, void 0, function*() {
                    if (!this.connection.connected) {
                        try {
                            yield this.open();
                        } catch (e) {
                            reject(e);
                        }
                    }
                    this.events.on(`${request.id}`, (response)=>{
                        if ((0, core_1.isJsonRpcError)(response)) {
                            reject(response.error);
                        } else {
                            resolve(response.result);
                        }
                    });
                    try {
                        (0, core_2.logDebug)('[RPC] >>> send request', request, context);
                        yield this.connection.send(request, context);
                    } catch (e) {
                        reject(e);
                    }
                }));
        });
    }
    setConnection(connection = this.connection) {
        return connection;
    }
    onPayload(payload) {
        this.events.emit("payload", payload);
        if ((0, core_1.isJsonRpcResponse)(payload)) {
            this.events.emit(`${payload.id}`, payload);
        } else {
            this.events.emit("message", {
                type: payload.method,
                data: payload.params
            });
        }
    }
    onClose(event) {
        // Code 3000 indicates an abnormal closure signalled by the relay -> emit an error in this case.
        if (event && event.code === 3000) {
            this.events.emit("error", new Error(`WebSocket connection closed abnormally with code: ${event.code} ${event.reason ? `(${event.reason})` : ""}`));
        }
        this.events.emit("disconnect");
    }
    open() {
        return __awaiter(this, arguments, void 0, function*(connection = this.connection) {
            if (this.connection === connection && this.connection.connected) return;
            if (this.connection.connected) this.close();
            if (typeof connection === "string") {
                yield this.connection.open(connection);
                connection = this.connection;
            }
            this.connection = this.setConnection(connection);
            yield this.connection.open();
            this.registerEventListeners();
            this.events.emit("connect");
        });
    }
    close() {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.connection.close();
        });
    }
    // ---------- Private ----------------------------------------------- //
    registerEventListeners() {
        if (this.hasRegisteredEventListeners) return;
        this.connection.on("payload", (payload)=>this.onPayload(payload));
        this.connection.on("close", (event)=>this.onClose(event));
        this.connection.on("error", (error)=>this.events.emit("error", error));
        this.connection.on("register_error", (_error)=>this.onClose());
        this.hasRegisteredEventListeners = true;
    }
}
exports.JsonRpcProvider = JsonRpcProvider;
}}),
"[project]/node_modules/@okxconnect/universal-provider/src/provider/providers/rpc/JsonRpcConnection.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.JsonRpcConnection = void 0;
const eventemitter3_1 = __turbopack_require__("[project]/node_modules/eventemitter3/index.js [app-client] (ecmascript)");
const cross_fetch_1 = __importDefault(__turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/node_modules/cross-fetch/dist/browser-ponyfill.js [app-client] (ecmascript)"));
const core_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/index.js [app-client] (ecmascript)");
const core_2 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/index.js [app-client] (ecmascript)");
const DEFAULT_HTTP_HEADERS = {
    Accept: "application/json",
    "Content-Type": "application/json"
};
const DEFAULT_HTTP_METHOD = "POST";
const DEFAULT_FETCH_OPTS = {
    headers: DEFAULT_HTTP_HEADERS,
    method: DEFAULT_HTTP_METHOD
};
// Source: https://nodejs.org/api/events.html#emittersetmaxlistenersn
const EVENT_EMITTER_MAX_LISTENERS_DEFAULT = 10;
class JsonRpcConnection {
    constructor(url, disableProviderPing = false){
        this.url = url;
        this.disableProviderPing = disableProviderPing;
        this.events = new eventemitter3_1.EventEmitter();
        this.isAvailable = false;
        this.registering = false;
        if (!(0, core_2.isHttpUrl)(url)) {
            throw new Error(`Provided URL is not compatible with HTTP connection: ${url}`);
        }
        this.url = url;
        this.disableProviderPing = disableProviderPing;
    }
    get connected() {
        return this.isAvailable;
    }
    get connecting() {
        return this.registering;
    }
    on(event, listener) {
        this.events.on(event, listener);
    }
    once(event, listener) {
        this.events.once(event, listener);
    }
    off(event, listener) {
        this.events.off(event, listener);
    }
    removeListener(event, listener) {
        this.events.removeListener(event, listener);
    }
    open() {
        return __awaiter(this, arguments, void 0, function*(url = this.url) {
            yield this.register(url);
        });
    }
    close() {
        return __awaiter(this, void 0, void 0, function*() {
            if (!this.isAvailable) {
                throw new Error("Connection already closed");
            }
            this.onClose();
        });
    }
    send(payload) {
        return __awaiter(this, void 0, void 0, function*() {
            if (!this.isAvailable) {
                yield this.register();
            }
            try {
                const body = (0, core_1.safeJsonStringify)(payload);
                const res = yield (0, cross_fetch_1.default)(this.url, Object.assign(Object.assign({}, DEFAULT_FETCH_OPTS), {
                    body
                }));
                const data = yield res.json();
                this.onPayload({
                    data
                });
            } catch (e) {
                this.onError(payload.id, e);
            }
        });
    }
    // ---------- Private ----------------------------------------------- //
    register() {
        return __awaiter(this, arguments, void 0, function*(url = this.url) {
            if (!(0, core_2.isHttpUrl)(url)) {
                throw new Error(`Provided URL is not compatible with HTTP connection: ${url}`);
            }
            if (this.registering) {
                return new Promise((resolve, reject)=>{
                    this.events.once("register_error", (error)=>{
                        reject(error);
                    });
                    this.events.once("open", ()=>{
                        if (typeof this.isAvailable === "undefined") {
                            return reject(new Error("HTTP connection is missing or invalid"));
                        }
                        resolve();
                    });
                });
            }
            this.url = url;
            this.registering = true;
            try {
                if (!this.disableProviderPing) {
                    const body = (0, core_1.safeJsonStringify)({
                        id: 1,
                        jsonrpc: "2.0",
                        method: "test",
                        params: []
                    });
                    yield (0, cross_fetch_1.default)(url, Object.assign(Object.assign({}, DEFAULT_FETCH_OPTS), {
                        body
                    }));
                }
                this.onOpen();
            } catch (e) {
                const error = this.parseError(e);
                this.events.emit("register_error", error);
                this.onClose();
                throw error;
            }
        });
    }
    onOpen() {
        this.isAvailable = true;
        this.registering = false;
        this.events.emit("open");
    }
    onClose() {
        this.isAvailable = false;
        this.registering = false;
        this.events.emit("close");
    }
    onPayload(e) {
        if (typeof e.data === "undefined") return;
        const payload = typeof e.data === "string" ? (0, core_1.safeJsonParse)(e.data) : e.data;
        this.events.emit("payload", payload);
    }
    onError(id, e) {
        const error = this.parseError(e);
        const message = error.message || error.toString();
        const payload = (0, core_2.formatJsonRpcError)(id, message);
        this.events.emit("payload", payload);
    }
    parseError(e, url = this.url) {
        return (0, core_2.parseConnectionError)(e, url, "HTTP");
    }
}
exports.JsonRpcConnection = JsonRpcConnection;
}}),
"[project]/node_modules/@okxconnect/universal-provider/src/provider/providers/eip155.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Eip155Provider = void 0;
const utils_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/utils/index.js [app-client] (ecmascript)");
const constants_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/constants/index.js [app-client] (ecmascript)");
const core_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/index.js [app-client] (ecmascript)");
const JsonRpcProvider_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/providers/rpc/JsonRpcProvider.js [app-client] (ecmascript)");
const JsonRpcConnection_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/providers/rpc/JsonRpcConnection.js [app-client] (ecmascript)");
class Eip155Provider {
    constructor(opts, client, events){
        this.name = "eip155";
        this.namespace = opts.namespace;
        this.events = events;
        this.client = client;
        this.chainId = parseInt(this.getDefaultChain());
        // rpc
        this.httpProviders = this.createHttpProviders();
        (0, core_1.logDebug)("eip155 constructor --opts.namespace-->", opts.namespace);
    }
    isRecord(value) {
        return typeof value === "object" && value !== null && !Array.isArray(value);
    }
    isArray(value) {
        return typeof value === "object" && value !== null && Array.isArray(value);
    }
    updateRequestParams(args) {
        let isDic = args.params && typeof args.params === 'object' && !Array.isArray(args.params);
        if (args.method === 'wallet_switchEthereumChain') {
            const switchChainId = args.chainId.split(":")[1];
            // const hexChainId = parseInt(switchChainId, 16);
            const decimalNumber = parseInt(switchChainId, 10);
            if (isNaN(decimalNumber)) {
                throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.NOT_CONNECTED_ERROR, `Invalid decimal number,  chainId: '${switchChainId}' `);
            }
            if (!args.params) {
                args.params = {
                    chainId: '0x' + decimalNumber.toString(16)
                };
            } else if (isDic) {
                let params = args.params;
                if (!('chainId' in params)) {
                    params['chainId'] = '0x' + decimalNumber.toString(16);
                    args.params = params;
                }
            } else {
                throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.NOT_CONNECTED_ERROR, `Request params error ,  method: '${args.method}' `);
            }
        } else if (args.method === 'personal_sign' || args.method === 'eth_signTypedData_v4' || args.method === 'eth_sendTransaction' || args.method === 'wallet_watchAsset') {
            if (!args.params) {
                throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.NOT_CONNECTED_ERROR, `Request params is nil, method: '${args.method}'`);
            }
            if (this.isRecord(args.params)) {
                let params = args.params;
                (0, core_1.logDebug)("eip155 updateRequestParams params>", JSON.stringify(params));
                if ('chainId' in params) {
                    const selectedChainId = args.chainId.split(":")[1];
                    const chainNum = parseInt(selectedChainId, 10);
                    let paramsChainString = String(params.chainId);
                    let paramsChainId;
                    if (paramsChainString.startsWith(this.name) && args.chainId === paramsChainString) {
                        paramsChainId = chainNum;
                    } else if (paramsChainString.startsWith("0x")) {
                        paramsChainId = parseInt(paramsChainString, 16);
                    } else if (!isNaN(Number(paramsChainString))) {
                        paramsChainId = parseInt(paramsChainString, 10);
                    } else {
                        throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.NOT_CONNECTED_ERROR, `Invalid params.chainId format, method: '${args.method}'`);
                    }
                    if (chainNum !== paramsChainId) {
                        throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.NOT_CONNECTED_ERROR, `Request params.chainId not equal chain,  method: '${args.method}' `);
                    }
                }
            } else {
                throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.NOT_CONNECTED_ERROR, `Invalid request params type, method: '${args.method}'`);
            }
        }
    }
    //adapt array
    adaptArray(args) {
        if (args.method === 'wallet_switchEthereumChain' || args.method === 'wallet_addEthereumChain' || args.method === 'wallet_watchAsset' || args.method === 'eth_sendTransaction') {
            if (this.isArray(args.params)) {
                let paramsArr = args.params;
                if (paramsArr) {
                    if (paramsArr.length === 1) {
                        let firstParam = args.params[0];
                        if (this.isRecord(firstParam)) {
                            args.params = firstParam;
                        }
                    } else if (paramsArr.length > 1) {
                        throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `Request params only Support one data,  method: '${args.method}' `);
                    } else {
                        throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `Request params is nil,  method: '${args.method}' `);
                    }
                }
            }
        } else if (args.method === 'eth_signTypedData_v4') {
            if (this.isArray(args.params)) {
                let paramsArr = args.params;
                if (paramsArr && paramsArr.length > 2) {
                    throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `Request params only Support one data,  method: '${args.method}' `);
                } else if (paramsArr && paramsArr.length === 0) {
                    throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `Request params is nil,  method: '${args.method}' `);
                }
                let messageObj = {};
                if (paramsArr && paramsArr.length === 2) {
                    let addressObj = args.params[0]; //address
                    if (addressObj && typeof addressObj === 'string') {
                        let isEqual = false;
                        this.namespace.accounts.forEach((account)=>{
                            let chainAddress = (0, utils_1.fromAccountToAddress)(account);
                            if (chainAddress.toLowerCase() === addressObj.toLowerCase()) {
                                isEqual = true;
                            }
                        });
                        (0, core_1.logDebug)("eip155 adaptArray eth_signTypedData_v4 >>>isEqual: ", isEqual);
                        if (!isEqual) {
                            throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `Request params address error, not equal,  method: '${args.method}' `);
                        }
                        if (this.isRecord(args.params[1])) {
                            messageObj = args.params[1];
                        } else {
                            throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `Request params message data error,  method: '${args.method}' `);
                        }
                    } else {
                        throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `Request params address error , not string,  method: '${args.method}' `);
                    }
                } else if (paramsArr && paramsArr.length === 1) {
                    if (this.isRecord(args.params[0])) {
                        messageObj = args.params[0];
                    } else {
                        throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `Request params message data error,  method: '${args.method}' `);
                    }
                }
                try {
                    let messages = JSON.stringify(messageObj);
                    args.params = {
                        typedDataJson: messages
                    };
                } catch (err) {
                    throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `Request params call JSON.stringify() failed,  method: '${args.method}' `);
                }
            }
        } else if (args.method === 'personal_sign') {
            if (this.isArray(args.params)) {
                if (args.params && args.params.length > 2) {
                    throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `Request params error,  method: '${args.method}' `);
                } else if (args.params && args.params.length === 0) {
                    throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `Request params is nil,  method: '${args.method}' `);
                }
                let firstObj = args.params[0];
                let secondObj = args.params[1];
                if (secondObj && typeof secondObj === 'string') {
                    let isEqual = false;
                    this.namespace.accounts.forEach((account)=>{
                        let chainAddress = (0, utils_1.fromAccountToAddress)(account);
                        if (chainAddress.toLowerCase() === secondObj.toLowerCase()) {
                            isEqual = true;
                        }
                    });
                    (0, core_1.logDebug)("eip155 adaptArray personal_sign >>>isEqual: ", isEqual);
                    if (!isEqual) {
                        throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `Request params address error,  method: '${args.method}' `);
                    }
                }
                if (firstObj && typeof firstObj === 'string') {
                    args.params = {
                        message: firstObj
                    };
                } else {
                    throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `Request params is error,  method: '${args.method}' `);
                }
            }
        }
    }
    showRequestModal(args) {
        switch(args.method){
            case "eth_requestAccounts":
            case "eth_accounts":
            case "eth_chainId":
                return false;
            case "eth_sendTransaction":
            case "eth_signTransaction":
            case "eth_sign":
            case "personal_sign":
            case "eth_signTypedData":
            case "wallet_addEthereumChain":
            case "wallet_watchAsset":
            case "eth_signTypedData_v4":
                return true;
            case "wallet_switchEthereumChain":
                {
                    this.adaptArray(args);
                    this.updateRequestParams(args);
                    const { parsedChainId, hexChainId } = this.getHexChainIdFromRequest(args);
                    return !this.isChainApproved(parsedChainId);
                }
            default:
                return false;
        }
        return false;
    }
    request(args) {
        return __awaiter(this, void 0, void 0, function*() {
            this.adaptArray(args);
            (0, core_1.logDebug)("eip155 request --args--string>", JSON.stringify(args));
            this.updateRequestParams(args);
            (0, core_1.logDebug)("eip155 request --params--string>", JSON.stringify(args));
            switch(args.method){
                case "eth_requestAccounts":
                    return this.getAccounts();
                case "eth_accounts":
                    return this.getAccounts();
                case "eth_chainId":
                    return parseInt(this.getDefaultChain());
                case "wallet_switchEthereumChain":
                    {
                        return yield this.handleSwitchChain(args);
                    }
                case "wallet_addEthereumChain":
                    return this.addEthereumChain(args);
                default:
                    break;
            }
            if (this.namespace.methods.includes(args.method)) {
                // personal_sign
                // eth_signTypedData_v4
                // eth_sendTransaction
                // wallet_watchAsset
                try {
                    const response = yield this.client.request(args);
                    (0, core_1.logDebug)("eip155 request --response----string>", JSON.stringify(response));
                    if (this.isRecord(response)) {
                        if ('result' in response) {
                            let result = response.result;
                            if (result && typeof result === 'string' && (result === "true" || result === "false")) {
                                (0, core_1.logDebug)("eip155 request --wallet_watchAsset>>>>", result === "true");
                                return result === "true";
                            }
                            return response.result;
                        }
                    }
                    return response;
                } catch (e) {
                    (0, core_1.logDebug)(`eip155 request --response --error--string> e instanceof OKXConnectError ${e instanceof core_1.OKXConnectError}`, JSON.stringify(e));
                    throw e;
                }
            } else {
                (0, core_1.logDebug)('[RPC] request begin');
                return yield this.getHttpProvider().request(args);
            }
        });
    }
    addEthereumChain(args) {
        return __awaiter(this, void 0, void 0, function*() {
            let resultData = yield this.client.request(args);
            try {
                if ('result' in resultData) {
                    let successData = resultData;
                    let account = resultData.result;
                    if (account) {
                        const nameSpace = account.split(":")[0];
                        const chainId = account.split(":")[1];
                        const chain = nameSpace + ':' + chainId;
                        let newNameSpace = this.namespace;
                        this.namespace.accounts.push(account);
                        this.namespace.chains.push(chain);
                        if (this.isRecord(args.params)) {
                            if ("rpcUrls" in args.params) {
                                let rpcUrls = args.params.rpcUrls;
                                let rpcUrl = rpcUrls ? rpcUrls[0] : undefined;
                                if (rpcUrl) {
                                    if (this.namespace.rpcMap) {
                                        this.namespace.rpcMap[chainId] = rpcUrl;
                                    } else {
                                        this.namespace.rpcMap = {
                                            [chainId]: rpcUrl
                                        };
                                    }
                                    this.setHttpProvider(chainId, rpcUrl);
                                }
                            }
                        }
                        this.events.emit(constants_1.PROVIDER_EVENTS.UPDATE_NAMESPACES, {
                            eip155: this.namespace
                        });
                    }
                } else {
                    new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `the method ${args.method} request error`);
                }
            } catch (error) {
                throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `the method ${args.method} request  error`);
            }
            return null;
        });
    }
    updateNamespace(namespace) {
        this.namespace = Object.assign(this.namespace, namespace);
    }
    setDefaultChain(chainId, rpcUrl) {
        this.chainId = parseInt(chainId);
        // set rpc
        if (!this.httpProviders[chainId]) {
            const rpc = rpcUrl || (0, utils_1.getRpcUrl)(`${this.name}:${chainId}`, this.namespace);
            if (!rpc) {
                // throw new Error(`No RPC url provided for chainId: ${chainId}`);
                (0, core_1.logError)(`No RPC url provided for chainId: ${chainId}`);
            } else {
                this.setHttpProvider(chainId, rpc);
            }
        }
        this.events.emit(constants_1.PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${chainId}`);
    }
    requestAccounts() {
        return this.getAccounts();
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId.toString();
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const chainId = this.namespace.chains[0];
        if (!chainId) throw new Error(`ChainId not found`);
        return chainId.split(":")[1];
    }
    // ---------- Private ----------------------------------------------- //
    getAccounts() {
        const accounts = this.namespace.accounts;
        (0, core_1.logDebug)("eip155 getAccounts ", accounts, this.chainId);
        if (!accounts) {
            return [];
        }
        return [
            ...new Set(accounts// get the accounts from the active chain
            .filter((account)=>account.split(":")[1] === this.chainId.toString())// remove namespace & chainId from the string
            .map((account)=>{
                return (0, utils_1.fromAccountToAddress)(account);
            }))
        ];
    }
    getHexChainIdFromRequest(args) {
        let params = args.params;
        let hexChainId = "0x0";
        if (params && "chainId" in params) {
            hexChainId = params.chainId;
        }
        hexChainId = hexChainId.startsWith("0x") ? hexChainId : `0x${hexChainId}`;
        (0, core_1.logDebug)("handleSwitchChain -->args ", args);
        (0, core_1.logDebug)("handleSwitchChain -->hexChainId ", hexChainId);
        const parsedChainId = parseInt(hexChainId, 16);
        (0, core_1.logDebug)("handleSwitchChain -->parsedChainId ", parsedChainId);
        return {
            parsedChainId,
            hexChainId
        };
    }
    handleSwitchChain(args) {
        return __awaiter(this, void 0, void 0, function*() {
            const { parsedChainId, hexChainId } = this.getHexChainIdFromRequest(args);
            if (this.isChainApproved(parsedChainId)) {
                this.setDefaultChain(`${parsedChainId}`);
            } else {
                const resultData = yield this.client.request({
                    method: "wallet_switchEthereumChain",
                    chainId: args.chainId,
                    params: {
                        chainId: hexChainId
                    }
                });
                try {
                    if ('result' in resultData) {
                        let successData = resultData;
                        let account = resultData.result;
                        if (account) {
                            const nameSpace = account.split(":")[0];
                            const chainId = account.split(":")[1];
                            const chain = nameSpace + ':' + chainId;
                            let newNameSpace = this.namespace;
                            this.namespace.accounts.push(account);
                            this.namespace.chains.push(chain);
                            (0, core_1.logDebug)("handleSwitchChain -->wallet_switchEthereumChain ", resultData);
                            this.setDefaultChain(`${parsedChainId}`);
                            this.events.emit(constants_1.PROVIDER_EVENTS.UPDATE_NAMESPACES, {
                                eip155: this.namespace
                            });
                        }
                    } else {
                        new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `the method ${args.method} request error`);
                    }
                } catch (error) {
                    throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `the method ${args.method} request  error`);
                }
            }
            return null;
        });
    }
    isChainApproved(chainId) {
        return this.namespace.chains.includes(`${this.name}:${chainId}`);
    }
    // rpc
    createHttpProvider(chainId, rpcUrl) {
        // 没有备用rpc对外提供
        const rpc = rpcUrl;
        if (!rpc) {
            (0, core_1.logError)(`No RPC url provided for chainId: ${chainId}`);
        //   throw new Error(`No RPC url provided for chainId: ${chainId}`);
        } else {
            const http = new JsonRpcProvider_1.JsonRpcProvider(new JsonRpcConnection_1.JsonRpcConnection(rpc, (0, utils_1.getGlobal)("disableProviderPing")));
            return http;
        }
    }
    createHttpProviders() {
        const http = {};
        this.namespace.chains.forEach((chain)=>{
            const parsedChainId = (0, utils_1.getChainId)(chain);
            const parsedRpc = (0, utils_1.getRpcUrl)(chain, this.namespace);
            (0, core_1.logDebug)('get parsed chain and rpc:', parsedChainId, parsedRpc);
            let httpProvider = this.createHttpProvider(parsedChainId, parsedRpc);
            if (httpProvider) {
                http[parsedChainId] = httpProvider;
            }
        });
        (0, core_1.logDebug)('get http providermap:', http);
        return http;
    }
    setHttpProvider(chainId, rpcUrl) {
        const http = this.createHttpProvider(chainId, rpcUrl);
        if (http) {
            this.httpProviders[chainId] = http;
        }
    }
    getHttpProvider() {
        const chain = `${this.chainId}`;
        const http = this.httpProviders[chain];
        (0, core_1.logDebug)('[RPC] get http provider:', chain, http);
        if (typeof http === "undefined") {
            throw new Error(`JSON-RPC provider for ${chain} not found`);
        }
        return http;
    }
}
exports.Eip155Provider = Eip155Provider;
exports.default = Eip155Provider;
}}),
"[project]/node_modules/@okxconnect/universal-provider/src/provider/providers/sui.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SuiProvider = void 0;
const constants_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/constants/index.js [app-client] (ecmascript)");
const core_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/index.js [app-client] (ecmascript)");
const utils_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/utils/index.js [app-client] (ecmascript)");
const JsonRpcConnection_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/providers/rpc/JsonRpcConnection.js [app-client] (ecmascript)");
const JsonRpcProvider_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/providers/rpc/JsonRpcProvider.js [app-client] (ecmascript)");
class SuiProvider {
    constructor(opts, client, events){
        this.name = core_1.NameSpaceKeySui;
        this.namespace = opts.namespace;
        this.events = events;
        this.client = client;
        this.chainId = this.getDefaultChain();
        this.httpProviders = this.createHttpProviders();
    }
    updateNamespace(namespace) {
        this.namespace = Object.assign(this.namespace, namespace);
    }
    request(args) {
        return __awaiter(this, void 0, void 0, function*() {
            (0, core_1.logDebug)("sui request --args--string>", JSON.stringify(args));
            (0, core_1.logDebug)("sui provider namespace: ", this.namespace);
            if (this.namespace.methods.includes(args.method)) {
                return this.client.request(args);
            }
            return this.getHttpProvider().request(args);
        });
    }
    requestAccounts() {
        return this.getAccounts();
    }
    setDefaultChain(chainId, rpcUrl) {
        if (!this.httpProviders[chainId]) {
            this.setHttpProvider(chainId, rpcUrl);
        }
        this.chainId = chainId;
        this.events.emit(constants_1.PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${chainId}`);
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const chainId = this.namespace.chains[0];
        if (!chainId) throw new Error(`ChainId not found`);
        return chainId.split(":")[1];
    }
    // --------- PRIVATE --------- //
    getAccounts() {
        const accounts = this.namespace.accounts;
        if (!accounts) {
            return [];
        }
        return [
            ...new Set(accounts// get the accounts from the active chain
            .filter((account)=>account.split(":")[1] === this.chainId.toString())// remove namespace & chainId from the string
            .map((account)=>account.split(":")[2]))
        ];
    }
    createHttpProviders() {
        const http = {};
        this.namespace.chains.forEach((chain)=>{
            const parsedChainId = (0, utils_1.getChainId)(chain);
            const parsedRpc = (0, utils_1.getRpcUrl)(chain, this.namespace);
            let httpProvider = this.createHttpProvider(parsedChainId, parsedRpc);
            if (httpProvider) {
                http[parsedChainId] = httpProvider;
            }
        });
        return http;
    }
    getHttpProvider() {
        const chain = `${this.chainId}`;
        const http = this.httpProviders[chain];
        (0, core_1.logDebug)('[RPC] get http provider:', chain, http);
        if (typeof http === "undefined") {
            throw new Error(`JSON-RPC provider for ${chain} not found`);
        }
        return http;
    }
    setHttpProvider(chainId, rpcUrl) {
        const http = this.createHttpProvider(chainId, rpcUrl);
        if (http) {
            (0, core_1.logDebug)("setHttpProvider", chainId, rpcUrl);
            this.httpProviders[chainId] = http;
        }
    }
    createHttpProvider(chainId, rpcUrl) {
        // 没有备用rpc对外提供
        const rpc = rpcUrl;
        if (!rpc) {
            (0, core_1.logError)(`No RPC url provided for chainId: ${chainId}`);
        // throw new Error(`No RPC url provided for chainId: ${chainId}`);
        } else {
            const http = new JsonRpcProvider_1.JsonRpcProvider(new JsonRpcConnection_1.JsonRpcConnection(rpc, (0, utils_1.getGlobal)("disableProviderPing")));
            return http;
        }
    }
    getPubkey(chainId) {
        return this.getWalletAddress(chainId);
    }
    getWalletAddress(chainId) {
        if (!chainId) {
            chainId = this.namespace.defaultChain;
            if (!(chainId === null || chainId === void 0 ? void 0 : chainId.startsWith("sui"))) {
                chainId = `sui:${chainId}`;
            }
        }
        return this.namespace.accounts.filter(function(account) {
            let components = account.split(":");
            return components.length > 2 && account.startsWith(chainId);
        }).map(function(account) {
            let components = account.split(":");
            return components[2];
        })[0];
    }
    showRequestModal(args) {
        switch(args.method){
            case "sui_signMessage":
            case "sui_signPersonalMessage":
            case "sui_signTransactionBlock":
            case "sui_signAndExecuteTransactionBlock":
                return true;
            default:
                return false;
        }
        return false;
    }
}
exports.SuiProvider = SuiProvider;
exports.default = SuiProvider;
}}),
"[project]/node_modules/@okxconnect/universal-provider/src/packages/utils/namespaces.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getAccountsChains = getAccountsChains;
exports.nameSpaceToConnectWalletNameSpace = nameSpaceToConnectWalletNameSpace;
exports.fillParamsToSession = fillParamsToSession;
exports.isCaipNamespace = isCaipNamespace;
exports.parseNamespaceKey = parseNamespaceKey;
const core_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/index.js [app-client] (ecmascript)");
function getAccountsChains(accounts) {
    const chains = [];
    accounts.forEach((account)=>{
        const [chain, chainId] = account.split(":");
        chains.push(`${chain}:${chainId}`);
    });
    return chains;
}
function nameSpaceToConnectWalletNameSpace(namespaces) {
    var result = [];
    if (!namespaces) {
        return result;
    }
    Object.keys(namespaces).forEach((key)=>{
        if (key === core_1.NameSpaceKeyEip155 || key === core_1.NameSpaceKeySOL || key === core_1.NameSpaceKeySui || key === core_1.NameSpaceKeyAptos || key == core_1.NameSpaceKeyBtc || key === core_1.NameSpaceKeyTON || key === core_1.NameSpaceKeyCosmos || key === core_1.NameSpaceKeyTron || key === core_1.NameSpaceKeyStarknet) {
            if (namespaces[key].chains) {
                result.push({
                    namespace: key,
                    chains: namespaces[key].chains,
                    params: namespaces[key].params
                });
            }
        }
    });
    return result;
}
function fillParamsToSession(session, namespaces, optionalNamespaces, sessionConfig) {
    // Helper function to merge rpcMaps
    const mergeRpcMap = (targetRpcMap, sourceRpcMap)=>{
        Object.assign(targetRpcMap, sourceRpcMap);
    };
    // Merge function for namespaces
    const mergeNamespaces = (target, source)=>{
        for(const key in source){
            if (source.hasOwnProperty(key) && source[key].rpcMap) {
                if (source[key].rpcMap) {
                    if (!target[key].rpcMap) {
                        target[key].rpcMap = {};
                    }
                    // 合并 rpcMap
                    mergeRpcMap(target[key].rpcMap, source[key].rpcMap);
                }
                if (source[key].defaultChain && target[key].defaultChain === undefined) {
                    //defaultChain need in session nameSpace
                    if (target[key].chains.some((chain)=>chain.split(":")[1] === source[key].defaultChain)) {
                        target[key].defaultChain = source[key].defaultChain;
                    }
                }
            }
        }
    };
    // 合并 namespaces
    if (namespaces) {
        mergeNamespaces(session.namespaces, namespaces);
    }
    // 合并 optionalNamespaces
    if (optionalNamespaces) {
        mergeNamespaces(session.namespaces, optionalNamespaces);
    }
    for(const key in session.namespaces){
        const namespace = session.namespaces[key];
        if (!(namespace === null || namespace === void 0 ? void 0 : namespace.accounts) || namespace.accounts.length === 0) {
            delete session.namespaces[key];
        }
    }
    session.sessionConfig = sessionConfig;
}
/**
 * util designed for Wallets that builds namespaces structure by provided supported chains, methods, events & accounts.
 * It takes required & optional namespaces provided in the session proposal
 * along with the supported chains/methods/events/accounts by the wallet and returns a structured namespaces object
 * @param {BuildApprovedNamespacesParams} params
 * @returns {SessionTypes.Namespaces}
 */ // export function buildApprovedNamespaces(
//   params: BuildApprovedNamespacesParams,
// ): SessionTypes.Namespaces {
//   const {
//     proposal: { requiredNamespaces, optionalNamespaces = {} },
//     supportedNamespaces,
//   } = params;
//   const normalizedRequired = normalizeNamespaces(requiredNamespaces);
//   const normalizedOptional = normalizeNamespaces(optionalNamespaces);
//
//   // build approved namespaces
//   const namespaces = {};
//   Object.keys(supportedNamespaces).forEach((namespace) => {
//     const supportedChains = supportedNamespaces[namespace].chains;
//     const supportedMethods = supportedNamespaces[namespace].methods;
//     const supportedEvents = supportedNamespaces[namespace].events;
//     const supportedAccounts = supportedNamespaces[namespace].accounts;
//
//     supportedChains.forEach((chain) => {
//       if (!supportedAccounts.some((account) => account.includes(chain))) {
//         throw new Error(`No accounts provided for chain ${chain} in namespace ${namespace}`);
//       }
//     });
//
//     namespaces[namespace] = {
//       chains: supportedChains,
//       methods: supportedMethods,
//       events: supportedEvents,
//       accounts: supportedAccounts,
//     };
//   });
//
//   // verify all required namespaces are supported
//   const err = isConformingNamespaces(requiredNamespaces, namespaces, "approve()");
//   if (err) throw new Error(err.message);
//
//   const approvedNamespaces = {};
//
//   // if both required & optional namespaces are empty, return all supported namespaces by the wallet
//   if (!Object.keys(requiredNamespaces).length && !Object.keys(optionalNamespaces).length)
//     return namespaces;
//
//   // assign accounts for the required namespaces
//   Object.keys(normalizedRequired).forEach((requiredNamespace) => {
//     const chains = supportedNamespaces[requiredNamespace].chains.filter((chain) =>
//       normalizedRequired[requiredNamespace]?.chains?.includes(chain),
//     );
//     const methods = supportedNamespaces[requiredNamespace].methods.filter((method) =>
//       normalizedRequired[requiredNamespace]?.methods?.includes(method),
//     );
//     const events = supportedNamespaces[requiredNamespace].events.filter((event) =>
//       normalizedRequired[requiredNamespace]?.events?.includes(event),
//     );
//
//     const accounts = chains
//       .map((chain: string) =>
//         supportedNamespaces[requiredNamespace].accounts.filter((account: string) =>
//           account.includes(`${chain}:`),
//         ),
//       )
//       .flat();
//
//     approvedNamespaces[requiredNamespace] = {
//       chains,
//       methods,
//       events,
//       accounts,
//     };
//   });
//
//   // add optional namespaces
//   Object.keys(normalizedOptional).forEach((optionalNamespace) => {
//     if (!supportedNamespaces[optionalNamespace]) return;
//
//     const chainsToAdd = normalizedOptional[optionalNamespace]?.chains?.filter((chain) =>
//       supportedNamespaces[optionalNamespace].chains.includes(chain),
//     );
//     const methodsToAdd = supportedNamespaces[optionalNamespace].methods.filter((method) =>
//       normalizedOptional[optionalNamespace]?.methods?.includes(method),
//     );
//     const eventsToAdd = supportedNamespaces[optionalNamespace].events.filter((event) =>
//       normalizedOptional[optionalNamespace]?.events?.includes(event),
//     );
//
//     const accountsToAdd = chainsToAdd
//       ?.map((chain: string) =>
//         supportedNamespaces[optionalNamespace].accounts.filter((account: string) =>
//           account.includes(`${chain}:`),
//         ),
//       )
//       .flat();
//
//     approvedNamespaces[optionalNamespace] = {
//       chains: mergeArrays(approvedNamespaces[optionalNamespace]?.chains, chainsToAdd),
//       methods: mergeArrays(approvedNamespaces[optionalNamespace]?.methods, methodsToAdd),
//       events: mergeArrays(approvedNamespaces[optionalNamespace]?.events, eventsToAdd),
//       accounts: mergeArrays(approvedNamespaces[optionalNamespace]?.accounts, accountsToAdd),
//     };
//   });
//
//   return approvedNamespaces;
// }
function isCaipNamespace(namespace) {
    return namespace.includes(":");
}
function parseNamespaceKey(namespace) {
    return isCaipNamespace(namespace) ? namespace.split(":")[0] : namespace;
} /**
 * Converts
 * ```
 * {
 *  "eip155:1": {...},
 *  "eip155:2": {...},
 * }
 * ```
 * into
 * ```
 * {
 *  "eip155": {
 *      chains: ["eip155:1", "eip155:2"],
 *      ...
 *    }
 * }
 *```
 */  // export function normalizeNamespaces(
 //   namespaces: ProposalTypes.RequiredNamespaces,
 // ): ProposalTypes.RequiredNamespaces {
 //   const normalizedNamespaces = {} as ProposalTypes.RequiredNamespaces;
 //   if (!isValidObject(namespaces)) return normalizedNamespaces;
 //   for (const [key, values] of Object.entries(namespaces)) {
 //     const chains = isCaipNamespace(key) ? [key] : values.chains;
 //     const methods = values.methods || [];
 //     const events = values.events || [];
 //     const normalizedKey = parseNamespaceKey(key);
 //     normalizedNamespaces[normalizedKey] = {
 //       ...normalizedNamespaces[normalizedKey],
 //       chains: mergeArrays(chains, normalizedNamespaces[normalizedKey]?.chains),
 //       methods: mergeArrays(methods, normalizedNamespaces[normalizedKey]?.methods),
 //       events: mergeArrays(events, normalizedNamespaces[normalizedKey]?.events),
 //     };
 //   }
 //   return normalizedNamespaces;
 // }
 // export function getNamespacesFromAccounts(accounts: string[]) {
 //   const namespaces = {};
 //   accounts?.forEach((account) => {
 //     const [namespace, chainId] = account.split(":");
 //     if (!namespaces[namespace]) {
 //       namespaces[namespace] = {
 //         accounts: [],
 //         chains: [],
 //         events: [],
 //       };
 //     }
 //     namespaces[namespace].accounts.push(account);
 //     namespaces[namespace].chains.push(`${namespace}:${chainId}`);
 //   });
 //
 //   return namespaces;
 // }
}}),
"[project]/node_modules/@okxconnect/universal-provider/src/packages/sign-client/client.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SignClient = void 0;
const core_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/index.js [app-client] (ecmascript)");
const namespaces_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/packages/utils/namespaces.js [app-client] (ecmascript)");
const ConnectMethodUtils_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/packages/utils/ConnectMethodUtils.js [app-client] (ecmascript)");
const constants_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/constants/index.js [app-client] (ecmascript)");
class SignClient extends core_1.ISignClient {
    constructor(metaData, events){
        super(metaData);
        // ---------- Engine ----------------------------------------------- //
        this.connect = (params)=>__awaiter(this, void 0, void 0, function*() {
                return new Promise((resolve, reject)=>__awaiter(this, void 0, void 0, function*() {
                        try {
                            var connectRequest = [];
                            (0, core_1.logDebug)(`client connect params >>>`, JSON.stringify(params));
                            var requestAccountItem = {
                                name: "requestAccounts",
                                requiredNamespaces: (0, namespaces_1.nameSpaceToConnectWalletNameSpace)(params.namespaces),
                                optionalNamespaces: (0, namespaces_1.nameSpaceToConnectWalletNameSpace)(params.optionalNamespaces)
                            };
                            this.engine.setSessionConnectingListener(()=>{
                                (0, core_1.logDebug)(`sessionConnectingListener >>>`);
                                this.events.emit(constants_1.PROVIDER_EVENTS.SESSION_CONNECTING);
                            });
                            if (params.signRequest) {
                                requestAccountItem.connectRequestMethods = yield (0, ConnectMethodUtils_1.connectMethodsToConnectWalletMethods)(params.signRequest, requestAccountItem.requiredNamespaces);
                            }
                            connectRequest.push(requestAccountItem);
                            (0, core_1.logDebug)(`client connect connectRequest >>>`, JSON.stringify(connectRequest));
                            this.engine.universalConnect(connectRequest, Object.assign({
                                dappInfo: this.metadata
                            }, params.sessionConfig), (info)=>{
                                if (info && info.connectRequest) {
                                    (0, core_1.logDebug)(`universalConect info.connectRequest :`, info.connectRequest);
                                    (0, core_1.logDebug)(`universalConect url:`, (0, core_1.getOKXLink)(info.connectRequest, this.sessionConfig.useMini));
                                    this.events.emit("display_uri", (0, core_1.getOKXLink)(info.connectRequest, this.sessionConfig.useMini));
                                    this.events.emit("short_display_uri", (0, core_1.getAppWalletShortDeepLink)(info.connectRequest.topic, info.connectRequest.clientId));
                                    (0, core_1.logDebug)(`universalConect EngineConnectInfo  ${JSON.stringify(info)}`);
                                    this.events.emit("okx_engine_connect_params", info);
                                }
                            }).then((session)=>__awaiter(this, void 0, void 0, function*() {
                                    (0, namespaces_1.fillParamsToSession)(session, params.namespaces, params.optionalNamespaces, this.sessionConfig);
                                    (0, core_1.logDebug)(`signClient: connect: session ${JSON.stringify(session)}`);
                                    if (params.signRequest) {
                                        yield (0, ConnectMethodUtils_1.connectMethodsResponseUpdate)(session, params.signRequest);
                                    }
                                    resolve(session);
                                })).catch((e)=>{
                                (0, core_1.logDebug)(`signClient: connect: catch ${JSON.stringify(e)}`);
                                this.events.emit("connect_error", e);
                                reject(e);
                            });
                        } catch (error) {
                            (0, core_1.logDebug)(`signClient: connect:  ${JSON.stringify(error)}`);
                            reject(error);
                        }
                    }));
            });
        this.restoreconnect = (sessionConfig)=>__awaiter(this, void 0, void 0, function*() {
                return new Promise((resolve, reject)=>{
                    this.engine.restoreconnect(sessionConfig, (session)=>{
                        resolve(session);
                    });
                });
            });
        this.reject = (params)=>__awaiter(this, void 0, void 0, function*() {
            //   try {
            //     return await this.engine.reject(params);
            //   } catch (error: any) {
            //     this.logger.error(error.message);
            //     throw error;
            //   }
            });
        //
        // public update: ISignClient["update"] = async (params) => {
        //   return
        // //   try {
        // //     return await this.engine.update(params);
        // //   } catch (error: any) {
        // //     this.logger.error(error.message);
        // //     throw error;
        // //   }
        // };
        this.request = (params)=>__awaiter(this, void 0, void 0, function*() {
                return new Promise((resolve, reject)=>__awaiter(this, void 0, void 0, function*() {
                        var _a, _b;
                        (0, core_1.logDebug)("clint request --params>>>> >", this.engine.connectionManager.getCurrentConnectionReady(), (_a = this.sessionConfig) === null || _a === void 0 ? void 0 : _a.openUniversalUrl, JSON.stringify(params));
                        try {
                            // this.sessionConfig
                            if (((_b = this.sessionConfig) === null || _b === void 0 ? void 0 : _b.openUniversalUrl) && (0, core_1.isIos)()) {
                                this.openOKXWallet();
                            }
                            yield this.engine.send(params, {
                                resolve: (response)=>{
                                    delete response.requestId;
                                    (0, core_1.logDebug)("clint request --response >", JSON.stringify(response));
                                    if ('error' in response && response.error) {
                                        let error = response.error;
                                        reject(new core_1.OKXConnectError(response.error.code, response.method + ":" + error.message));
                                    } else {
                                        resolve(response);
                                    }
                                },
                                onAck: ()=>{
                                    var _a;
                                    if (!(0, core_1.isIos)() && ((_a = this.sessionConfig) === null || _a === void 0 ? void 0 : _a.openUniversalUrl)) {
                                        this.openOKXWallet();
                                    }
                                }
                            });
                        } catch (e) {
                            reject(e);
                        }
                    }));
            });
        // public emit: ISignClient["emit"] = async (params) => {
        //     try {
        //         // return await this.engine.emit(params);
        //     } catch (error: any) {
        //         throw error;
        //     }
        // };
        this.disconnect = ()=>__awaiter(this, void 0, void 0, function*() {
                return new Promise((resolve, reject)=>{
                    this.engine.send({
                        method: "disconnect"
                    }, {
                        onAck: ()=>{
                            resolve();
                        }
                    }, undefined, 86400000).catch((error)=>{
                        console.log(`disconnect : ${JSON.stringify(error)}`);
                        reject(error);
                    });
                });
            });
        this.engine = new core_1.Engine(new core_1.ConnectionManager(metaData.name));
        this.events = events;
        this.metadata = metaData;
    }
    openOKXWallet() {
        var _a;
        // if (this.openUniversalUrl){
        (0, core_1.logDebug)('bridge-provider ==>> connect_5');
        if ((_a = this.sessionConfig) === null || _a === void 0 ? void 0 : _a.useMini) {
            let url = (0, core_1.getTelegramWalletTWAUrl)(undefined, this.sessionConfig.tmaReturnUrl);
            (0, core_1.openOKXTMAWalletlinkWithFallback)(url);
        } else {
            (0, core_1.openOKXDeeplink)(core_1.standardDeeplink);
        }
    // }
    }
    syncAllAddress() {
        return __awaiter(this, void 0, void 0, function*() {
            return new Promise((resolve, reject)=>{
                this.engine.send({
                    method: "sync_all_addresses"
                }, {
                    resolve: (response)=>{
                        delete response.requestId;
                        (0, core_1.logDebug)("clint syncAllAddress --response >", JSON.stringify(response));
                        if ('error' in response && response.error) {
                            let error = response.error;
                            reject(new core_1.OKXConnectError(response.error.code, response.method + ":" + error.message));
                        } else {
                            let allAddressStr = response.result;
                            resolve((0, ConnectMethodUtils_1.syncResoonseToRequire)(allAddressStr));
                        }
                    }
                }).catch((error)=>{
                    console.log(`disconnect : ${JSON.stringify(error)}`);
                    reject(error);
                });
            });
        });
    }
}
exports.SignClient = SignClient;
}}),
"[project]/node_modules/@okxconnect/universal-provider/src/provider/providers/solana.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SolanaProvider = void 0;
const constants_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/constants/index.js [app-client] (ecmascript)");
const core_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/index.js [app-client] (ecmascript)");
const utils_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/utils/index.js [app-client] (ecmascript)");
const JsonRpcConnection_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/providers/rpc/JsonRpcConnection.js [app-client] (ecmascript)");
const JsonRpcProvider_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/providers/rpc/JsonRpcProvider.js [app-client] (ecmascript)");
class SolanaProvider {
    constructor(opts, name, client, events){
        this.name = "solana";
        this.namespace = opts.namespace;
        this.events = events;
        this.client = client;
        this.chainId = this.getDefaultChain();
        this.httpProviders = this.createHttpProviders();
        this.name = name;
    }
    updateNamespace(namespace) {
        this.namespace = Object.assign(this.namespace, namespace);
    }
    requestAccounts() {
        return this.getAccounts();
    }
    request(args) {
        return __awaiter(this, void 0, void 0, function*() {
            (0, core_1.logDebug)("solana request --args--string>", JSON.stringify(args));
            (0, core_1.logDebug)("solana provider namespace: ", this.namespace);
            if (this.namespace.methods.includes(args.method)) {
                return this.client.request(args);
            } else {
                throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.METHOD_NOT_SUPPORTED, "Please upgrade OKX APP");
            }
        });
    }
    setDefaultChain(chainId, rpcUrl) {
        // http provider exists so just set the chainId
        if (!this.httpProviders[chainId]) {
            this.setHttpProvider(chainId, rpcUrl);
        }
        this.chainId = chainId;
        this.events.emit(constants_1.PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${chainId}`);
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const chainId = this.namespace.chains[0];
        if (!chainId) throw new Error(`ChainId not found`);
        return chainId.split(":")[1];
    }
    // --------- PRIVATE --------- //
    getAccounts() {
        const accounts = this.namespace.accounts;
        if (!accounts) {
            return [];
        }
        return [
            ...new Set(accounts// get the accounts from the active chain
            .filter((account)=>account.split(":")[1] === this.chainId.toString())// remove namespace & chainId from the string
            .map((account)=>account.split(":")[2]))
        ];
    }
    createHttpProviders() {
        const http = {};
        this.namespace.chains.forEach((chain)=>{
            const parsedChainId = (0, utils_1.getChainId)(chain);
            const parsedRpc = (0, utils_1.getRpcUrl)(chain, this.namespace);
            let httpProvider = this.createHttpProvider(parsedChainId, parsedRpc);
            if (httpProvider) {
                http[parsedChainId] = httpProvider;
            }
        });
        return http;
    }
    getHttpProvider() {
        const chain = `${this.chainId}`;
        const http = this.httpProviders[chain];
        if (typeof http === "undefined") {
            throw new Error(`JSON-RPC provider for ${chain} not found`);
        }
        return http;
    }
    setHttpProvider(chainId, rpcUrl) {
        const http = this.createHttpProvider(chainId, rpcUrl);
        if (http) {
            this.httpProviders[chainId] = http;
        }
    }
    createHttpProvider(chainId, rpcUrl) {
        // 没有备用rpc对外提供
        const rpc = rpcUrl;
        if (!rpc) {
        // logError(`No RPC url provided for chainId: ${chainId}`);
        // throw new Error(`No RPC url provided for chainId: ${chainId}`);
        } else {
            const http = new JsonRpcProvider_1.JsonRpcProvider(new JsonRpcConnection_1.JsonRpcConnection(rpc, (0, utils_1.getGlobal)("disableProviderPing")));
            return http;
        }
    }
    getPubkey(chainId) {
        return this.getWalletAddress(chainId);
    }
    //   {
    //     "chains": ["solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp" ],
    //     "accounts": ["solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp:F7wnJc5wiBGy1k87jv6gyNwE3jMEWd18oTQiYsF1xVG7"],
    //     "methods": [
    //         "solana_signTransaction",
    //         "solana_signMessage"
    //     ],
    //     "defaultChain": "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp"
    // }
    // TODO:确认上面的defaultChain是否正确（没有solana前缀）
    getWalletAddress(chainId) {
        if (!chainId) {
            chainId = this.namespace.defaultChain;
            if (!(chainId === null || chainId === void 0 ? void 0 : chainId.startsWith("solana"))) {
                chainId = `solana:${chainId}`;
            }
        }
        return this.namespace.accounts.filter(function(account) {
            let components = account.split(":");
            return components.length > 2 && account.startsWith(chainId);
        }).map(function(account) {
            let components = account.split(":");
            return components[2];
        })[0];
    }
    showRequestModal(args) {
        return true;
    }
}
exports.SolanaProvider = SolanaProvider;
exports.default = SolanaProvider;
}}),
"[project]/node_modules/@okxconnect/universal-provider/src/provider/providers/btc.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
const constants_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/constants/index.js [app-client] (ecmascript)");
const core_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/index.js [app-client] (ecmascript)");
const utils_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/utils/index.js [app-client] (ecmascript)");
const JsonRpcConnection_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/providers/rpc/JsonRpcConnection.js [app-client] (ecmascript)");
const JsonRpcProvider_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/providers/rpc/JsonRpcProvider.js [app-client] (ecmascript)");
class BtcProvider {
    constructor(opts, name, client, events){
        this.name = core_1.NameSpaceKeyBtc;
        this.namespace = opts.namespace;
        this.events = events;
        this.client = client;
        this.chainId = this.getDefaultChain();
        this.httpProviders = this.createHttpProviders();
        this.name = name;
    }
    updateNamespace(namespace) {
        this.namespace = Object.assign(this.namespace, namespace);
    }
    requestAccounts() {
        return this.getAccounts();
    }
    request(args) {
        return __awaiter(this, void 0, void 0, function*() {
            (0, core_1.logDebug)("btc request --args--string>", JSON.stringify(args));
            (0, core_1.logDebug)("btc provider namespace: ", JSON.stringify(this.namespace));
            if (this.namespace.methods.includes(args.method)) {
                return this.client.request(args);
            }
            return this.getHttpProvider().request(args);
        });
    }
    setDefaultChain(chainId, rpcUrl) {
        // http provider exists so just set the chainId
        if (!this.httpProviders[chainId]) {
            this.setHttpProvider(chainId, rpcUrl);
        }
        this.chainId = chainId;
        this.events.emit(constants_1.PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${chainId}`);
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const chainId = this.namespace.chains[0];
        if (!chainId) throw new Error(`ChainId not found`);
        return chainId.split(":")[1];
    }
    // --------- PRIVATE --------- //
    getAccounts() {
        const accounts = this.namespace.accounts;
        if (!accounts) {
            return [];
        }
        return [
            ...new Set(accounts// get the accounts from the active chain
            .filter((account)=>account.split(":")[1] === this.chainId.toString())// remove namespace & chainId from the string
            .map((account)=>account.split(":")[2]))
        ];
    }
    createHttpProviders() {
        const http = {};
        this.namespace.chains.forEach((chain)=>{
            const parsedChainId = (0, utils_1.getChainId)(chain);
            const parsedRpc = (0, utils_1.getRpcUrl)(chain, this.namespace);
            let httpProvider = this.createHttpProvider(parsedChainId, parsedRpc);
            if (httpProvider) {
                http[parsedChainId] = httpProvider;
            }
        });
        return http;
    }
    getHttpProvider() {
        const chain = `${this.chainId}`;
        const http = this.httpProviders[chain];
        if (typeof http === "undefined") {
            throw new Error(`JSON-RPC provider for ${chain} not found`);
        }
        return http;
    }
    setHttpProvider(chainId, rpcUrl) {
        const http = this.createHttpProvider(chainId, rpcUrl);
        if (http) {
            this.httpProviders[chainId] = http;
        }
    }
    createHttpProvider(chainId, rpcUrl) {
        // 没有备用rpc对外提供
        const rpc = rpcUrl;
        if (!rpc) {
            (0, core_1.logError)(`No RPC url provided for chainId: ${chainId}`);
        // throw new Error(`No RPC url provided for chainId: ${chainId}`);
        } else {
            const http = new JsonRpcProvider_1.JsonRpcProvider(new JsonRpcConnection_1.JsonRpcConnection(rpc, (0, utils_1.getGlobal)("disableProviderPing")));
            return http;
        }
    }
    showRequestModal(args) {
        return true;
    }
}
exports.default = BtcProvider;
}}),
"[project]/node_modules/@okxconnect/universal-provider/src/provider/providers/aptos.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
const constants_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/constants/index.js [app-client] (ecmascript)");
const core_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/index.js [app-client] (ecmascript)");
const utils_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/utils/index.js [app-client] (ecmascript)");
const JsonRpcConnection_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/providers/rpc/JsonRpcConnection.js [app-client] (ecmascript)");
const JsonRpcProvider_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/providers/rpc/JsonRpcProvider.js [app-client] (ecmascript)");
class AptosProvider {
    constructor(opts, name, client, events){
        this.name = "aptos";
        this.namespace = opts.namespace;
        this.events = events;
        this.client = client;
        this.chainId = this.getDefaultChain();
        this.httpProviders = this.createHttpProviders();
        this.name = name;
    }
    updateNamespace(namespace) {
        this.namespace = Object.assign(this.namespace, namespace);
    }
    requestAccounts() {
        return this.getAccounts();
    }
    request(args) {
        return __awaiter(this, void 0, void 0, function*() {
            (0, core_1.logDebug)("solana request --args--string>", JSON.stringify(args));
            (0, core_1.logDebug)("solana provider namespace: ", this.namespace);
            if (this.namespace.methods.includes(args.method)) {
                return this.client.request(args);
            } else {
                throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.METHOD_NOT_SUPPORTED, "Please upgrade OKX APP");
            }
        });
    }
    setDefaultChain(chainId, rpcUrl) {
        // http provider exists so just set the chainId
        if (!this.httpProviders[chainId]) {
            this.setHttpProvider(chainId, rpcUrl);
        }
        this.chainId = chainId;
        this.events.emit(constants_1.PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${chainId}`);
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const chainId = this.namespace.chains[0];
        if (!chainId) throw new Error(`ChainId not found`);
        return chainId.split(":")[1];
    }
    // --------- PRIVATE --------- //
    getAccounts() {
        const accounts = this.namespace.accounts;
        if (!accounts) {
            return [];
        }
        return [
            ...new Set(accounts// get the accounts from the active chain
            .filter((account)=>account.split(":")[1] === this.chainId.toString())// remove namespace & chainId from the string
            .map((account)=>account.split(":")[2]))
        ];
    }
    createHttpProviders() {
        const http = {};
        this.namespace.chains.forEach((chain)=>{
            const parsedChainId = (0, utils_1.getChainId)(chain);
            const parsedRpc = (0, utils_1.getRpcUrl)(chain, this.namespace);
            let httpProvider = this.createHttpProvider(parsedChainId, parsedRpc);
            if (httpProvider) {
                http[parsedChainId] = httpProvider;
            }
        });
        return http;
    }
    getHttpProvider() {
        const chain = `${this.chainId}`;
        const http = this.httpProviders[chain];
        if (typeof http === "undefined") {
            throw new Error(`JSON-RPC provider for ${chain} not found`);
        }
        return http;
    }
    setHttpProvider(chainId, rpcUrl) {
        const http = this.createHttpProvider(chainId, rpcUrl);
        if (http) {
            this.httpProviders[chainId] = http;
        }
    }
    createHttpProvider(chainId, rpcUrl) {
        // 没有备用rpc对外提供
        const rpc = rpcUrl;
        if (!rpc) {
        // logError(`No RPC url provided for chainId: ${chainId}`);
        // throw new Error(`No RPC url provided for chainId: ${chainId}`);
        } else {
            const http = new JsonRpcProvider_1.JsonRpcProvider(new JsonRpcConnection_1.JsonRpcConnection(rpc, (0, utils_1.getGlobal)("disableProviderPing")));
            return http;
        }
    }
    showRequestModal(args) {
        return true;
    }
}
exports.default = AptosProvider;
}}),
"[project]/node_modules/@okxconnect/universal-provider/src/provider/providers/ton.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
const constants_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/constants/index.js [app-client] (ecmascript)");
const core_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/index.js [app-client] (ecmascript)");
const utils_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/utils/index.js [app-client] (ecmascript)");
const JsonRpcConnection_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/providers/rpc/JsonRpcConnection.js [app-client] (ecmascript)");
const JsonRpcProvider_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/providers/rpc/JsonRpcProvider.js [app-client] (ecmascript)");
class TONProvider {
    constructor(opts, client, events){
        this.name = core_1.NameSpaceKeyTON;
        this.namespace = opts.namespace;
        this.events = events;
        this.client = client;
        this.chainId = this.getDefaultChain();
        this.httpProviders = this.createHttpProviders();
    }
    updateNamespace(namespace) {
        this.namespace = Object.assign(this.namespace, namespace);
    }
    isRecord(value) {
        return typeof value === "object" && value !== null && !Array.isArray(value);
    }
    request(args) {
        return __awaiter(this, void 0, void 0, function*() {
            var _a, _b, _c, _d;
            (0, core_1.logDebug)("TONProvider request --args--string>", JSON.stringify(args));
            (0, core_1.logDebug)("TONProvider request provider namespace: ", this.namespace);
            if (this.namespace.methods.includes(args.method)) {
                if (!args.params) {
                    throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, "ton request params is nil");
                }
                if (this.isRecord(args.params)) {
                    const _e = args.params, { validUntil } = _e, newParams = __rest(_e, [
                        "validUntil"
                    ]);
                    let fromAddress = (_b = (_a = this.namespace.payload) === null || _a === void 0 ? void 0 : _a.ton_addr) === null || _b === void 0 ? void 0 : _b.address;
                    if ('from' in newParams) {
                        fromAddress = newParams.from || ((_d = (_c = this.namespace.payload) === null || _c === void 0 ? void 0 : _c.ton_addr) === null || _d === void 0 ? void 0 : _d.address);
                    }
                    args.params['from'] = fromAddress;
                    args.params['network'] = this.getDefaultChain();
                    args.params['valid_until'] = validUntil;
                    let response = yield this.client.request(args);
                    if (this.isRecord(response) && 'result' in response) {
                        const result = {
                            boc: response.result.toString()
                        };
                        (0, core_1.logDebug)("TONProvider request provider response: ", JSON.stringify(response));
                        (0, core_1.logDebug)("TONProvider request provider result: ", JSON.stringify(result));
                        return result;
                    }
                    throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, "ton_send request response is nil");
                } else {
                    throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, "ton request params type add nil");
                }
            }
            return this.getHttpProvider().request(args);
        });
    }
    requestAccounts() {
        return this.getAccounts();
    }
    setDefaultChain(chainId, rpcUrl) {
        if (!this.httpProviders[chainId]) {
            this.setHttpProvider(chainId, rpcUrl);
        }
        this.chainId = chainId;
        this.events.emit(constants_1.PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${chainId}`);
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const chainId = this.namespace.chains[0];
        if (!chainId) throw new Error(`ChainId not found`);
        return chainId.split(":")[1];
    }
    // --------- PRIVATE --------- //
    getAccounts() {
        var _a, _b;
        const accounts = this.namespace.accounts;
        (0, core_1.logDebug)("ton getAccounts accounts :", accounts);
        (0, core_1.logDebug)("ton getAccounts .namespace :", JSON.stringify(this.namespace));
        if (!accounts) {
            return [];
        }
        let address = (_b = (_a = this.namespace.payload) === null || _a === void 0 ? void 0 : _a.ton_addr) === null || _b === void 0 ? void 0 : _b.address;
        (0, core_1.logDebug)("ton getAccounts address :", address);
        if (address) {
            return [
                address
            ];
        }
        return [];
    }
    createHttpProviders() {
        const http = {};
        this.namespace.chains.forEach((chain)=>{
            const parsedChainId = (0, utils_1.getChainId)(chain);
            const parsedRpc = (0, utils_1.getRpcUrl)(chain, this.namespace);
            let httpProvider = this.createHttpProvider(parsedChainId, parsedRpc);
            if (httpProvider) {
                http[parsedChainId] = httpProvider;
            }
        });
        return http;
    }
    getHttpProvider() {
        const chain = `${this.chainId}`;
        const http = this.httpProviders[chain];
        (0, core_1.logDebug)('[RPC] get http provider:', chain, http);
        if (typeof http === "undefined") {
            throw new Error(`JSON-RPC provider for ${chain} not found`);
        }
        return http;
    }
    setHttpProvider(chainId, rpcUrl) {
        const http = this.createHttpProvider(chainId, rpcUrl);
        if (http) {
            (0, core_1.logDebug)("setHttpProvider", chainId, rpcUrl);
            this.httpProviders[chainId] = http;
        }
    }
    createHttpProvider(chainId, rpcUrl) {
        // 没有备用rpc对外提供
        const rpc = rpcUrl;
        if (!rpc) {
            (0, core_1.logError)(`No RPC url provided for chainId: ${chainId}`);
        // throw new Error(`No RPC url provided for chainId: ${chainId}`);
        } else {
            const http = new JsonRpcProvider_1.JsonRpcProvider(new JsonRpcConnection_1.JsonRpcConnection(rpc, (0, utils_1.getGlobal)("disableProviderPing")));
            return http;
        }
    }
    showRequestModal(args) {
        switch(args.method){
            case "ton_sendTransaction":
                return true;
            default:
                return false;
        }
        return false;
    }
}
exports.default = TONProvider;
}}),
"[project]/node_modules/@okxconnect/universal-provider/src/provider/providers/cosmos.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
const constants_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/constants/index.js [app-client] (ecmascript)");
const core_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/index.js [app-client] (ecmascript)");
const utils_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/utils/index.js [app-client] (ecmascript)");
const JsonRpcConnection_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/providers/rpc/JsonRpcConnection.js [app-client] (ecmascript)");
const JsonRpcProvider_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/providers/rpc/JsonRpcProvider.js [app-client] (ecmascript)");
class CosmosProvider {
    constructor(opts, client, events){
        this.name = core_1.NameSpaceKeyCosmos;
        this.namespace = opts.namespace;
        this.events = events;
        this.client = client;
        this.chainId = this.getDefaultChain();
        this.httpProviders = this.createHttpProviders();
    }
    updateNamespace(namespace) {
        this.namespace = Object.assign(this.namespace, namespace);
    }
    requestAccounts() {
        return this.getAccounts();
    }
    request(args) {
        return __awaiter(this, void 0, void 0, function*() {
            (0, core_1.logDebug)("cosmos request --args--string>", JSON.stringify(args));
            (0, core_1.logDebug)("cosmos provider namespace: ", JSON.stringify(this.namespace));
            if (this.namespace.methods.includes(args.method)) {
                return this.client.request(args);
            } else {
                throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.METHOD_NOT_SUPPORTED, "Please upgrade OKX APP");
            }
        });
    }
    setDefaultChain(chainId, rpcUrl) {
        // http provider exists so just set the chainId
        if (!this.httpProviders[chainId]) {
            this.setHttpProvider(chainId, rpcUrl);
        }
        this.chainId = chainId;
        this.events.emit(constants_1.PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${chainId}`);
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const chainId = this.namespace.chains[0];
        if (!chainId) throw new Error(`ChainId not found`);
        return chainId.split(":")[1];
    }
    // --------- PRIVATE --------- //
    getAccounts() {
        const accounts = this.namespace.accounts;
        if (!accounts) {
            return [];
        }
        return [
            ...new Set(accounts// get the accounts from the active chain
            .filter((account)=>account.split(":")[1] === this.chainId.toString())// remove namespace & chainId from the string
            .map((account)=>account.split(":")[2]))
        ];
    }
    createHttpProviders() {
        const http = {};
        this.namespace.chains.forEach((chain)=>{
            const parsedChainId = (0, utils_1.getChainId)(chain);
            const parsedRpc = (0, utils_1.getRpcUrl)(chain, this.namespace);
            let httpProvider = this.createHttpProvider(parsedChainId, parsedRpc);
            if (httpProvider) {
                http[parsedChainId] = httpProvider;
            }
        });
        return http;
    }
    getHttpProvider() {
        const chain = `${this.chainId}`;
        const http = this.httpProviders[chain];
        if (typeof http === "undefined") {
            throw new Error(`JSON-RPC provider for ${chain} not found`);
        }
        return http;
    }
    setHttpProvider(chainId, rpcUrl) {
        const http = this.createHttpProvider(chainId, rpcUrl);
        if (http) {
            this.httpProviders[chainId] = http;
        }
    }
    createHttpProvider(chainId, rpcUrl) {
        // 没有备用rpc对外提供
        const rpc = rpcUrl;
        if (!rpc) {
        // logError(`No RPC url provided for chainId: ${chainId}`);
        // throw new Error(`No RPC url provided for chainId: ${chainId}`);
        } else {
            const http = new JsonRpcProvider_1.JsonRpcProvider(new JsonRpcConnection_1.JsonRpcConnection(rpc, (0, utils_1.getGlobal)("disableProviderPing")));
            return http;
        }
    }
    showRequestModal(args) {
        return true;
    }
}
exports.default = CosmosProvider;
}}),
"[project]/node_modules/@okxconnect/universal-provider/src/provider/providers/tron.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
const constants_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/constants/index.js [app-client] (ecmascript)");
const core_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/index.js [app-client] (ecmascript)");
const utils_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/utils/index.js [app-client] (ecmascript)");
const JsonRpcConnection_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/providers/rpc/JsonRpcConnection.js [app-client] (ecmascript)");
const JsonRpcProvider_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/providers/rpc/JsonRpcProvider.js [app-client] (ecmascript)");
class TronProvider {
    constructor(opts, client, events){
        this.name = core_1.NameSpaceKeyTron;
        this.namespace = opts.namespace;
        this.events = events;
        this.client = client;
        this.chainId = this.getDefaultChain();
        this.httpProviders = this.createHttpProviders();
    }
    updateNamespace(namespace) {
        this.namespace = Object.assign(this.namespace, namespace);
    }
    requestAccounts() {
        return this.getAccounts();
    }
    request(args) {
        return __awaiter(this, void 0, void 0, function*() {
            (0, core_1.logDebug)("tron request --args--string>", JSON.stringify(args));
            (0, core_1.logDebug)("tron provider namespace: ", JSON.stringify(this.namespace));
            if (this.namespace.methods.includes(args.method)) {
                return this.client.request(args);
            } else {
                throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.METHOD_NOT_SUPPORTED, "Please upgrade OKX APP");
            }
        });
    }
    setDefaultChain(chainId, rpcUrl) {
        // http provider exists so just set the chainId
        if (!this.httpProviders[chainId]) {
            this.setHttpProvider(chainId, rpcUrl);
        }
        this.chainId = chainId;
        this.events.emit(constants_1.PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${chainId}`);
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const chainId = this.namespace.chains[0];
        if (!chainId) throw new Error(`ChainId not found`);
        return chainId.split(":")[1];
    }
    // --------- PRIVATE --------- //
    getAccounts() {
        const accounts = this.namespace.accounts;
        if (!accounts) {
            return [];
        }
        return [
            ...new Set(accounts// get the accounts from the active chain
            .filter((account)=>account.split(":")[1] === this.chainId.toString())// remove namespace & chainId from the string
            .map((account)=>account.split(":")[2]))
        ];
    }
    createHttpProviders() {
        const http = {};
        this.namespace.chains.forEach((chain)=>{
            const parsedChainId = (0, utils_1.getChainId)(chain);
            const parsedRpc = (0, utils_1.getRpcUrl)(chain, this.namespace);
            let httpProvider = this.createHttpProvider(parsedChainId, parsedRpc);
            if (httpProvider) {
                http[parsedChainId] = httpProvider;
            }
        });
        return http;
    }
    getHttpProvider() {
        const chain = `${this.chainId}`;
        const http = this.httpProviders[chain];
        if (typeof http === "undefined") {
            throw new Error(`JSON-RPC provider for ${chain} not found`);
        }
        return http;
    }
    setHttpProvider(chainId, rpcUrl) {
        const http = this.createHttpProvider(chainId, rpcUrl);
        if (http) {
            this.httpProviders[chainId] = http;
        }
    }
    createHttpProvider(chainId, rpcUrl) {
        // 没有备用rpc对外提供
        const rpc = rpcUrl;
        if (!rpc) {
        // logError(`No RPC url provided for chainId: ${chainId}`);
        // throw new Error(`No RPC url provided for chainId: ${chainId}`);
        } else {
            const http = new JsonRpcProvider_1.JsonRpcProvider(new JsonRpcConnection_1.JsonRpcConnection(rpc, (0, utils_1.getGlobal)("disableProviderPing")));
            return http;
        }
    }
    showRequestModal(args) {
        return true;
    }
}
exports.default = TronProvider;
}}),
"[project]/node_modules/@okxconnect/universal-provider/src/provider/providers/starknet.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
const constants_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/constants/index.js [app-client] (ecmascript)");
const core_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/index.js [app-client] (ecmascript)");
const utils_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/utils/index.js [app-client] (ecmascript)");
const JsonRpcConnection_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/providers/rpc/JsonRpcConnection.js [app-client] (ecmascript)");
const JsonRpcProvider_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/providers/rpc/JsonRpcProvider.js [app-client] (ecmascript)");
class StarknetProvider {
    constructor(opts, name, client, events){
        this.name = "starknet";
        this.namespace = opts.namespace;
        this.events = events;
        this.client = client;
        this.chainId = this.getDefaultChain();
        this.httpProviders = this.createHttpProviders();
        this.name = name;
    }
    updateNamespace(namespace) {
        this.namespace = Object.assign(this.namespace, namespace);
    }
    requestAccounts() {
        return this.getAccounts();
    }
    request(args) {
        return __awaiter(this, void 0, void 0, function*() {
            (0, core_1.logDebug)("starknet request --args--string>", JSON.stringify(args));
            (0, core_1.logDebug)("starknet provider namespace: ", this.namespace);
            if (this.namespace.methods.includes(args.method)) {
                return this.client.request(args);
            } else {
                throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.METHOD_NOT_SUPPORTED, "Wallet doesn't support" + args.method);
            }
        });
    }
    setDefaultChain(chainId, rpcUrl) {
        // http provider exists so just set the chainId
        if (!this.httpProviders[chainId]) {
            this.setHttpProvider(chainId, rpcUrl);
        }
        this.chainId = chainId;
        this.events.emit(constants_1.PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${chainId}`);
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const chainId = this.namespace.chains[0];
        if (!chainId) throw new Error(`ChainId not found`);
        return chainId.split(":")[1];
    }
    // --------- PRIVATE --------- //
    getAccounts() {
        const accounts = this.namespace.accounts;
        if (!accounts) {
            return [];
        }
        return [
            ...new Set(accounts// get the accounts from the active chain
            .filter((account)=>account.split(":")[1] === this.chainId.toString())// remove namespace & chainId from the string
            .map((account)=>account.split(":")[2]))
        ];
    }
    createHttpProviders() {
        const http = {};
        this.namespace.chains.forEach((chain)=>{
            const parsedChainId = (0, utils_1.getChainId)(chain);
            const parsedRpc = (0, utils_1.getRpcUrl)(chain, this.namespace);
            let httpProvider = this.createHttpProvider(parsedChainId, parsedRpc);
            if (httpProvider) {
                http[parsedChainId] = httpProvider;
            }
        });
        return http;
    }
    getHttpProvider() {
        const chain = `${this.chainId}`;
        const http = this.httpProviders[chain];
        if (typeof http === "undefined") {
            throw new Error(`JSON-RPC provider for ${chain} not found`);
        }
        return http;
    }
    setHttpProvider(chainId, rpcUrl) {
        const http = this.createHttpProvider(chainId, rpcUrl);
        if (http) {
            this.httpProviders[chainId] = http;
        }
    }
    createHttpProvider(chainId, rpcUrl) {
        // 没有备用rpc对外提供
        const rpc = rpcUrl;
        if (!rpc) {
        // logError(`No RPC url provided for chainId: ${chainId}`);
        // throw new Error(`No RPC url provided for chainId: ${chainId}`);
        } else {
            const http = new JsonRpcProvider_1.JsonRpcProvider(new JsonRpcConnection_1.JsonRpcConnection(rpc, (0, utils_1.getGlobal)("disableProviderPing")));
            return http;
        }
    }
    showRequestModal(args) {
        return true;
    }
}
exports.default = StarknetProvider;
}}),
"[project]/node_modules/@okxconnect/universal-provider/src/OKXUniversalProvider.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OKXUniversalProvider = void 0;
const eip155_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/providers/eip155.js [app-client] (ecmascript)");
const sui_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/providers/sui.js [app-client] (ecmascript)");
const constants_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/constants/index.js [app-client] (ecmascript)");
const eventemitter3_1 = __importDefault(__turbopack_require__("[project]/node_modules/eventemitter3/index.js [app-client] (ecmascript)"));
const client_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/packages/sign-client/client.js [app-client] (ecmascript)");
const core_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/index.js [app-client] (ecmascript)");
const namespaces_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/packages/utils/namespaces.js [app-client] (ecmascript)");
const solana_1 = __importDefault(__turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/providers/solana.js [app-client] (ecmascript)"));
const btc_1 = __importDefault(__turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/providers/btc.js [app-client] (ecmascript)"));
const aptos_1 = __importDefault(__turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/providers/aptos.js [app-client] (ecmascript)"));
const ton_1 = __importDefault(__turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/providers/ton.js [app-client] (ecmascript)"));
const cosmos_1 = __importDefault(__turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/providers/cosmos.js [app-client] (ecmascript)"));
const tron_1 = __importDefault(__turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/providers/tron.js [app-client] (ecmascript)"));
const utils_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/utils/index.js [app-client] (ecmascript)");
const packages_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/packages/index.js [app-client] (ecmascript)");
const provider_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/index.js [app-client] (ecmascript)");
const starknet_1 = __importDefault(__turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/providers/starknet.js [app-client] (ecmascript)"));
class OKXUniversalProvider {
    static init(opts) {
        return __awaiter(this, void 0, void 0, function*() {
            (0, core_1.logDebug)('OKXUniversalProvider init() called');
            (0, core_1.checkMetaData)(opts.dappMetaData);
            // ignore rpc provider check by default
            (0, utils_1.setGlobal)('disableProviderPing', true);
            let provider;
            if (window && window.okxConnectUniversalinwindow && window.okxConnectUniversalinwindow instanceof OKXUniversalProvider) {
                (0, core_1.logDebug)('OKXUniversalConnect init() old called');
                provider = window.okxConnectUniversalinwindow;
            } else {
                (0, core_1.logDebug)('OKXUniversalConnect init() new called');
                provider = new OKXUniversalProvider(opts);
                if (window) {
                    window.okxConnectUniversalinwindow = provider;
                }
                yield provider.initialize();
            }
            (0, core_1.getDefaultReporter)().configVersionAndSide('universalprovider-1.5.2', 'dapp', provider.providerOpts.dappMetaData.name);
            return provider;
        });
    }
    constructor(opts){
        this.rpcProviders = {};
        this.events = new eventemitter3_1.default();
        this.providerOpts = opts;
    }
    request(args, chain) {
        return __awaiter(this, void 0, void 0, function*() {
            (0, core_1.logDebug)('OKXUniversalProvider request() called');
            (0, core_1.reportLog)('OKXUniversalProvider request() called');
            if (!this.connected()) {
                throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.NOT_CONNECTED_ERROR);
            }
            const { namespace, requestParam } = this.buildRequestParamFromRequest(args, chain);
            return yield this.getProvider(namespace).request(requestParam);
        });
    }
    buildRequestParamFromRequest(args, chain) {
        var _a;
        (0, core_1.logDebug)("UniversalProvider request args >>>>>>>: ", chain, JSON.stringify(args));
        let [namespace, chainId] = this.validateChain(chain);
        if (!this.session) {
            throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, "Please call connect() before request()");
        }
        let keyArr = Object.keys(this.session.namespaces);
        if (!chain && keyArr && keyArr.length > 1) {
            throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.NOT_CONNECTED_ERROR, `Multiple chains have been linked, the request method requires chain`);
        }
        if (namespace == "aptos" && chainId == "mainnet") {
            namespace = "aptos";
            chainId = "637";
        }
        if (namespace == "movement" && chainId == "testnet") {
            namespace = "aptos";
            chainId = "70000060";
        }
        const requestParam = Object.assign(Object.assign({}, args), {
            chainId: `${namespace}:${chainId}`,
            redirect: (_a = args.redirect) !== null && _a !== void 0 ? _a : this.sessionConfig.redirect
        });
        return {
            namespace,
            requestParam
        };
    }
    enable() {
        return __awaiter(this, void 0, void 0, function*() {
            if (!this.client) {
                throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, "Sign Client not initialized");
            }
            if (!this.session) {
                if (this.connectOpts) {
                    yield this.connect(this.connectOpts);
                } else {
                    throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, "Sign Client not initialized");
                }
            }
            const accounts = yield this.requestAccounts();
            return accounts;
        });
    }
    disconnect() {
        return __awaiter(this, void 0, void 0, function*() {
            (0, core_1.logDebug)('OKXUniversalProvider disconnect() called');
            (0, core_1.reportLog)('provider disconnect called');
            if (!this.session) {
                throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.NOT_CONNECTED_ERROR);
            }
            return new Promise((resolve)=>__awaiter(this, void 0, void 0, function*() {
                    let called = false;
                    const onRequestSent = ()=>__awaiter(this, void 0, void 0, function*() {
                            if (!called) {
                                called = true;
                                yield this.disconnectAndEmit();
                                yield this.cleanup();
                                resolve();
                                (0, core_1.logDebug)("UniversalProvider disconnect Disconnected");
                                (0, core_1.reportLog)('provider disconnect disconnected');
                            }
                        });
                    try {
                        yield this.client.disconnect();
                        yield onRequestSent();
                    } catch (e) {
                        yield onRequestSent();
                    }
                }));
        });
    }
    disconnectAndEmit() {
        var _a, _b;
        this.client.engine.connectionManager.disconnect();
        this.events.emit("disconnect", {
            topic: (_a = this.session) === null || _a === void 0 ? void 0 : _a.topic
        });
        this.events.emit("session_delete", {
            topic: (_b = this.session) === null || _b === void 0 ? void 0 : _b.topic
        });
    }
    aptosChainNameToGeneralId(chainId) {
        if (chainId == "aptos:mainnet") {
            return "aptos:637";
        } else if (chainId == "movement:testnet") {
            return "aptos:70000060";
        } else {
            return chainId;
        }
    }
    replaceAptos(opts) {
        var _a, _b;
        let aptosNameSpace = (_a = opts.namespaces) === null || _a === void 0 ? void 0 : _a["aptos"];
        if (aptosNameSpace != undefined) {
            let realNS = this.replaceAptosInner(aptosNameSpace);
            if (opts.namespaces != undefined && "aptos" in opts.namespaces && realNS != undefined) {
                opts.namespaces.aptos = realNS;
            }
        }
        let optionAptosNameSpace = (_b = opts.optionalNamespaces) === null || _b === void 0 ? void 0 : _b["aptos"];
        if (optionAptosNameSpace != undefined) {
            let realOptionNS = this.replaceAptosInner(optionAptosNameSpace);
            if (opts.optionalNamespaces != undefined && "aptos" in opts.optionalNamespaces && realOptionNS != undefined) {
                opts.optionalNamespaces.aptos = realOptionNS;
            }
        }
        return opts;
    }
    replaceAptosInner(aptosNameSpace) {
        var _a;
        if (aptosNameSpace != undefined) {
            aptosNameSpace.chains = (_a = aptosNameSpace.chains) === null || _a === void 0 ? void 0 : _a.map((chainId)=>{
                return this.aptosChainNameToGeneralId(chainId);
            });
            if (aptosNameSpace.defaultChain != undefined) {
                aptosNameSpace.defaultChain = this.aptosChainNameToGeneralId(aptosNameSpace.defaultChain);
            }
        }
        return aptosNameSpace;
    }
    replaceAptosGeneralIdWithNetName(chainId) {
        if (chainId.includes("aptos:637")) {
            chainId = chainId.replace("aptos:637", "aptos:mainnet");
        } else if (chainId.includes("aptos:70000060")) {
            chainId = chainId.replace("aptos:70000060", "movement:testnet");
        }
        return chainId;
    }
    replaceSessionAptos(session) {
        var _a;
        let namespaces = (_a = session === null || session === void 0 ? void 0 : session.namespaces) === null || _a === void 0 ? void 0 : _a["aptos"];
        if (namespaces != undefined && namespaces.chains != undefined) {
            namespaces.chains = namespaces.chains.map((chain)=>{
                return this.replaceAptosGeneralIdWithNetName(chain);
            });
            namespaces.accounts = namespaces.accounts.map((account)=>{
                return this.replaceAptosGeneralIdWithNetName(account);
            });
            let extra = {};
            Object.keys(namespaces.extra || {}).forEach((key, index)=>{
                let newKey = this.replaceAptosGeneralIdWithNetName(key);
                extra[this.replaceAptosGeneralIdWithNetName(key)] = Object.values((session === null || session === void 0 ? void 0 : session.namespaces["aptos"].extra) || {})[index];
            });
            namespaces.extra = extra;
        }
        (0, core_1.logDebug)("replaceSessionAptos", session);
    }
    connected() {
        (0, core_1.logDebug)('OKXUniversalProvider connected() called');
        (0, core_1.reportLog)('provider connected called');
        let disconnectInner = ()=>{
            try {
                this.cleanup();
                this.client.engine.connectionManager.disconnect();
            } catch (e) {
                (0, core_1.logDebug)("Error during disconnect:", e);
            }
        };
        try {
            if (!this.session) return false;
            if (!this.client.engine.connectionManager.getCurrentConnectionReady()) {
                disconnectInner();
                return false;
            }
            return true;
        } catch (e) {
            disconnectInner();
            return false;
        }
    }
    connectAndSign(opts, signRequest) {
        return __awaiter(this, void 0, void 0, function*() {
            (0, core_1.logDebug)('OKXUniversalProvider connectAndSign() called');
            const updatedOpts = Object.assign(Object.assign({}, opts), {
                signRequest
            });
            (0, core_1.logDebug)('OKXUniversalProvider connectAndSign() opts:', JSON.stringify(opts));
            (0, core_1.logDebug)('OKXUniversalProvider connectAndSign() signRequest:', JSON.stringify(signRequest));
            return yield this.connect(updatedOpts);
        });
    }
    connect(opts) {
        return __awaiter(this, void 0, void 0, function*() {
            (0, core_1.logDebug)('OKXUniversalProvider connect() called');
            (0, core_1.reportLog)('provider connect called');
            if (!this.client) {
                throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, "Sign Client not initialized");
            }
            if (this.connected()) {
                return this.session;
            }
            opts = this.replaceAptos(opts);
            (0, core_1.logDebug)(`OKXUniversalProvider connect >>>>`, JSON.stringify(opts));
            if (opts.sessionConfig === undefined) {
                opts.sessionConfig = {};
            }
            if (opts.sessionConfig.openUniversalUrl === undefined) {
                opts.sessionConfig.openUniversalUrl = (0, core_1.isMobileUserAgent)();
            }
            this.setNamespaces(opts);
            try {
                (0, core_1.logDebug)(`UniversalProvider connect opts.stringify ====> ${JSON.stringify(opts)}`);
                let session = yield this.client.connect(opts);
                this.replaceSessionAptos(session);
                (0, core_1.logDebug)(`UniversalProvider connect success ====> ${JSON.stringify(session)}`);
                if (session) {
                    this.session = session;
                    this.client.session = session;
                    (0, core_1.logDebug)(`OKXUniversalProvider connect success opts>>>>`, JSON.stringify(opts));
                    this.onConnect();
                    if (opts.signRequest && opts.signRequest.length > 0) {
                        let requestItem = opts.signRequest[0];
                        let signResponseList = [];
                        if (typeof window !== "undefined" && window && window.okxConnectUniversalUIinwindow) {
                            (0, core_1.logDebug)(`OKXUniversalProvider connect success, us UI SDK>>>>`);
                            if (this.session.signResponse && this.session.signResponse.length > 0) {
                                signResponseList = this.session.signResponse;
                            }
                        } else {
                            (0, core_1.logDebug)(`OKXUniversalProvider connect success, us Universal SDK>>>>`);
                            if (this.session.signResponse && this.session.signResponse.length > 0) {
                                signResponseList = this.session.signResponse;
                            } else {
                                signResponseList.push((0, packages_1.creatNotSupportMethodItemReplay)(requestItem));
                            }
                        }
                        (0, core_1.logDebug)(`UniversalProvider connect success connectRequestReply ====> ${JSON.stringify(signResponseList)}`);
                        setTimeout(()=>{
                            this.events.emit("connect_signResponse", signResponseList);
                        }, 100);
                    }
                    return session;
                }
                return undefined;
            } catch (error) {
                (0, core_1.logDebug)(`UniversalProvider connect error ====> `, JSON.stringify(error));
                throw error;
            }
        });
    }
    syncAllAddresses() {
        return __awaiter(this, void 0, void 0, function*() {
            if ((0, provider_1.syncAddressAvailable)(this.session.wallet)) {
                return this.client.syncAllAddress();
            } else {
                throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.METHOD_NOT_SUPPORTED);
            }
        });
    }
    on(event, listener) {
        this.events.on(event, listener);
    }
    once(event, listener) {
        this.events.once(event, listener);
    }
    removeListener(event, listener) {
        this.events.removeListener(event, listener);
    }
    off(event, listener) {
        this.events.off(event, listener);
    }
    setDefaultChain(chain, rpcUrl) {
        (0, core_1.logDebug)('OKXUniversalProvider setDefaultChain() called');
        // chain = this.aptosChainNameToGeneralId(chain)
        try {
            // ignore without active session
            if (!this.connected()) return;
            const [namespace, chainId] = this.validateChain(chain);
            const provider = this.getProvider(namespace);
            provider.setDefaultChain(chainId, rpcUrl);
        } catch (error) {
            // ignore the error if the fx is used prematurely before namespaces are set
            if (!/Please call connect/.test(error.message)) throw error;
        }
    }
    checkStorage() {
        return __awaiter(this, void 0, void 0, function*() {
            let sessionInfoStr = yield this.getFromStore("connectSession");
            (0, core_1.logDebug)(sessionInfoStr);
            if (sessionInfoStr) {
                let sessionInfo = sessionInfoStr;
                this.session = sessionInfo;
                this.client.session = this.session;
                this.sessionConfig = sessionInfo.sessionConfig;
                this.client.sessionConfig = this.sessionConfig;
                (0, core_1.logDebug)('[evm u-provider] do reconnection', this.session);
                yield this.client.restoreconnect(sessionInfo);
                this.createProviders();
                this.registerEventListeners();
                setTimeout(()=>{
                    this.events.emit("reconnect", {
                        session: this.session
                    });
                }, 100);
                this.registerEventListeners();
            }
        });
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function*() {
            (0, core_1.logDebug)('OKXUniversalProvider initialize() called');
            (0, core_1.reportLog)('provider initialize called');
            const data = Object.assign({
                url: window.location.hostname,
                origin: window.location.origin
            }, this.providerOpts.dappMetaData);
            this.client = new client_1.SignClient(data, this.events);
            yield this.checkStorage();
        });
    }
    createProviders() {
        if (!this.client) {
            throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, "Sign Client not initialized");
        }
        if (!this.connected()) {
            throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, "Session not initialized. Please call connect() before enable()");
        }
        const providersToCreate = [
            ...new Set(Object.keys(this.session.namespaces).filter((namespace)=>{
                var _a, _b;
                return ((_b = (_a = this.session.namespaces[namespace]) === null || _a === void 0 ? void 0 : _a.accounts) === null || _b === void 0 ? void 0 : _b.length) > 0;
            }).map((namespace)=>(0, namespaces_1.parseNamespaceKey)(namespace)))
        ];
        providersToCreate.forEach((namespace)=>{
            if (!this.session) return;
            const namespacesValue = this.session.namespaces;
            const currentNameSpace = namespacesValue[namespace];
            (0, core_1.logDebug)("init eip155 >> ", currentNameSpace);
            switch(namespace){
                case "eip155":
                    const opts = {
                        namespace: currentNameSpace
                    };
                    this.rpcProviders[namespace] = new eip155_1.Eip155Provider(opts, this.client, this.events);
                    break;
                case "solana":
                    const opts1 = {
                        namespace: currentNameSpace
                    };
                    let solanaProvider = new solana_1.default(opts1, "solana", this.client, this.events);
                    this.rpcProviders[namespace] = solanaProvider;
                    let sonicProvider = new solana_1.default(opts1, "sonic", this.client, this.events);
                    this.rpcProviders['sonic'] = sonicProvider;
                    let svmProvider = new solana_1.default(opts1, "svm", this.client, this.events);
                    this.rpcProviders['svm'] = svmProvider;
                    break;
                case "ton":
                    const optsTon = {
                        namespace: currentNameSpace
                    };
                    let tonProvider = new ton_1.default(optsTon, this.client, this.events);
                    this.rpcProviders[namespace] = tonProvider;
                    break;
                case "sui":
                    const optsSui = {
                        namespace: currentNameSpace
                    };
                    let suiProvider = new sui_1.SuiProvider(optsSui, this.client, this.events);
                    suiProvider.name = "sui";
                    this.rpcProviders[namespace] = suiProvider;
                    break;
                case "btc":
                    const optsBtc = {
                        namespace: currentNameSpace
                    };
                    let btcProvider = new btc_1.default(optsBtc, "btc", this.client, this.events);
                    this.rpcProviders["btc"] = btcProvider;
                    let fbProvider = new btc_1.default(optsBtc, "fractal", this.client, this.events);
                    this.rpcProviders["fractal"] = fbProvider;
                    break;
                case "aptos":
                    let aptosProvider = new aptos_1.default({
                        namespace: currentNameSpace
                    }, "aptos", this.client, this.events);
                    this.rpcProviders[namespace] = aptosProvider;
                    let moveProvider = new aptos_1.default({
                        namespace: currentNameSpace
                    }, "movement", this.client, this.events);
                    this.rpcProviders["movement"] = moveProvider;
                    break;
                case "cosmos":
                    let cosmosProvider = new cosmos_1.default({
                        namespace: currentNameSpace
                    }, this.client, this.events);
                    this.rpcProviders[namespace] = cosmosProvider;
                    break;
                case "tron":
                    let tronProvider = new tron_1.default({
                        namespace: currentNameSpace
                    }, this.client, this.events);
                    this.rpcProviders[namespace] = tronProvider;
                    break;
                case "starknet":
                    let starknetProvider = new starknet_1.default({
                        namespace: currentNameSpace
                    }, "starknet", this.client, this.events);
                    this.rpcProviders[namespace] = starknetProvider;
                    break;
            }
        });
    }
    registerEventListeners() {
        if (typeof this.client === "undefined") {
            throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, "Sign Client is not initialized");
        }
        this.client.engine.addDisconnectListener(()=>{
            this.disconnectAndEmit();
            this.cleanup();
        });
        this.on(constants_1.PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, (caip2ChainId)=>{
            this.onChainChanged(caip2ChainId);
        });
        this.on(constants_1.PROVIDER_EVENTS.UPDATE_NAMESPACES, (nameSpaces)=>{
            if (nameSpaces) {
                const nameSpacekey = Object.keys(nameSpaces)[0];
                if (this.session) {
                    this.session.namespaces[nameSpacekey] = nameSpaces[nameSpacekey];
                    if (this.session) {
                        this.persist("connectSession", this.session);
                        this.events.emit("session_update", this.session);
                    }
                    (0, core_1.logDebug)("PROVIDER_EVENTS.UPDATE_NAMESPACES this.session... ->>>", JSON.stringify(this.session));
                }
            }
        });
    }
    getProvider(namespace) {
        (0, core_1.logDebug)('current get providers', this.rpcProviders);
        (0, core_1.logDebug)('query namespace: ', namespace);
        return this.rpcProviders[namespace];
    }
    setNamespaces(params) {
        this.connectOpts = params;
        const { namespaces, sessionConfig } = params;
        const data = {
            origin: window.location.origin,
            url: window.location.hostname,
            name: this.providerOpts.dappMetaData.name,
            icon: this.providerOpts.dappMetaData.icon
        };
        this.sessionConfig = Object.assign({
            dappInfo: data
        }, sessionConfig);
        (0, core_1.logDebug)("setNamespaces sessionConfig>>>", this.sessionConfig);
        this.client.sessionConfig = this.sessionConfig;
        this.persist("sessionConfig", sessionConfig);
    }
    validateChain(chain) {
        var _a;
        let [namespace, chainId] = (chain === null || chain === void 0 ? void 0 : chain.split(":")) || [
            "",
            ""
        ];
        if (!this.session || !this.session.namespaces || !Object.keys(this.session.namespaces).length) {
            (0, core_1.logDebug)('get name & chain', namespace, chainId);
            return [
                namespace,
                chainId
            ];
        }
        if (namespace) {
            if (!this.isChainNamespaceInSession(namespace)) {
                throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.NOT_CONNECTED_ERROR, `Namespace '${namespace}' is not configured. Please call connect() first with namespace config.`);
            }
            if (chainId && chain) {
                (0, core_1.logDebug)('this.session.namespaces -->> ', namespace, JSON.stringify(this.session.namespaces));
                const chainsArr = (_a = this.session.namespaces[namespace]) === null || _a === void 0 ? void 0 : _a.chains;
                (0, core_1.logDebug)('get chainsArr & chain', JSON.stringify(chainsArr), chain);
                if (chainsArr && !chainsArr.includes(chain)) {
                    throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.NOT_CONNECTED_ERROR, `Namespace not include the chain '${chain}'`);
                }
            }
        }
        if (namespace && chainId) {
            (0, core_1.logDebug)('get name & chain', namespace, chainId);
            return [
                namespace,
                chainId
            ];
        }
        let defaultNamespace = (0, namespaces_1.parseNamespaceKey)(Object.keys(this.session.namespaces)[0]);
        const defaultChain = this.rpcProviders[defaultNamespace].getDefaultChain();
        (0, core_1.logDebug)('get default chain:', defaultChain);
        return [
            defaultNamespace,
            defaultChain
        ];
    }
    isChainNamespaceInSession(namespaceStr) {
        var _a, _b;
        if (Object.keys(((_a = this.session) === null || _a === void 0 ? void 0 : _a.namespaces) || {}).map((key)=>(0, namespaces_1.parseNamespaceKey)(key)).includes(namespaceStr)) {
            return true;
        }
        let isChainNamespaceInSession = false;
        Object.values(((_b = this.session) === null || _b === void 0 ? void 0 : _b.namespaces) || {}).forEach((namespace)=>{
            namespace.chains.forEach((chain)=>{
                if (chain.split(":")[0] == namespaceStr) {
                    isChainNamespaceInSession = true;
                }
            });
        });
        return isChainNamespaceInSession;
    }
    requestAccountsWithNamespace(namespace) {
        return this.getProvider(namespace).requestAccounts();
    }
    requestDefaultChainWithNamespace(namespace) {
        return this.getProvider(namespace).getDefaultChain();
    }
    requestAccounts() {
        return __awaiter(this, void 0, void 0, function*() {
            const [namespace] = this.validateChain();
            return yield this.getProvider(namespace).requestAccounts();
        });
    }
    onChainChanged(caip2Chain) {
        var _a;
        if (!((_a = this.session) === null || _a === void 0 ? void 0 : _a.namespaces)) return;
        const [namespace, chainId] = this.validateChain(caip2Chain);
        if (!chainId) return;
        if (this.session.namespaces[namespace]) {
            this.session.namespaces[namespace].defaultChain = chainId;
            this.persist("connectSession", this.session);
        }
        this.events.emit("chainChanged", chainId);
    }
    onConnect() {
        this.createProviders();
        if (this.session) {
            this.persist("connectSession", this.session);
        }
        this.events.emit("connect", {
            session: this.session
        });
        this.registerEventListeners();
    }
    cleanup() {
        return __awaiter(this, void 0, void 0, function*() {
            this.session = undefined;
            this.client.session = undefined;
            this.sessionProperties = undefined;
            this.persist("optionalNamespaces", undefined);
            this.persist("sessionProperties", undefined);
            this.persist("connectSession", undefined);
        });
    }
    persist(key, data) {
        (0, core_1.logDebug)('[evm u-provider] persisit data', key, data);
        return this.client.engine.connectionManager.saveSessionContent(key, data);
    }
    getFromStore(key) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.client.engine.connectionManager.getSessionContent(key);
        });
    }
    showRequestModal(args, chain) {
        try {
            const { namespace, requestParam } = this.buildRequestParamFromRequest(args, chain);
            return this.getProvider(namespace).showRequestModal(requestParam);
        } catch (e) {
            return false;
        }
    }
}
exports.OKXUniversalProvider = OKXUniversalProvider;
exports.default = OKXUniversalProvider;
}}),
"[project]/node_modules/@okxconnect/universal-provider/src/OKXBtcProvider.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OKXBtcProvider = void 0;
const _1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/index.js [app-client] (ecmascript)");
class OKXBtcProvider {
    constructor(provider){
        this.caip = [
            "btc:mainnet",
            "fractal:mainnet"
        ];
        this.provider = provider;
    }
    getAddressForChainId(chainId) {
        var _a, _b;
        let ns = this.checkChainId(chainId);
        if (ns == undefined) {
            throw new _1.OKXConnectError(_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `invalid chainId`);
        }
        let accounts = (_b = (_a = this.provider.session) === null || _a === void 0 ? void 0 : _a.namespaces['btc']) === null || _b === void 0 ? void 0 : _b.accounts.filter(function(account) {
            return account.startsWith(chainId);
        });
        if (accounts == undefined || accounts.length < 0) {
            throw new _1.OKXConnectError(_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `no connected account`);
        }
        let account = accounts[0];
        const address = account.split(':')[2];
        return address;
    }
    getAccount(chainId) {
        var _a, _b, _c;
        let ns = this.checkChainId(chainId);
        if (ns == undefined) {
            throw new _1.OKXConnectError(_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `invalid chainId`);
        }
        let extra = (_c = (_b = (_a = this.provider.session) === null || _a === void 0 ? void 0 : _a.namespaces['btc']) === null || _b === void 0 ? void 0 : _b.extra) === null || _c === void 0 ? void 0 : _c[chainId];
        let publicKey = "";
        if (extra != undefined) {
            publicKey = extra["compressedPublicKey"];
        }
        return {
            address: this.getAddressForChainId(chainId),
            publicKey: publicKey
        };
    }
    /**
     *
     * @param signStr
     * @param chainId
     * @param type
     * @returns
     */ signMessage(chainId, signStr, type) {
        return __awaiter(this, void 0, void 0, function*() {
            let ns = this.checkChainId(chainId);
            if (ns == undefined) {
                throw new _1.OKXConnectError(_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `invalid chainId`);
            }
            if (signStr === 'undefined') {
                throw new _1.OKXConnectError(_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `the method signMessage parmas error`);
            }
            let params = {
                signStr: signStr,
                from: this.getAddressForChainId(chainId)
            };
            if (type) {
                params.type = type;
            }
            try {
                const ret = yield this.provider.request({
                    method: "btc_signMessage",
                    params: params
                }, chainId);
                if ('result' in ret) {
                    return ret.result;
                } else {
                    let errorData = ret;
                    return errorData.error;
                }
            } catch (error) {
                if (error instanceof _1.OKXConnectError) {
                    throw error;
                }
                throw new _1.OKXConnectError(_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `the method signTransaction request error`);
            }
        });
    }
    /**
     *
     * @param chainId
     * @param toAddress
     * @param satoshis
     * @param options { feeRate: 0 }
     * @returns
     */ sendBitcoin(chainId, toAddress, satoshis, options) {
        return __awaiter(this, void 0, void 0, function*() {
            let ns = this.checkChainId(chainId);
            if (ns == undefined) {
                throw new _1.OKXConnectError(_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `invalid chainId`);
            }
            let params = {
                from: this.getAddressForChainId(chainId),
                to: toAddress,
                value: (satoshis / 100000000).toString()
            };
            if (options === null || options === void 0 ? void 0 : options.feeRate) {
                params["satBytes"] = options.feeRate.toString();
            }
            let result = yield this.send(chainId, params);
            if (result !== undefined && 'txhash' in result) {
                // return txhash directly
                return result.txhash;
            }
            // or return unexpected result
            return result;
        });
    }
    //  from - string：当前连接的钱包的 BTC 地址
    //  to - string：接受 BTC 的地址
    //  value - string：发送 BTC 的数量
    //  satBytes - string： (可选) 自定义费率
    //  memo - string： (可选) 指定 outputs OP_RETURN 内容 示例
    //  memoPos - number： (可选) 指定 outputs OP_RETURN 输出位置，如果传了 memo 则必须传入 memoPos 指定位置，否则 memo 不生效
    send(chainId, input) {
        return __awaiter(this, void 0, void 0, function*() {
            let ns = this.checkChainId(chainId);
            if (ns == undefined) {
                throw new _1.OKXConnectError(_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `invalid chainId`);
            }
            if (!this.checkParameters(input, 'to', 'value')) {
                throw new _1.OKXConnectError(_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `the method send parmas  error`);
            }
            input["from"] = this.getAddressForChainId(chainId);
            try {
                const ret = yield this.provider.request({
                    method: 'btc_send',
                    params: input
                }, chainId);
                if ('result' in ret) {
                    return {
                        txhash: ret.result
                    };
                } else {
                    let errorData = ret;
                    return errorData.error;
                }
            } catch (error) {
                if (error instanceof _1.OKXConnectError) {
                    throw error;
                }
                throw new _1.OKXConnectError(_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `the method send request error: ${error}`);
            }
        });
    }
    /**
     *
     * @param psbtHex string 要签名的 psbt 的十六进制字符串
     * @param options object { autoFinalized: 0 }
     */ signPsbt(chainId, psbtHex, options) {
        return __awaiter(this, void 0, void 0, function*() {
            return new Promise((resolve, reject)=>{
                this.signPsbts(chainId, [
                    psbtHex
                ], [
                    options
                ]).then((psbtResults)=>{
                    let results = JSON.parse(psbtResults);
                    resolve(results[0]);
                }).catch((error)=>{
                    reject(error);
                });
            });
        });
    }
    /**
     *
     * @param chainId
     * @param psbtHexs Array
     * @param options Array [{ autoFinalized: 0 }]
     * @returns
     */ signPsbts(chainId, psbtHexs, options) {
        return __awaiter(this, void 0, void 0, function*() {
            let ns = this.checkChainId(chainId);
            if (ns == undefined) {
                throw new _1.OKXConnectError(_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `invalid chainId`);
            }
            if (psbtHexs === undefined) {
                throw new _1.OKXConnectError(_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `the method signPsbts params error`);
            }
            let params = {
                psbtHexs: psbtHexs,
                options: options
            };
            params.from = this.getAddressForChainId(chainId);
            try {
                const ret = yield this.provider.request({
                    method: "btc_signPsbts",
                    params: params
                }, chainId);
                if ('result' in ret) {
                    return ret.result;
                }
            } catch (error) {
                if (error instanceof _1.OKXConnectError) {
                    throw error;
                }
                throw new _1.OKXConnectError(_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `the method send request error: ${error}`);
            }
        });
    }
    /**
     *
     * @param chainId
     * @param psbtHex string
     * @param options object
     * @returns
     */ signAndPushPsbt(chainId, psbtHex, options) {
        return __awaiter(this, void 0, void 0, function*() {
            let ns = this.checkChainId(chainId);
            if (ns == undefined) {
                throw new _1.OKXConnectError(_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `invalid chainId`);
            }
            if (psbtHex === undefined) {
                throw new _1.OKXConnectError(_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `the method signPsbts params error`);
            }
            let params = {
                psbtHex: psbtHex,
                options: options
            };
            params.from = this.getAddressForChainId(chainId);
            try {
                const ret = yield this.provider.request({
                    method: "btc_signAndPushPsbt",
                    params: params
                }, chainId);
                if ('result' in ret) {
                    return JSON.parse(ret.result);
                } else {
                    let errorData = ret;
                    return errorData.error;
                }
            } catch (error) {
                if (error instanceof _1.OKXConnectError) {
                    throw error;
                }
                throw new _1.OKXConnectError(_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `the method send request error: ${error}`);
            }
        });
    }
    /**
     *
     * @param address string, receiver address
     * @param inscriptionId string, 铭文 ID + 协议，没有传协议则默认是 Ordinals NFT ，目前仅支持 Ordinals 及 Atomicals 协议
     * @param options object, { feeRate: number } custom rates
     */ sendInscription(chainId, address, inscriptionId, options) {
        return __awaiter(this, void 0, void 0, function*() {
            let extension = {
                address: address,
                inscriptionId: inscriptionId,
                options: options
            };
            let ns = this.checkChainId(chainId);
            if (ns == undefined) {
                throw new _1.OKXConnectError(_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `invalid chainId`);
            }
            if (address === 'undefined') {
                throw new _1.OKXConnectError(_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `the method sendInscription params error`);
            }
            var feeRate = 0;
            if (options && 'feeRate' in options) {
                feeRate = options.feeRate;
            }
            let coinId = '';
            let from = this.getAddressForChainId(chainId);
            var protocolId = 7; //ProtocolIdBRCNFT
            if (inscriptionId !== 'undefined') {
                let atomicSuffix = "-Atomicals";
                let ordinalsSuffix = "-Ordinals";
                if (inscriptionId === null || inscriptionId === void 0 ? void 0 : inscriptionId.toLowerCase().endsWith(atomicSuffix.toLowerCase())) {
                    protocolId = 8; //WXRCProtocolIdARCNFT
                    inscriptionId = this.removeSuffix(inscriptionId, atomicSuffix);
                } else if (inscriptionId === null || inscriptionId === void 0 ? void 0 : inscriptionId.toLowerCase().endsWith(ordinalsSuffix.toLowerCase())) {
                    inscriptionId = this.removeSuffix(inscriptionId, ordinalsSuffix);
                }
            }
            let params = {
                scenario: 5,
                feeRate: feeRate,
                txType: "20",
                to: address,
                batchBean: [
                    {
                        coinAmount: "1",
                        nftId: inscriptionId,
                        protocolId: protocolId,
                        coinId: coinId,
                        inscriptionId: "",
                        from: from
                    }
                ],
                extension: extension
            };
            try {
                const ret = yield this.provider.request({
                    method: "btc_sendInscription",
                    params: params
                }, chainId);
                if ('result' in ret) {
                    return ret.result;
                } else {
                    let errorData = ret;
                    return errorData.error;
                }
            } catch (error) {
                if (error instanceof _1.OKXConnectError) {
                    throw error;
                }
                throw new _1.OKXConnectError(_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `the method signTransaction request error`);
            }
        });
    }
    removeSuffix(str, suffix) {
        if (str.endsWith(suffix)) {
            return str.slice(0, str.length - suffix.length);
        }
        return str;
    }
    checkParameters(params, ...keys) {
        var unexistKeys = [];
        keys.forEach((key)=>{
            if (!(`${key}` in params)) {
                unexistKeys.push(key);
            }
        });
        if (unexistKeys.length > 0) {
            console.log('not find key: ', unexistKeys.join(","));
            return false;
        }
        return true;
    }
    /**
     *
     * @param chainId eg. btc:mainnet
     * @returns eg. btc
     */ checkChainId(chainId) {
        if (this.caip.includes(chainId)) {
            let [namespaceKey, _] = chainId.split(":");
            return namespaceKey;
        }
        return undefined;
    }
}
exports.OKXBtcProvider = OKXBtcProvider;
exports.default = OKXBtcProvider;
}}),
"[project]/node_modules/@okxconnect/universal-provider/src/OKXCosmosProvider.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OKXCosmosProvider = void 0;
const core_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/index.js [app-client] (ecmascript)");
class OKXCosmosProvider {
    constructor(provider){
        this.provider = provider;
    }
    getAccount(chainId) {
        var _a, _b, _c, _d, _e, _f;
        (0, core_1.logDebug)("OKXCosmosProvider getAccount chainId:", chainId);
        (0, core_1.logDebug)("OKXCosmosProvider getAccount namespaces:", JSON.stringify((_a = this.provider.session) === null || _a === void 0 ? void 0 : _a.namespaces));
        let account = (_c = (_b = this.provider.session) === null || _b === void 0 ? void 0 : _b.namespaces[core_1.NameSpaceKeyCosmos]) === null || _c === void 0 ? void 0 : _c.accounts.filter(function(account) {
            return account.startsWith(chainId);
        })[0];
        (0, core_1.logDebug)("OKXCosmosProvider getAccount account:", JSON.stringify(account));
        if (!account) {
            // if (required) {
            //      throw new Error('Account not found')
            // }
            return undefined;
        }
        const accountArray = account.split(':');
        const address = account.split(':')[2];
        (0, core_1.logDebug)("OKXCosmosProvider getAccount address:", address);
        let extra = (_f = (_e = (_d = this.provider.session) === null || _d === void 0 ? void 0 : _d.namespaces[core_1.NameSpaceKeyCosmos]) === null || _e === void 0 ? void 0 : _e.extra) === null || _f === void 0 ? void 0 : _f[`${accountArray[0]}:${accountArray[1]}`];
        let publicKey = "";
        if (extra != undefined) {
            publicKey = extra["publicKey"];
            console.log("aptos_publicKey", publicKey);
        }
        if (!address) {
            // if (required) {
            //     throw new Error('Address not found')
            // }
            return undefined;
        }
        return {
            algo: "secp256k1",
            address: address,
            bech32Address: address,
            pubKey: this.hexToUint8Array(publicKey)
        };
    }
    signArbitrary(chainId, signerAddress, data) {
        return __awaiter(this, void 0, void 0, function*() {
            const base64Encoded = window.btoa(data);
            const signDoc = {
                chain_id: "",
                account_number: "0",
                sequence: "0",
                fee: {
                    gas: "0",
                    amount: []
                },
                msgs: [
                    {
                        "type": "sign/MsgSignData",
                        "value": {
                            "signer": signerAddress,
                            "data": base64Encoded
                        }
                    }
                ],
                memo: ""
            };
            let signData = {
                "chainId": chainId,
                "method": "cosmos_signArbitrary",
                "params": {
                    "signer": signerAddress,
                    "chain_id": chainId.split(":")[1],
                    "data": signDoc
                }
            };
            try {
                const ret = yield this.provider.request(signData, chainId);
                if ('result' in ret) {
                    if (typeof ret.result == "string") {
                        return JSON.parse(ret.result);
                    } else {
                        return ret.result;
                    }
                } else {
                    let errorData = ret;
                    return errorData.error;
                }
            } catch (error) {
                return error;
            // throw new OKXConnectError(OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `the method signTransaction request error`);
            }
        });
    }
    signAmino(chainId, signerAddress, signDoc, signOptions) {
        return __awaiter(this, void 0, void 0, function*() {
            if (signDoc.msgs[0].type == "sign/MsgSignData") {
                let signData = {
                    "chainId": chainId,
                    "method": "cosmos_signArbitrary",
                    "params": {
                        "signer": signerAddress,
                        "chain_id": chainId.split(":")[1],
                        "data": signDoc
                    }
                };
                try {
                    const ret = yield this.provider.request(signData, chainId);
                    if ('result' in ret) {
                        return ret.result;
                    } else {
                        let errorData = ret;
                        return errorData.error;
                    }
                } catch (error) {
                    return error;
                // throw new OKXConnectError(OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `the method signAmino request error`);
                }
            } else {
                let signData = {
                    "chainId": chainId,
                    "method": "cosmos_signAmino",
                    "params": {
                        "signer": signerAddress,
                        "chainId": chainId.split(":")[1],
                        "sign_doc": signDoc,
                        "signOptions": signOptions
                    }
                };
                try {
                    const ret = yield this.provider.request(signData, chainId);
                    if ('result' in ret) {
                        const resData = JSON.parse(ret.result);
                        console.log("signdoc", signDoc, resData.signDoc);
                        signDoc.fee = resData.signDoc.fee;
                        return {
                            signed: signDoc,
                            signature: resData.signature
                        };
                    } else {
                        let errorData = ret;
                        return errorData.error;
                    }
                } catch (error) {
                    // throw new OKXConnectError(OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `the method signAmino request error`);
                    return error;
                }
            }
        });
    }
    signDirect(chainId, signerAddress, signDoc, signOptions) {
        return __awaiter(this, void 0, void 0, function*() {
            const object = {
                bodyBytes: this.bufferToHex(signDoc.bodyBytes),
                authInfoBytes: this.bufferToHex(signDoc.authInfoBytes),
                chainId: signDoc.chainId,
                accountNumber: signDoc.accountNumber ? signDoc.accountNumber.toString() : null,
                signOptions: signOptions ? signOptions : null
            };
            let data = {
                "chainId": chainId,
                "method": "cosmos_signDirect",
                "params": {
                    "signer": signerAddress,
                    "chainId": chainId.split(":")[1],
                    "sign_doc": object
                }
            };
            try {
                const ret = yield this.provider.request(data, chainId);
                if ('result' in ret) {
                    const res = JSON.parse(ret.result);
                    console.log("signdirect result", res);
                    signDoc.authInfoBytes = this.messageToBuffer(res.signDoc.authInfoBytes);
                    return {
                        signed: signDoc,
                        signature: res.signature
                    };
                }
            } catch (error) {
                return error;
            // throw new OKXConnectError(OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `the method signTransaction request error`);
            }
        });
    }
    messageToBuffer(message) {
        var buffer = Uint8Array.from([]);
        try {
            if (typeof message === "string") {
                buffer = this.hexToUint8Array(message.replace("0x", ""));
            } else {
                buffer = Uint8Array.from(message);
            }
        } catch (err) {
            console.log(`messageToBuffer error: ${err}`);
        }
        return buffer;
    }
    bufferToHex(arr) {
        let output = [
            ...new Uint8Array(arr)
        ].map((x)=>x.toString(16).padStart(2, '0')).join('');
        return '0x' + output;
    }
    hexToUint8Array(hexString) {
        if (hexString.length % 2 !== 0) {
            throw "Invalid hexString";
        }
        var arrayBuffer = new Uint8Array(hexString.length / 2);
        for(var i = 0; i < hexString.length; i += 2){
            var byteValue = parseInt(hexString.substr(i, 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    }
}
exports.OKXCosmosProvider = OKXCosmosProvider;
}}),
"[project]/node_modules/@okxconnect/universal-provider/src/OKXTonProvider.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OKXTonProvider = void 0;
const _1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/index.js [app-client] (ecmascript)");
const core_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/index.js [app-client] (ecmascript)");
class OKXTonProvider {
    constructor(generator){
        this.statusChangeSubscriptions = [];
        this.statusChangeErrorSubscriptions = [];
        this.provider = generator;
        this.provider.on("connect", ()=>{
            let tonWallet = this.wallet();
            (0, core_1.logDebug)("OKXTONProvider event connect:", JSON.stringify(tonWallet));
            this.statusChangeSubscriptions.forEach((callback)=>callback(tonWallet));
        });
        this.provider.on("reconnect", ()=>{
            let tonWallet = this.wallet();
            (0, core_1.logDebug)("OKXTONProvider event reconnect:", JSON.stringify(tonWallet));
            this.statusChangeSubscriptions.forEach((callback)=>callback(tonWallet));
        });
        this.provider.on("disconnect", ()=>{
            (0, core_1.logDebug)("OKXTONProvider event disconnect:");
            this.statusChangeSubscriptions.forEach((callback)=>callback(null));
        });
        this.provider.on("connect_error", (error)=>{
            (0, core_1.logDebug)("OKXTONProvider event connect_error:", JSON.stringify(error));
            this.statusChangeErrorSubscriptions.forEach((errorsHandler)=>errorsHandler(error));
        });
    }
    connected() {
        if (this.provider.connected()) {
            return !!this.provider.session.namespaces["ton"];
        }
        return false;
    }
    account() {
        try {
            if (!this.provider.session) {
                return null;
            }
            let tonNameSpace = this.provider.session.namespaces['ton'];
            if (!tonNameSpace || !tonNameSpace.payload || !tonNameSpace.payload.ton_addr) {
                return null;
            }
            let ton_addr = tonNameSpace.payload.ton_addr;
            return {
                address: ton_addr.address,
                chain: ton_addr.network,
                walletStateInit: ton_addr.walletStateInit,
                publicKey: ton_addr.publicKey
            };
        } catch (e) {
            (0, core_1.logDebug)("OKXTONProvider account  error:", JSON.stringify(e));
            return null;
        }
    }
    wallet() {
        if (this.connected()) {
            try {
                let sessionWallet = this.provider.session.wallet;
                let tonDeviceInfo = {
                    platform: sessionWallet.platform,
                    appName: sessionWallet.appName,
                    appVersion: sessionWallet.appVersion,
                    maxProtocolVersion: sessionWallet.maxProtocolVersion,
                    features: [
                        'ton_sendTransaction'
                    ]
                };
                const wallet = {
                    device: tonDeviceInfo,
                    provider: "http",
                    account: this.account()
                };
                let tonNameSpace = this.provider.session.namespaces['ton'];
                if (tonNameSpace && tonNameSpace.payload && tonNameSpace.payload.ton_proof) {
                    wallet.connectItems = {
                        tonProof: tonNameSpace.payload.ton_proof
                    };
                }
                (0, core_1.logDebug)("OKXTONProvider wallet :", JSON.stringify(wallet));
                return wallet;
            } catch (e) {
                (0, core_1.logDebug)("OKXTONProvider wallet  error:", JSON.stringify(e));
                return null;
            }
        }
        return null;
    }
    onStatusChange(callback, errorsHandler) {
        this.statusChangeSubscriptions.push(callback);
        if (errorsHandler) {
            this.statusChangeErrorSubscriptions.push(errorsHandler);
        }
        return ()=>{
            this.statusChangeSubscriptions = this.statusChangeSubscriptions.filter((item)=>item !== callback);
            if (errorsHandler) {
                this.statusChangeErrorSubscriptions = this.statusChangeErrorSubscriptions.filter((item)=>item !== errorsHandler);
            }
        };
    }
    sendTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function*() {
            if (transaction.network && transaction.network !== core_1.TONCHAIN.MAINNET) {
                throw new _1.OKXConnectError(_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, 'OKXTONProvider sendTransaction network error');
            }
            if (!transaction.network) {
                transaction.network = core_1.TONCHAIN.MAINNET;
            }
            if (this.provider.session) {
                if (!transaction.from) {
                    const accounts = this.provider.requestAccountsWithNamespace('ton');
                    transaction.from = accounts[0];
                }
            }
            const requestParams = {
                method: "ton_sendTransaction",
                params: transaction
            };
            let chain = 'ton:' + core_1.TONCHAIN.MAINNET;
            (0, core_1.logDebug)("OKXTONProvider sendTransaction transaction----:", chain, JSON.stringify(requestParams));
            return this.provider.request(requestParams, chain);
        });
    }
}
exports.OKXTonProvider = OKXTonProvider;
exports.default = OKXTonProvider;
}}),
"[project]/node_modules/@okxconnect/universal-provider/src/OKXTronProvider.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OKXTronProvider = void 0;
const core_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/index.js [app-client] (ecmascript)");
class OKXTronProvider {
    constructor(provider){
        this.TRON_CHAIN_ID = "tron:mainnet";
        this.provider = provider;
    }
    getChain(chainId) {
        if (chainId == null) {
            chainId = this.TRON_CHAIN_ID;
        }
        if (chainId != this.TRON_CHAIN_ID) {
            throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.CHAIN_NOT_SUPPORTED, "The chainId:" + chainId + "is wrong for OKXTronProvider");
        }
        return chainId;
    }
    getAccount(chainId) {
        var _a, _b, _c, _d, _e;
        chainId = this.getChain(chainId);
        let account = (_b = (_a = this.provider.session) === null || _a === void 0 ? void 0 : _a.namespaces[core_1.NameSpaceKeyTron]) === null || _b === void 0 ? void 0 : _b.accounts.filter(function(account) {
            return account.startsWith(chainId);
        })[0];
        if (!account) {
            // if (required) {
            //      throw new Error('Account not found')
            // }
            return undefined;
        }
        const accountArray = account.split(':');
        const address = account.split(':')[2];
        let extra = (_e = (_d = (_c = this.provider.session) === null || _c === void 0 ? void 0 : _c.namespaces[core_1.NameSpaceKeyTron]) === null || _d === void 0 ? void 0 : _d.extra) === null || _e === void 0 ? void 0 : _e[`${accountArray[0]}:${accountArray[1]}`];
        let publicKey = "";
        if (extra != undefined) {
            publicKey = extra["publicKey"];
        }
        if (!address) {
            // if (required) {
            //     throw new Error('Address not found')
            // }
            return undefined;
        }
        return {
            address: address
        };
    }
    stringToHex(str) {
        let hex = '';
        for(let i = 0; i < str.length; i++){
            hex += str.charCodeAt(i).toString(16).padStart(2, '0');
        }
        return hex;
    }
    signMessage(data, chainId) {
        return __awaiter(this, void 0, void 0, function*() {
            chainId = this.getChain(chainId);
            let signData = {
                "chainId": chainId,
                "method": "tron_signMessage",
                "params": {
                    "message": this.stringToHex(data)
                }
            };
            try {
                const ret = yield this.provider.request(signData, chainId);
                if ('result' in ret) {
                    return ret.result;
                } else {
                    let errorData = ret;
                    return errorData.error;
                }
            } catch (error) {
                return error;
            // throw new OKXConnectError(OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `the method signTransaction request error`);
            }
        });
    }
    signMessageV2(data, chainId) {
        return __awaiter(this, void 0, void 0, function*() {
            chainId = this.getChain(chainId);
            let signData = {
                "chainId": chainId,
                "method": "tron_signMessageV2",
                "params": {
                    "message": data
                }
            };
            try {
                const ret = yield this.provider.request(signData, chainId);
                if ('result' in ret) {
                    return ret.result;
                } else {
                    let errorData = ret;
                    return errorData.error;
                }
            } catch (error) {
                return error;
            // throw new OKXConnectError(OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `the method signTransaction request error`);
            }
        });
    }
    signTransaction(transaction, chainId) {
        return __awaiter(this, void 0, void 0, function*() {
            chainId = this.getChain(chainId);
            let data = {
                "method": "tron_signTransaction",
                "params": transaction
            };
            try {
                const ret = yield this.provider.request(data, chainId);
                if ('result' in ret) {
                    let signedTx;
                    if (typeof ret.result == "string") {
                        signedTx = JSON.parse(ret.result);
                    } else {
                        signedTx = ret.result;
                    }
                    let realSignTx = {};
                    realSignTx.visible = signedTx.visible;
                    realSignTx.txID = signedTx.txID;
                    let rawData = {};
                    rawData.contract = signedTx.raw_data.contract;
                    rawData.expiration = signedTx.raw_data.expiration;
                    rawData.ref_block_bytes = signedTx.raw_data.ref_block_bytes;
                    rawData.fee_limit = signedTx.raw_data.fee_limit;
                    rawData.ref_block_hash = signedTx.raw_data.ref_block_hash;
                    rawData.timestamp = signedTx.raw_data.timestamp;
                    realSignTx.raw_data = rawData;
                    realSignTx.raw_data_hex = signedTx.raw_data_hex;
                    realSignTx.signature = signedTx.signature;
                    return realSignTx;
                }
            } catch (error) {
                return error;
            // throw new OKXConnectError(OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `the method signTransaction request error`);
            }
        });
    }
    signAndSendTransaction(transaction, chainId) {
        return __awaiter(this, void 0, void 0, function*() {
            chainId = this.getChain(chainId);
            let data = {
                "method": "tron_signAndSendTransaction",
                "params": transaction
            };
            try {
                const ret = yield this.provider.request(data, chainId);
                if ('result' in ret) {
                    return ret.result;
                }
            } catch (error) {
                return error;
            // throw new OKXConnectError(OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `the method signTransaction request error`);
            }
        });
    }
}
exports.OKXTronProvider = OKXTronProvider;
}}),
"[project]/node_modules/@okxconnect/universal-provider/src/OKXStarknetProvider.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OKXStarknetProvider = void 0;
const core_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/index.js [app-client] (ecmascript)");
class OKXStarknetProvider {
    constructor(provider){
        this.STARKNET_CHAIN_ID = "starknet:mainnet";
        this.provider = provider;
    }
    getChain(chainId) {
        if (chainId == null) {
            chainId = this.STARKNET_CHAIN_ID;
        }
        if (chainId != this.STARKNET_CHAIN_ID) {
            throw new core_1.OKXConnectError(core_1.OKX_CONNECT_ERROR_CODES.CHAIN_NOT_SUPPORTED, "The chainId:" + chainId + "is wrong for OKXStarknetProvider");
        }
        return chainId;
    }
    getAccount(chainId) {
        var _a, _b, _c, _d, _e;
        let account = (_b = (_a = this.provider.session) === null || _a === void 0 ? void 0 : _a.namespaces[core_1.NameSpaceKeyStarknet]) === null || _b === void 0 ? void 0 : _b.accounts.filter(function(account) {
            return account.startsWith(chainId);
        })[0];
        if (!account) {
            // if (required) {
            //      throw new Error('Account not found')
            // }
            return undefined;
        }
        const accountArray = account.split(':');
        const address = account.split(':')[2];
        let extra = (_e = (_d = (_c = this.provider.session) === null || _c === void 0 ? void 0 : _c.namespaces[core_1.NameSpaceKeyStarknet]) === null || _d === void 0 ? void 0 : _d.extra) === null || _e === void 0 ? void 0 : _e[`${accountArray[0]}:${accountArray[1]}`];
        let publicKey = "";
        if (extra != undefined) {
            publicKey = extra["publicKey"];
        }
        if (!address) {
            // if (required) {
            //     throw new Error('Address not found')
            // }
            return undefined;
        }
        return {
            address: address,
            pubKey: publicKey
        };
    }
    /**
     *
     * @param chainId
     * @param signerAddress
     * @param data: { types, primaryType, domain, message } as TypedData
     * @returns [signedDataR, signedDataS]
     */ signMessage(signerAddress, typedData, chainId) {
        return __awaiter(this, void 0, void 0, function*() {
            chainId = this.getChain(chainId);
            if (signerAddress.length == 0) {
                signerAddress = this.getAccount(chainId)["address"];
            }
            let signData = {
                "chainId": chainId,
                "method": "starknet_signMessage",
                "params": {
                    "accountAddress": signerAddress,
                    "typedData": typedData
                }
            };
            try {
                const ret = yield this.provider.request(signData, chainId);
                if ('result' in ret) {
                    let results = ret.result;
                    if (typeof results == 'string') {
                        results = JSON.parse(results);
                    }
                    return [
                        results["signedDataR"],
                        results["signedDataS"]
                    ];
                } else {
                    let errorData = ret;
                    return errorData.error;
                }
            } catch (error) {
                return error;
            // throw new OKXConnectError(OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `the method signTransaction request error`);
            }
        });
    }
    /**
     * sendTransaction
     * @param chainId
     * @param signerAddress
     * @param transaction
     * @returns { transaction_hash }
     */ sendTransaction(signerAddress, transaction, chainId) {
        return __awaiter(this, void 0, void 0, function*() {
            chainId = this.getChain(chainId);
            let transactionData = {
                "accountAddress": signerAddress,
                "executionRequest": transaction
            };
            let data = {
                "method": "starknet_sendTransaction",
                "params": {
                    "data": JSON.stringify(transactionData),
                    "from": signerAddress
                }
            };
            try {
                const ret = yield this.provider.request(data, chainId);
                if ('result' in ret) {
                    return {
                        transaction_hash: ret.result
                    };
                } else {
                    let errorData = ret;
                    return errorData.error;
                }
            } catch (error) {
                return error;
            // throw new OKXConnectError(OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `the method signTransaction request error`);
            }
        });
    }
    /**
     *
     * signMessage old API（rarely used, no need provide to external）
     * @param chainId
     * @param payload
     * @returns {transaction_hash, class_hash}
     */ signMessageDeclareContractPayload(payload, chainId) {
        return __awaiter(this, void 0, void 0, function*() {
            chainId = this.getChain(chainId);
            try {
                let data = {
                    "method": "starknet_signMessage",
                    "params": payload
                };
                const ret = yield this.provider.request(data, chainId);
                if ('result' in ret) {
                    return {
                        "transaction_hash": ret.result["txHash"],
                        "class_hash": ret.result["classHash"]
                    };
                } else {
                    let errorData = ret;
                    return errorData.error;
                }
            } catch (error) {
                return error;
            // throw new OKXConnectError(OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `the method signTransaction request error`);
            }
        });
    }
    /**
     * sendTransaction old API（rarely used, no need provide to external）
     * @param chainId
     * @param signerAddress
     * @param calls
     * @param abis
     * @param transactionsDetail
     * @returns { transaction_hash }
     */ /// todo： 
    /// 修改方法名
    /// chainId 放后面
    sendMessageExecuteTransactionDetail(signerAddress, calls, abis, transactionsDetail, chainId) {
        return __awaiter(this, void 0, void 0, function*() {
            chainId = this.getChain(chainId);
            const transactions = Array.isArray(calls) ? calls : [
                calls
            ];
            const executionRequest = {
                "calls": transactions,
                "abis": abis,
                "transactionsDetail": {
                    "nonce": transactionsDetail === null || transactionsDetail === void 0 ? void 0 : transactionsDetail.nonce,
                    "maxFee": transactionsDetail === null || transactionsDetail === void 0 ? void 0 : transactionsDetail.nonce,
                    "version": transactionsDetail === null || transactionsDetail === void 0 ? void 0 : transactionsDetail.version
                }
            };
            return this.sendTransaction(signerAddress, executionRequest, chainId);
        });
    }
}
exports.OKXStarknetProvider = OKXStarknetProvider;
}}),
"[project]/node_modules/@okxconnect/universal-provider/src/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OKXStarknetProvider = exports.OKXTronProvider = exports.OKXTonProvider = exports.OKXCosmosProvider = exports.OKXBtcProvider = exports.OKXUniversalProvider = void 0;
__exportStar(__turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/provider/types/index.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/packages/index.js [app-client] (ecmascript)"), exports);
var OKXUniversalProvider_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/OKXUniversalProvider.js [app-client] (ecmascript)");
Object.defineProperty(exports, "OKXUniversalProvider", {
    enumerable: true,
    get: function() {
        return OKXUniversalProvider_1.OKXUniversalProvider;
    }
});
var OKXBtcProvider_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/OKXBtcProvider.js [app-client] (ecmascript)");
Object.defineProperty(exports, "OKXBtcProvider", {
    enumerable: true,
    get: function() {
        return OKXBtcProvider_1.OKXBtcProvider;
    }
});
var OKXCosmosProvider_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/OKXCosmosProvider.js [app-client] (ecmascript)");
Object.defineProperty(exports, "OKXCosmosProvider", {
    enumerable: true,
    get: function() {
        return OKXCosmosProvider_1.OKXCosmosProvider;
    }
});
var OKXTonProvider_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/OKXTonProvider.js [app-client] (ecmascript)");
Object.defineProperty(exports, "OKXTonProvider", {
    enumerable: true,
    get: function() {
        return OKXTonProvider_1.OKXTonProvider;
    }
});
var OKXTronProvider_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/OKXTronProvider.js [app-client] (ecmascript)");
Object.defineProperty(exports, "OKXTronProvider", {
    enumerable: true,
    get: function() {
        return OKXTronProvider_1.OKXTronProvider;
    }
});
var OKXStarknetProvider_1 = __turbopack_require__("[project]/node_modules/@okxconnect/universal-provider/src/OKXStarknetProvider.js [app-client] (ecmascript)");
Object.defineProperty(exports, "OKXStarknetProvider", {
    enumerable: true,
    get: function() {
        return OKXStarknetProvider_1.OKXStarknetProvider;
    }
});
__exportStar(__turbopack_require__("[project]/node_modules/@okxconnect/core/src/index.js [app-client] (ecmascript)"), exports);
}}),
}]);

//# sourceMappingURL=node_modules_%40okxconnect_universal-provider_src_36aa5e._.js.map