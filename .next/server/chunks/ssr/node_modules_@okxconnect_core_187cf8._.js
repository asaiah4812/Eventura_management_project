module.exports = {

"[project]/node_modules/@okxconnect/core/src/connect/constants.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ConnectorState = exports.CONNECT_JSONRPC_VER = exports.OKXCONNECTOR_MESSAGE_TTL = exports.OKXCONNECTOR_WS_URL_PENDING_CLOSE_CODE = exports.OKXCONNECTOR_WS_URL_LIST = exports.OKXCONNECTOR_WS_URL_IDX_KEY = exports.OKXCONNECTOR_WS_URL_3 = exports.OKXCONNECTOR_WS_URL_2 = exports.OKXCONNECTOR_WS_URL_1 = exports.EVENT_EMITTER_MAX_LISTENERS = void 0;
exports.EVENT_EMITTER_MAX_LISTENERS = 10;
exports.OKXCONNECTOR_WS_URL_1 = "wss://wsdexpri.okx.com/ws/v1/wallet-connect-relay";
exports.OKXCONNECTOR_WS_URL_2 = "wss://wsdexpri.okx.ac/ws/v1/wallet-connect-relay";
exports.OKXCONNECTOR_WS_URL_3 = "wss://wsdexpri.coinall.ltd/ws/v1/wallet-connect-relay";
exports.OKXCONNECTOR_WS_URL_IDX_KEY = "wuik";
exports.OKXCONNECTOR_WS_URL_LIST = [
    exports.OKXCONNECTOR_WS_URL_1,
    exports.OKXCONNECTOR_WS_URL_2,
    exports.OKXCONNECTOR_WS_URL_3
];
exports.OKXCONNECTOR_WS_URL_PENDING_CLOSE_CODE = {
    TIME_OUT: 3990,
    CANCELED: 3991,
    FINISHED: 3992
};
exports.OKXCONNECTOR_MESSAGE_TTL = 300000;
// --------------- JSON RPC ---------------
exports.CONNECT_JSONRPC_VER = "2.0";
exports.ConnectorState = {
    InitState: 0,
    Connecting: 1,
    Connected: 2,
    Disconnected: 3,
    OnError: 4
};
}}),
"[project]/node_modules/@okxconnect/core/src/connect/storageconstants.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OKXCONNECTOR_STORAGE_CIPHER_METHOD = exports.OKXCONNECTOR_STORAGE_CRYPTO_CIPHERIV = exports.OKXCONNECTOR_STORAGER_CRYPTO_SALT = exports.OKXCONNECTOR_STORAGE_CRYPTO_PASSWORD = exports.OKXCONNECTOR_TON_KEY = exports.OKXCONNECTOR_CRYPTO_SENDER_PK_CACHE = exports.OKXCONNECTOR_TOKEN_CACHE = exports.OKXCONNECTOR_JWT_KEY = exports.OKXCONNECTOR_SESSION_PREFIX_KEY = exports.OKXCONNECTOR_CRYPTO_KEY = exports.OKXCONNECTOR_CACHE_KEY_DAPP = exports.OKXCONNECTOR_CACHE_KEY = void 0;
exports.OKXCONNECTOR_CACHE_KEY = "ck";
exports.OKXCONNECTOR_CACHE_KEY_DAPP = "ck_dapp";
exports.OKXCONNECTOR_CRYPTO_KEY = "cck_k";
exports.OKXCONNECTOR_SESSION_PREFIX_KEY = "cspk_";
exports.OKXCONNECTOR_JWT_KEY = "cjk_k";
exports.OKXCONNECTOR_TOKEN_CACHE = "ct";
exports.OKXCONNECTOR_CRYPTO_SENDER_PK_CACHE = "csp";
exports.OKXCONNECTOR_TON_KEY = "OKXStorage_ctc";
exports.OKXCONNECTOR_STORAGE_CRYPTO_PASSWORD = "scp";
exports.OKXCONNECTOR_STORAGER_CRYPTO_SALT = "scs";
exports.OKXCONNECTOR_STORAGE_CRYPTO_CIPHERIV = "scpc";
exports.OKXCONNECTOR_STORAGE_CIPHER_METHOD = "aes-256-cbc";
}}),
"[project]/node_modules/@okxconnect/core/src/protocol/error/okx-connect.error.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DEFAULT_ERROR = exports.STANDARD_ERROR_MAP = exports.SERVER_ERROR_CODE_RANGE = exports.RESERVED_ERROR_CODES = exports.SERVER_ERROR = exports.INTERNAL_ERROR = exports.INVALID_PARAMS = exports.METHOD_NOT_FOUND = exports.INVALID_REQUEST = exports.PARSE_ERROR = exports.OKX_CONNECT_ERROR_CODES = exports.OKXConnectError = void 0;
class OKXConnectError extends Error {
    constructor(code, message){
        if (message == undefined) {
            message = getDefaultMessageByCode(code);
        }
        super(message);
        this.code = code;
        this.message = `${OKXConnectError.prefix} ${message ? '\n' + message : ''}`;
        Object.setPrototypeOf(this, OKXConnectError.prototype);
    }
    toJSON() {
        return {
            message: this.message,
            code: this.code
        };
    }
}
exports.OKXConnectError = OKXConnectError;
OKXConnectError.prefix = '[OKX_CONNECT_SDK_ERROR]';
function getDefaultMessageByCode(code) {
    if (code == OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR) {
        return "unknown error";
    } else if (code == OKX_CONNECT_ERROR_CODES.BAD_REQUEST_ERROR) {
        return "bad request error";
    } else if (code == OKX_CONNECT_ERROR_CODES.ALREADY_CONNECTED_ERROR) {
        return "already connected error";
    } else if (code == OKX_CONNECT_ERROR_CODES.NOT_CONNECTED_ERROR) {
        return "not connected error";
    } else if (code == OKX_CONNECT_ERROR_CODES.UNKNOWN_APP_ERROR) {
        return "unknown app error";
    } else if (code == OKX_CONNECT_ERROR_CODES.USER_REJECTS_ERROR) {
        return "user rejects error";
    } else if (code == OKX_CONNECT_ERROR_CODES.USER_REJECTS_ERROR_CAUSE_REGISTER) {
        return "wallet address are registering";
    } else if (code == OKX_CONNECT_ERROR_CODES.METHOD_NOT_SUPPORTED) {
        return "method not supported";
    } else if (code == OKX_CONNECT_ERROR_CODES.CONNECTION_ERROR) {
        return "connect error";
    } else if (code == OKX_CONNECT_ERROR_CODES.CHAIN_NOT_SUPPORTED) {
        return "chain not supported";
    }
    return "unknown error";
}
var OKX_CONNECT_ERROR_CODES;
(function(OKX_CONNECT_ERROR_CODES) {
    OKX_CONNECT_ERROR_CODES[OKX_CONNECT_ERROR_CODES["UNKNOWN_ERROR"] = 0] = "UNKNOWN_ERROR";
    OKX_CONNECT_ERROR_CODES[OKX_CONNECT_ERROR_CODES["BAD_REQUEST_ERROR"] = 1] = "BAD_REQUEST_ERROR";
    OKX_CONNECT_ERROR_CODES[OKX_CONNECT_ERROR_CODES["ALREADY_CONNECTED_ERROR"] = 11] = "ALREADY_CONNECTED_ERROR";
    OKX_CONNECT_ERROR_CODES[OKX_CONNECT_ERROR_CODES["NOT_CONNECTED_ERROR"] = 12] = "NOT_CONNECTED_ERROR";
    OKX_CONNECT_ERROR_CODES[OKX_CONNECT_ERROR_CODES["UNKNOWN_APP_ERROR"] = 100] = "UNKNOWN_APP_ERROR";
    OKX_CONNECT_ERROR_CODES[OKX_CONNECT_ERROR_CODES["USER_REJECTS_ERROR"] = 300] = "USER_REJECTS_ERROR";
    OKX_CONNECT_ERROR_CODES[OKX_CONNECT_ERROR_CODES["USER_REJECTS_ERROR_CAUSE_REGISTER"] = 301] = "USER_REJECTS_ERROR_CAUSE_REGISTER";
    OKX_CONNECT_ERROR_CODES[OKX_CONNECT_ERROR_CODES["METHOD_NOT_SUPPORTED"] = 400] = "METHOD_NOT_SUPPORTED";
    OKX_CONNECT_ERROR_CODES[OKX_CONNECT_ERROR_CODES["CHAIN_NOT_SUPPORTED"] = 500] = "CHAIN_NOT_SUPPORTED";
    OKX_CONNECT_ERROR_CODES[OKX_CONNECT_ERROR_CODES["WALLET_NOT_SUPPORTED"] = 600] = "WALLET_NOT_SUPPORTED";
    OKX_CONNECT_ERROR_CODES[OKX_CONNECT_ERROR_CODES["CONNECTION_ERROR"] = 700] = "CONNECTION_ERROR";
})(OKX_CONNECT_ERROR_CODES || (exports.OKX_CONNECT_ERROR_CODES = OKX_CONNECT_ERROR_CODES = {}));
exports.PARSE_ERROR = "PARSE_ERROR";
exports.INVALID_REQUEST = "INVALID_REQUEST";
exports.METHOD_NOT_FOUND = "METHOD_NOT_FOUND";
exports.INVALID_PARAMS = "INVALID_PARAMS";
exports.INTERNAL_ERROR = "INTERNAL_ERROR";
exports.SERVER_ERROR = "SERVER_ERROR";
exports.RESERVED_ERROR_CODES = [
    -32700,
    -32600,
    -32601,
    -32602,
    -32603
];
exports.SERVER_ERROR_CODE_RANGE = [
    -32000,
    -32099
];
exports.STANDARD_ERROR_MAP = {
    [exports.PARSE_ERROR]: {
        code: -32700,
        message: "Parse error"
    },
    [exports.INVALID_REQUEST]: {
        code: -32600,
        message: "Invalid Request"
    },
    [exports.METHOD_NOT_FOUND]: {
        code: -32601,
        message: "Method not found"
    },
    [exports.INVALID_PARAMS]: {
        code: -32602,
        message: "Invalid params"
    },
    [exports.INTERNAL_ERROR]: {
        code: -32603,
        message: "Internal error"
    },
    [exports.SERVER_ERROR]: {
        code: -32000,
        message: "Server error"
    }
};
exports.DEFAULT_ERROR = exports.SERVER_ERROR;
}}),
"[project]/node_modules/@okxconnect/core/src/protocol/error/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OKX_CONNECT_ERROR_CODES = exports.OKXConnectError = void 0;
var okx_connect_error_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/protocol/error/okx-connect.error.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "OKXConnectError", {
    enumerable: true,
    get: function() {
        return okx_connect_error_1.OKXConnectError;
    }
});
Object.defineProperty(exports, "OKX_CONNECT_ERROR_CODES", {
    enumerable: true,
    get: function() {
        return okx_connect_error_1.OKX_CONNECT_ERROR_CODES;
    }
});
}}),
"[project]/node_modules/@okxconnect/core/src/protocol/misc.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NameSpaceKeyStarknet = exports.NameSpaceKeyTron = exports.NameSpaceKeyCosmos = exports.NameSpaceKeyAptos = exports.NameSpaceKeyBtc = exports.NameSpaceKeySui = exports.NameSpaceKeyTON = exports.NameSpaceKeySOL = exports.NameSpaceKeyEip155 = void 0;
exports.NameSpaceKeyEip155 = "eip155";
exports.NameSpaceKeySOL = "solana";
exports.NameSpaceKeyTON = "ton";
exports.NameSpaceKeySui = "sui";
exports.NameSpaceKeyBtc = "btc";
exports.NameSpaceKeyAptos = "aptos";
exports.NameSpaceKeyCosmos = "cosmos";
exports.NameSpaceKeyTron = "tron";
exports.NameSpaceKeyStarknet = "starknet";
}}),
"[project]/node_modules/@okxconnect/core/src/protocol/constants.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.tgwalletAppName = exports.tgwalletName = exports.tonConnectSdkVersion = exports.shortUniversalLink = exports.standardDeeplink = exports.downloadUrl = exports.standardUniversalLink = exports.okxDeeplink = void 0;
exports.getTestTwaUrl = getTestTwaUrl;
exports.getTestTgTwaUrl = getTestTgTwaUrl;
exports.okxDeeplink = 'okx://web3';
exports.standardUniversalLink = typeof window !== "undefined" && window.location.hostname.includes("okx.com") ? "https://link.okx.com/download" : "https://www.okx.com/download";
exports.downloadUrl = "https://www.okx.com/download";
// export const standardUniversalLink = 'http://localhost:5173';
exports.standardDeeplink = `${exports.okxDeeplink}/wallet/connect`;
exports.shortUniversalLink = `https://www.okx.com/ul/connect`;
// export const standardDeeplink = 'http://localhost:5173';
exports.tonConnectSdkVersion = '1';
// export const tgwalletName: string = "TCTestqdqwdqwdqBot"
exports.tgwalletName = "OKX_WALLET_BOT";
exports.tgwalletAppName = "start";
// https://t.me/OKX_WALLET_BOT/start
function getTestTwaUrl() {
    return window.okxTesttwaUrl;
}
function getTestTgTwaUrl() {
    return window.okxTestTgtwaUrl;
}
}}),
"[project]/node_modules/@okxconnect/core/src/protocol/connect/json-rpc.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isJsonRpcPayload = isJsonRpcPayload;
exports.isJsonRpcRequest = isJsonRpcRequest;
exports.isJsonRpcResponse = isJsonRpcResponse;
exports.isJsonRpcResult = isJsonRpcResult;
exports.isJsonRpcError = isJsonRpcError;
exports.payloadId = payloadId;
exports.getBigIntRpcId = getBigIntRpcId;
exports.formatJsonRpcRequest = formatJsonRpcRequest;
exports.formatJsonRpcResult = formatJsonRpcResult;
exports.formatJsonRpcError = formatJsonRpcError;
exports.isReservedErrorCode = isReservedErrorCode;
exports.getError = getError;
exports.getErrorByCode = getErrorByCode;
exports.formatErrorMessage = formatErrorMessage;
exports.isHttpUrl = isHttpUrl;
exports.isWsUrl = isWsUrl;
exports.parseConnectionError = parseConnectionError;
function isJsonRpcPayload(payload) {
    return typeof payload === "object" && "id" in payload && "jsonrpc" in payload && payload.jsonrpc === "2.0";
}
function isJsonRpcRequest(payload) {
    return isJsonRpcPayload(payload) && "method" in payload;
}
function isJsonRpcResponse(payload) {
    return isJsonRpcPayload(payload) && (isJsonRpcResult(payload) || isJsonRpcError(payload));
}
function isJsonRpcResult(payload) {
    return "result" in payload;
}
function isJsonRpcError(payload) {
    return "error" in payload;
}
const okx_connect_error_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/protocol/error/okx-connect.error.js [app-ssr] (ecmascript)");
const tweetnacl_1 = __importDefault(__turbopack_require__("[project]/node_modules/tweetnacl/nacl-fast.js [app-ssr] (ecmascript)"));
class IncrementalRandomGenerator {
    constructor(bits){
        this.i = 1;
        const typedArray = bits === 8 ? new Uint8Array(1) : bits === 16 ? new Uint16Array(1) : new Uint32Array(1);
        if (bits) {
            this.initialValue = tweetnacl_1.default.randomBytes(bits / 8)[0];
        } else {
            this.initialValue = 0;
        }
    }
    getNextValue() {
        return this.initialValue + this.i++;
    }
}
const uint8Generator = new IncrementalRandomGenerator(8);
const uint16Generator = new IncrementalRandomGenerator(16);
function payloadId() {
    const date = Date.now() * 1000;
    const extra = uint8Generator.getNextValue();
    return date + extra;
}
function getBigIntRpcId() {
    const date = BigInt(Date.now()) * BigInt(1000000);
    const extra = BigInt(uint16Generator.getNextValue());
    return date + extra;
}
function formatJsonRpcRequest(method, params, id) {
    return {
        id: id || payloadId(),
        jsonrpc: "2.0",
        method,
        params
    };
}
function formatJsonRpcResult(id, result) {
    return {
        id,
        jsonrpc: "2.0",
        result
    };
}
function formatJsonRpcError(id, error, data) {
    return {
        id,
        jsonrpc: "2.0",
        error: formatErrorMessage(error, data)
    };
}
function isReservedErrorCode(code) {
    return okx_connect_error_1.RESERVED_ERROR_CODES.includes(code);
}
function getError(type) {
    if (!Object.keys(okx_connect_error_1.STANDARD_ERROR_MAP).includes(type)) {
        return okx_connect_error_1.STANDARD_ERROR_MAP[okx_connect_error_1.DEFAULT_ERROR];
    }
    return okx_connect_error_1.STANDARD_ERROR_MAP[type];
}
function getErrorByCode(code) {
    const match = Object.values(okx_connect_error_1.STANDARD_ERROR_MAP).find((e)=>e.code === code);
    if (!match) {
        return okx_connect_error_1.STANDARD_ERROR_MAP[okx_connect_error_1.DEFAULT_ERROR];
    }
    return match;
}
function formatErrorMessage(error, data) {
    if (typeof error === "undefined") {
        return getError(okx_connect_error_1.INTERNAL_ERROR);
    }
    if (typeof error === "string") {
        error = Object.assign(Object.assign({}, getError(okx_connect_error_1.SERVER_ERROR)), {
            message: error
        });
    }
    if (typeof data !== "undefined") {
        error.data = data;
    }
    if (isReservedErrorCode(error.code)) {
        error = getErrorByCode(error.code);
    }
    return error;
}
function getUrlProtocol(url) {
    const matches = url.match(new RegExp(/^\w+:/, "gi"));
    if (!matches || !matches.length) return;
    return matches[0];
}
function matchRegexProtocol(url, regex) {
    const protocol = getUrlProtocol(url);
    if (typeof protocol === "undefined") return false;
    return new RegExp(regex).test(protocol);
}
function isHttpUrl(url) {
    return matchRegexProtocol(url, "^https?:");
}
function isWsUrl(url) {
    return matchRegexProtocol(url, "^wss?:");
}
function parseConnectionError(e, url, type) {
    return e.message.includes("getaddrinfo ENOTFOUND") || e.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${type} RPC url at ${url}`) : e;
}
}}),
"[project]/node_modules/@okxconnect/core/src/protocol/connect/engine.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IEngine = exports.ISignClient = exports.ISignClientEvents = exports.IEngineEvents = void 0;
const eventemitter3_1 = __importDefault(__turbopack_require__("[project]/node_modules/eventemitter3/index.js [app-ssr] (ecmascript)"));
class IEngineEvents extends eventemitter3_1.default {
    constructor(){
        super();
    }
}
exports.IEngineEvents = IEngineEvents;
class ISignClientEvents extends eventemitter3_1.default {
    constructor(){
        super();
    }
}
exports.ISignClientEvents = ISignClientEvents;
class ISignClient {
    constructor(data){
        this.data = data;
    }
}
exports.ISignClient = ISignClient;
class IEngine {
    constructor(client){
        this.client = client;
    }
}
exports.IEngine = IEngine;
}}),
"[project]/node_modules/@okxconnect/core/src/protocol/connect/ton/connect-wallet.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TONCHAIN = void 0;
var TONCHAIN;
(function(TONCHAIN) {
    TONCHAIN["MAINNET"] = "-239";
})(TONCHAIN || (exports.TONCHAIN = TONCHAIN = {}));
}}),
"[project]/node_modules/@okxconnect/core/src/protocol/connect/ton/connect-event.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CONNECT_ITEM_ERROR_CODES = void 0;
var CONNECT_ITEM_ERROR_CODES;
(function(CONNECT_ITEM_ERROR_CODES) {
    CONNECT_ITEM_ERROR_CODES[CONNECT_ITEM_ERROR_CODES["UNKNOWN_ERROR"] = 0] = "UNKNOWN_ERROR";
    CONNECT_ITEM_ERROR_CODES[CONNECT_ITEM_ERROR_CODES["METHOD_NOT_SUPPORTED"] = 400] = "METHOD_NOT_SUPPORTED";
})(CONNECT_ITEM_ERROR_CODES || (exports.CONNECT_ITEM_ERROR_CODES = CONNECT_ITEM_ERROR_CODES = {}));
}}),
"[project]/node_modules/@okxconnect/core/src/protocol/connect/ton/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CONNECT_ITEM_ERROR_CODES = exports.TONCHAIN = void 0;
var connect_wallet_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/protocol/connect/ton/connect-wallet.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "TONCHAIN", {
    enumerable: true,
    get: function() {
        return connect_wallet_1.TONCHAIN;
    }
});
var connect_event_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/protocol/connect/ton/connect-event.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "CONNECT_ITEM_ERROR_CODES", {
    enumerable: true,
    get: function() {
        return connect_event_1.CONNECT_ITEM_ERROR_CODES;
    }
});
}}),
"[project]/node_modules/@okxconnect/core/src/protocol/connect/wallet-info.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.creatOKXWalletInfo = creatOKXWalletInfo;
exports.creatOKXMiniAppWalletInfo = creatOKXMiniAppWalletInfo;
const constants_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/protocol/constants.js [app-ssr] (ecmascript)");
function creatOKXWalletInfo() {
    return {
        "appName": "okxAppWallet",
        "name": "OKX Wallet",
        "imageUrl": "https://static.okx.com/cdn/assets/imgs/247/58E63FEA47A2B7D7.png",
        "aboutUrl": constants_1.downloadUrl,
        "universalLink": constants_1.standardUniversalLink,
        "deepLink": constants_1.standardDeeplink,
        "platforms": [
            "ios",
            "android"
        ]
    };
}
function creatOKXMiniAppWalletInfo() {
    return {
        "appName": "okxMiniApp",
        "name": "OKX Mini Wallet",
        "imageUrl": "https://static.okx.com/cdn/assets/imgs/247/58E63FEA47A2B7D7.png",
        "aboutUrl": constants_1.downloadUrl,
        "universalLink": `https://t.me/${constants_1.tgwalletName}/start`,
        "deepLink": "",
        "platforms": [
            "ios",
            "android",
            'macos',
            'windows'
        ]
    };
}
}}),
"[project]/node_modules/@okxconnect/core/src/protocol/connect/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.creatOKXMiniAppWalletInfo = exports.creatOKXWalletInfo = exports.ISignClientEvents = exports.IEngine = exports.IEngineEvents = exports.ISignClient = exports.getBigIntRpcId = exports.formatJsonRpcRequest = exports.isJsonRpcError = exports.isJsonRpcResponse = exports.parseConnectionError = exports.isHttpUrl = exports.formatJsonRpcError = void 0;
var json_rpc_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/protocol/connect/json-rpc.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "formatJsonRpcError", {
    enumerable: true,
    get: function() {
        return json_rpc_1.formatJsonRpcError;
    }
});
Object.defineProperty(exports, "isHttpUrl", {
    enumerable: true,
    get: function() {
        return json_rpc_1.isHttpUrl;
    }
});
Object.defineProperty(exports, "parseConnectionError", {
    enumerable: true,
    get: function() {
        return json_rpc_1.parseConnectionError;
    }
});
Object.defineProperty(exports, "isJsonRpcResponse", {
    enumerable: true,
    get: function() {
        return json_rpc_1.isJsonRpcResponse;
    }
});
Object.defineProperty(exports, "isJsonRpcError", {
    enumerable: true,
    get: function() {
        return json_rpc_1.isJsonRpcError;
    }
});
Object.defineProperty(exports, "formatJsonRpcRequest", {
    enumerable: true,
    get: function() {
        return json_rpc_1.formatJsonRpcRequest;
    }
});
Object.defineProperty(exports, "getBigIntRpcId", {
    enumerable: true,
    get: function() {
        return json_rpc_1.getBigIntRpcId;
    }
});
var engine_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/protocol/connect/engine.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "ISignClient", {
    enumerable: true,
    get: function() {
        return engine_1.ISignClient;
    }
});
Object.defineProperty(exports, "IEngineEvents", {
    enumerable: true,
    get: function() {
        return engine_1.IEngineEvents;
    }
});
Object.defineProperty(exports, "IEngine", {
    enumerable: true,
    get: function() {
        return engine_1.IEngine;
    }
});
Object.defineProperty(exports, "ISignClientEvents", {
    enumerable: true,
    get: function() {
        return engine_1.ISignClientEvents;
    }
});
__exportStar(__turbopack_require__("[project]/node_modules/@okxconnect/core/src/protocol/connect/ton/index.js [app-ssr] (ecmascript)"), exports);
var wallet_info_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/protocol/connect/wallet-info.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "creatOKXWalletInfo", {
    enumerable: true,
    get: function() {
        return wallet_info_1.creatOKXWalletInfo;
    }
});
Object.defineProperty(exports, "creatOKXMiniAppWalletInfo", {
    enumerable: true,
    get: function() {
        return wallet_info_1.creatOKXMiniAppWalletInfo;
    }
});
}}),
"[project]/node_modules/@okxconnect/core/src/protocol/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.downloadUrl = exports.okxDeeplink = exports.tonConnectSdkVersion = exports.standardDeeplink = exports.standardUniversalLink = exports.NameSpaceKeyStarknet = exports.NameSpaceKeyTron = exports.NameSpaceKeyCosmos = exports.NameSpaceKeyAptos = exports.NameSpaceKeyBtc = exports.NameSpaceKeySui = exports.NameSpaceKeyTON = exports.NameSpaceKeySOL = exports.NameSpaceKeyEip155 = void 0;
__exportStar(__turbopack_require__("[project]/node_modules/@okxconnect/core/src/protocol/error/index.js [app-ssr] (ecmascript)"), exports);
var misc_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/protocol/misc.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "NameSpaceKeyEip155", {
    enumerable: true,
    get: function() {
        return misc_1.NameSpaceKeyEip155;
    }
});
Object.defineProperty(exports, "NameSpaceKeySOL", {
    enumerable: true,
    get: function() {
        return misc_1.NameSpaceKeySOL;
    }
});
Object.defineProperty(exports, "NameSpaceKeyTON", {
    enumerable: true,
    get: function() {
        return misc_1.NameSpaceKeyTON;
    }
});
Object.defineProperty(exports, "NameSpaceKeySui", {
    enumerable: true,
    get: function() {
        return misc_1.NameSpaceKeySui;
    }
});
Object.defineProperty(exports, "NameSpaceKeyBtc", {
    enumerable: true,
    get: function() {
        return misc_1.NameSpaceKeyBtc;
    }
});
Object.defineProperty(exports, "NameSpaceKeyAptos", {
    enumerable: true,
    get: function() {
        return misc_1.NameSpaceKeyAptos;
    }
});
Object.defineProperty(exports, "NameSpaceKeyCosmos", {
    enumerable: true,
    get: function() {
        return misc_1.NameSpaceKeyCosmos;
    }
});
Object.defineProperty(exports, "NameSpaceKeyTron", {
    enumerable: true,
    get: function() {
        return misc_1.NameSpaceKeyTron;
    }
});
Object.defineProperty(exports, "NameSpaceKeyStarknet", {
    enumerable: true,
    get: function() {
        return misc_1.NameSpaceKeyStarknet;
    }
});
var constants_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/protocol/constants.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "standardUniversalLink", {
    enumerable: true,
    get: function() {
        return constants_1.standardUniversalLink;
    }
});
Object.defineProperty(exports, "standardDeeplink", {
    enumerable: true,
    get: function() {
        return constants_1.standardDeeplink;
    }
});
Object.defineProperty(exports, "tonConnectSdkVersion", {
    enumerable: true,
    get: function() {
        return constants_1.tonConnectSdkVersion;
    }
});
Object.defineProperty(exports, "okxDeeplink", {
    enumerable: true,
    get: function() {
        return constants_1.okxDeeplink;
    }
});
Object.defineProperty(exports, "downloadUrl", {
    enumerable: true,
    get: function() {
        return constants_1.downloadUrl;
    }
});
__exportStar(__turbopack_require__("[project]/node_modules/@okxconnect/core/src/protocol/connect/index.js [app-ssr] (ecmascript)"), exports);
}}),
"[project]/node_modules/@okxconnect/core/src/utils/web-api.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.openLink = openLink;
exports.openLinkBlank = openLinkBlank;
exports.openDeeplinkWithFallback = openDeeplinkWithFallback;
exports.isMobileUserAgent = isMobileUserAgent;
exports.getUserAgent = getUserAgent;
exports.isOS = isOS;
exports.isBrowser = isBrowser;
const ua_parser_js_1 = __importDefault(__turbopack_require__("[project]/node_modules/ua-parser-js/src/ua-parser.js [app-ssr] (ecmascript)"));
const log_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/log.js [app-ssr] (ecmascript)");
function openLink(href, target = '_self') {
    (0, log_1.logDebug)('openLink', href, target);
    window.open(href, target, 'noopener noreferrer');
}
function openLinkBlank(href) {
    openLink(href, '_blank');
}
function openDeeplinkWithFallback(href, fallback) {
    const doFallback = ()=>{
        if (isBrowser('safari') || isOS('android') && isBrowser('firefox')) {
            // Safari does not support fallback to direct link.
            return;
        }
        fallback();
    };
    const fallbackTimeout = setTimeout(()=>doFallback(), 500);
    window.addEventListener('blur', ()=>clearTimeout(fallbackTimeout), {
        once: true
    });
    openLink(href, '_self');
}
function isMobileUserAgent() {
    let check = false;
    (function(a) {
        if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.slice(0, 4))) check = true;
    })(navigator.userAgent || navigator.vendor || window.opera);
    return check;
}
function getUserAgent() {
    var _a, _b, _c;
    const results = new ua_parser_js_1.default().getResult();
    const osName = (_a = results.os.name) === null || _a === void 0 ? void 0 : _a.toLowerCase();
    const deviceModel = (_b = results.device.model) === null || _b === void 0 ? void 0 : _b.toLowerCase();
    let os;
    switch(true){
        case deviceModel === 'ipad':
            os = 'ipad';
            break;
        case osName === 'ios':
            os = 'ios';
            break;
        case osName === 'android':
            os = 'android';
            break;
        case osName === 'mac os':
            os = 'macos';
            break;
        case osName === 'linux':
            os = 'linux';
            break;
        case osName === null || osName === void 0 ? void 0 : osName.includes('windows'):
            os = 'windows';
            break;
    }
    const browserName = (_c = results.browser.name) === null || _c === void 0 ? void 0 : _c.toLowerCase();
    let browser;
    switch(true){
        case browserName === 'chrome':
            browser = 'chrome';
            break;
        case browserName === 'firefox':
            browser = 'firefox';
            break;
        case browserName === null || browserName === void 0 ? void 0 : browserName.includes('safari'):
            browser = 'safari';
            break;
        case browserName === null || browserName === void 0 ? void 0 : browserName.includes('opera'):
            browser = 'opera';
            break;
    }
    return {
        os,
        browser
    };
}
function isOS(...os) {
    return os.includes(getUserAgent().os);
}
function isBrowser(...browser) {
    return browser.includes(getUserAgent().browser);
}
}}),
"[project]/node_modules/@okxconnect/core/src/utils/tma-api.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var _a, _b, _c, _d, _e, _f, _g;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isTmaPlatform = isTmaPlatform;
exports.isInTMA = isInTMA;
exports.isInTelegramBrowser = isInTelegramBrowser;
exports.sendExpand = sendExpand;
exports.sendOpenTelegramLink = sendOpenTelegramLink;
exports.versionCompare = versionCompare;
const url_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/url.js [app-ssr] (ecmascript)");
const log_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/log.js [app-ssr] (ecmascript)");
const protocol_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/protocol/index.js [app-ssr] (ecmascript)");
const web_api_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/web-api.js [app-ssr] (ecmascript)");
let initParams = {};
try {
    let locationHash = location.hash.toString();
    initParams = urlParseHashParams(locationHash);
} catch (e) {}
let tmaPlatform = 'unknown';
if (initParams === null || initParams === void 0 ? void 0 : initParams.tgWebAppPlatform) {
    tmaPlatform = (_a = initParams.tgWebAppPlatform) !== null && _a !== void 0 ? _a : 'unknown';
}
if (tmaPlatform === 'unknown') {
    const window = (0, url_1.getWindow)();
    tmaPlatform = (_d = (_c = (_b = window === null || window === void 0 ? void 0 : window.Telegram) === null || _b === void 0 ? void 0 : _b.WebApp) === null || _c === void 0 ? void 0 : _c.platform) !== null && _d !== void 0 ? _d : 'unknown';
}
let webAppVersion = '6.0';
if (initParams === null || initParams === void 0 ? void 0 : initParams.tgWebAppVersion) {
    webAppVersion = initParams.tgWebAppVersion;
}
if (!webAppVersion) {
    const window = (0, url_1.getWindow)();
    webAppVersion = (_g = (_f = (_e = window === null || window === void 0 ? void 0 : window.Telegram) === null || _e === void 0 ? void 0 : _e.WebApp) === null || _f === void 0 ? void 0 : _f.version) !== null && _g !== void 0 ? _g : '6.0';
}
/**
 * Returns true if the app is running in TMA on the specified platform.
 * @param platforms
 */ function isTmaPlatform(...platforms) {
    return platforms.includes(tmaPlatform);
}
/**
 * Returns true if the app is running in TMA.
 */ function isInTMA() {
    var _a;
    return tmaPlatform !== 'unknown' || !!((_a = (0, url_1.getWindow)()) === null || _a === void 0 ? void 0 : _a.TelegramWebviewProxy);
}
/**
 * Returns true if the app is running in the Telegram browser.
 */ function isInTelegramBrowser() {
    var _a;
    const isTelegramWebview = !!((_a = (0, url_1.getWindow)()) === null || _a === void 0 ? void 0 : _a.TelegramWebview);
    return (isInTMA() || isTelegramWebview) && tmaPlatform === 'unknown';
}
/**
 * Expand the app window.
 */ function sendExpand() {
    postEvent('web_app_expand', {});
}
/**
 * Opens link in TMA or in new tab and returns a function that closes the tab.
 * @param link The link to open.
 * @param fallback The function to call if the link can't be opened in TMA.
 */ function sendOpenTelegramLink(link, fallback) {
    const url = new URL(link);
    if (url.protocol !== 'http:' && url.protocol !== 'https:') {
        if (fallback) {
            return fallback();
        }
        throw new protocol_1.OKXConnectError(protocol_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `Url protocol is not supported: ${url}`);
    }
    if (url.hostname !== 't.me') {
        if (fallback) {
            return fallback();
        }
        throw new protocol_1.OKXConnectError(protocol_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `Url host is not supported: ${url}`);
    }
    const pathFull = url.pathname + url.search;
    if (isIframe() || versionAtLeast('6.1')) {
        postEvent('web_app_open_tg_link', {
            path_full: pathFull
        });
    } else {
        (0, web_api_1.openLinkBlank)('https://t.me' + pathFull);
    }
}
function isIframe() {
    try {
        const window = (0, url_1.getWindow)();
        if (!window) {
            return false;
        }
        return window.parent != null && window !== window.parent;
    } catch (e) {
        return false;
    }
}
function postEvent(eventType, eventData) {
    try {
        const window = (0, url_1.getWindow)();
        if (!window) {
            throw new protocol_1.OKXConnectError(protocol_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `Can't post event to parent window: window is not defined`);
        }
        if (window.TelegramWebviewProxy !== undefined) {
            (0, log_1.logDebug)('postEvent', eventType, eventData);
            window.TelegramWebviewProxy.postEvent(eventType, JSON.stringify(eventData));
        } else if (window.external && 'notify' in window.external) {
            (0, log_1.logDebug)('postEvent', eventType, eventData);
            window.external.notify(JSON.stringify({
                eventType: eventType,
                eventData: eventData
            }));
        } else if (isIframe()) {
            const trustedTarget = '*';
            const message = JSON.stringify({
                eventType: eventType,
                eventData: eventData
            });
            (0, log_1.logDebug)('postEvent', eventType, eventData);
            window.parent.postMessage(message, trustedTarget);
        } else {
            throw new protocol_1.OKXConnectError(protocol_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `Can't post event to TMA`);
        }
    } catch (e) {
        (0, log_1.logError)(`Can't post event to parent window: ${e}`);
    }
}
function urlParseHashParams(locationHash) {
    locationHash = locationHash.replace(/^#/, '');
    let params = {};
    if (!locationHash.length) {
        return params;
    }
    if (locationHash.indexOf('=') < 0 && locationHash.indexOf('?') < 0) {
        params._path = urlSafeDecode(locationHash);
        return params;
    }
    let qIndex = locationHash.indexOf('?');
    if (qIndex >= 0) {
        let pathParam = locationHash.substr(0, qIndex);
        params._path = urlSafeDecode(pathParam);
        locationHash = locationHash.substr(qIndex + 1);
    }
    let query_params = urlParseQueryString(locationHash);
    for(let k in query_params){
        params[k] = query_params[k];
    }
    return params;
}
function urlSafeDecode(urlencoded) {
    try {
        urlencoded = urlencoded.replace(/\+/g, '%20');
        return decodeURIComponent(urlencoded);
    } catch (e) {
        return urlencoded;
    }
}
function urlParseQueryString(queryString) {
    let params = {};
    if (!queryString.length) {
        return params;
    }
    let queryStringParams = queryString.split('&');
    let i, param, paramName, paramValue;
    for(i = 0; i < queryStringParams.length; i++){
        param = queryStringParams[i].split('=');
        paramName = urlSafeDecode(param[0]);
        paramValue = param[1] == null ? null : urlSafeDecode(param[1]);
        params[paramName] = paramValue;
    }
    return params;
}
function versionCompare(v1, v2) {
    if (typeof v1 !== 'string') v1 = '';
    if (typeof v2 !== 'string') v2 = '';
    let v1List = v1.replace(/^\s+|\s+$/g, '').split('.');
    let v2List = v2.replace(/^\s+|\s+$/g, '').split('.');
    let a, i, p1, p2;
    a = Math.max(v1List.length, v2List.length);
    for(i = 0; i < a; i++){
        p1 = parseInt(v1List[i]) || 0;
        p2 = parseInt(v2List[i]) || 0;
        if (p1 === p2) continue;
        if (p1 > p2) return 1;
        return -1;
    }
    return 0;
}
function versionAtLeast(ver) {
    return versionCompare(webAppVersion, ver) >= 0;
}
}}),
"[project]/node_modules/@okxconnect/core/src/utils/url.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.removeUrlLastSlash = removeUrlLastSlash;
exports.addPathToUrl = addPathToUrl;
exports.getUniversalLink = getUniversalLink;
exports.openOKXDeeplink = openOKXDeeplink;
exports.openOKXUniversalLink = openOKXUniversalLink;
exports.openOKXDeeplinkWithFallback = openOKXDeeplinkWithFallback;
exports.getWindow = getWindow;
exports.isTelegramUrl = isTelegramUrl;
exports.encodeTelegramUrlParameters = encodeTelegramUrlParameters;
exports.encodeConnectParams = encodeConnectParams;
exports.encodeTWAConnectURLParams = encodeTWAConnectURLParams;
exports.getAppWalletDeepLink = getAppWalletDeepLink;
exports.getAppWalletShortDeepLink = getAppWalletShortDeepLink;
exports.getTelegramWalletTWAUrl = getTelegramWalletTWAUrl;
exports.openOKXTMAWalletlinkWithFallback = openOKXTMAWalletlinkWithFallback;
exports.isInTMA = isInTMA;
exports.isInTelegramBrowser = isInTelegramBrowser;
exports.getOKXLink = getOKXLink;
const protocol_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/protocol/index.js [app-ssr] (ecmascript)");
const log_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/log.js [app-ssr] (ecmascript)");
const constants_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/protocol/constants.js [app-ssr] (ecmascript)");
const utils_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/utils.js [app-ssr] (ecmascript)");
const tma_api_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/tma-api.js [app-ssr] (ecmascript)");
function removeUrlLastSlash(url) {
    if (url.slice(-1) === '/') {
        return url.slice(0, -1);
    }
    return url;
}
function addPathToUrl(url, path) {
    return removeUrlLastSlash(url) + '/' + path;
}
function getUniversalLink(deeplinkUrl, useStandardUniversalLink = false) {
    console.log("getUniversalLink deeplinkUrl:", deeplinkUrl, ", useStandardUniversalLink:", useStandardUniversalLink);
    const replaceStrWithParam = `${protocol_1.standardDeeplink}?param=`;
    if (!useStandardUniversalLink && deeplinkUrl.startsWith(replaceStrWithParam)) {
        const cleanUrl = deeplinkUrl.replace(replaceStrWithParam, '');
        (0, log_1.logDebug)("getUniversalLink cleanUrl:", cleanUrl);
        const deeplinkEncodeUrl = encodeURIComponent(cleanUrl);
        (0, log_1.logDebug)("getUniversalLink standardUniversalLink:", protocol_1.standardUniversalLink);
        (0, log_1.logDebug)("getUniversalLink `${shortUniversalLink}?param=${deeplinkEncodeUrl}`:", `${constants_1.shortUniversalLink}?param=${deeplinkEncodeUrl}`);
        return `${constants_1.shortUniversalLink}?param=${deeplinkEncodeUrl}`;
    } else if (!useStandardUniversalLink && deeplinkUrl == protocol_1.standardDeeplink) {
        (0, log_1.logDebug)("getUniversalLink shortUniversalLink:", constants_1.shortUniversalLink);
        return constants_1.shortUniversalLink;
    } else {
        const deeplinkEncodeUrl = encodeURIComponent(deeplinkUrl);
        console.log("getUniversalLink standardUniversalLink:", protocol_1.standardUniversalLink);
        return `${protocol_1.standardUniversalLink}?deeplink=${deeplinkEncodeUrl}`;
    }
}
function openOKXDeeplink(deeplinkUrl) {
    var _a;
    const fullUrl = getUniversalLink(deeplinkUrl);
    const isTelegram = !!((_a = getWindow()) === null || _a === void 0 ? void 0 : _a.TelegramWebviewProxy);
    console.log("openOKXDeeplink fullUrl:", fullUrl);
    if (!(0, utils_1.isIos)()) {
        let newWindow = null;
        if (isTelegram) {
            newWindow = window.open(deeplinkUrl, '_blank');
        } else {
            window.location.href = deeplinkUrl;
        }
    } else {
        openOKXUniversalLink(fullUrl);
    }
}
function openOKXUniversalLink(fullUrl) {
    if (!(0, utils_1.isIos)()) {
        // if (isTelegram) {
        window.open(fullUrl, '_blank');
    // } else {
    //     window.location.href = fullUrl;
    // }
    } else {
        if (isInTMA()) {
            window.open(fullUrl, '_blank');
        } else {
            console.log("windowOpen[before]: ", Date.now());
            if (window === null || window === void 0 ? void 0 : window.okxLogDebug) {
                window.open(fullUrl, '_blank');
            } else {
                window.open(fullUrl, '_self');
            }
            console.log("windowOpen[after]: ", Date.now());
        }
    }
}
function openOKXDeeplinkWithFallback(deeplinkUrl) {
    var _a;
    const fullUrl = getUniversalLink(deeplinkUrl);
    const isTelegram = !!((_a = getWindow()) === null || _a === void 0 ? void 0 : _a.TelegramWebviewProxy);
    console.log("openOKXDeeplinkWithFallback fullUrl:", fullUrl);
    let deepLinkOpened = false;
    const timeoutDuration = 3000; // 1.5
    const downloadUrl = protocol_1.standardUniversalLink;
    console.log("openOKXDeeplinkWithFallback standardUniversalLink:", protocol_1.standardUniversalLink);
    if (!(0, utils_1.isIos)()) {
        let newWindow = null;
        var fallbackToDownloadPage = ()=>{
            if (!deepLinkOpened) {
                if (newWindow) {
                    newWindow.open(fullUrl, '_self');
                } else {
                    window.open(fullUrl, '_blank');
                }
            }
        };
        if (isTelegram) {
            newWindow = window.open(deeplinkUrl, '_blank');
        } else {
            window.location.href = deeplinkUrl;
        }
        setTimeout(fallbackToDownloadPage, timeoutDuration);
        window.addEventListener('blur', ()=>{
            deepLinkOpened = true;
        }, {
            once: true
        });
        document.addEventListener('visibilitychange', ()=>{
            if (document.visibilityState === 'hidden') {
                deepLinkOpened = true;
            }
        });
    } else {
        if (isTelegram) {
            window.open(fullUrl, '_blank');
        } else {
            console.log("windowOpen[before]: ", Date.now());
            if (window === null || window === void 0 ? void 0 : window.okxLogDebug) {
                window.open(fullUrl, '_blank');
            } else {
                window.open(fullUrl, '_self');
            }
            console.log("windowOpen[after]: ", Date.now());
        }
    }
}
function getWindow() {
    if (typeof window !== 'undefined') {
        return window;
    }
    return undefined;
}
function isTelegramUrl(link) {
    if (!link) {
        return false;
    }
    const url = new URL(link);
    return url.protocol === 'tg:' || url.hostname === 't.me';
}
function encodeTelegramUrlParameters(parameters) {
    let encodedParameters = parameters;
    encodedParameters = encodedParameters.replace(/\./g, '%2E');
    encodedParameters = encodedParameters.replace(/-/g, '%2D');
    encodedParameters = encodedParameters.replace(/_/g, '%5F');
    encodedParameters = encodedParameters.replace(/&/g, '-');
    encodedParameters = encodedParameters.replace(/=/g, '__');
    encodedParameters = encodedParameters.replace(/%/g, '--');
    return encodedParameters;
}
function encodeConnectParams(connectRequest) {
    const connectRequestStr = JSON.stringify(connectRequest);
    (0, log_1.logDebug)("url encodeConnectParams connectRequestStr ", connectRequestStr);
    const utf8Array = new TextEncoder().encode(connectRequestStr);
    const base64Encoded = btoa(String.fromCharCode(...utf8Array));
    // .replace(/\+/g, '-')
    // .replace(/\//g, '_')
    // .replace(/=+$/, ''); //Compatible with older versions of iOS. Cannot be added directly  (Base64 URL Safe)
    (0, log_1.logDebug)("url encodeConnectParams base64Encoded ", base64Encoded);
    return base64Encoded;
}
function encodeTWAConnectURLParams(connectRequest) {
    const connectRequestStr = JSON.stringify({
        topic: connectRequest.topic,
        clientId: connectRequest.clientId
    });
    (0, log_1.logDebug)("url encodeConnectParams connectRequestStr", connectRequestStr);
    const utf8Array = new TextEncoder().encode(connectRequestStr);
    const base64Encoded = btoa(String.fromCharCode(...utf8Array));
    return base64Encoded;
}
function getAppWalletDeepLink(connectParam) {
    return `${protocol_1.standardDeeplink}?param=${connectParam}`;
}
function getAppWalletShortDeepLink(topic, clientId) {
    return `${constants_1.shortUniversalLink}?topic=${topic}${(0, utils_1.getLastSixMd5Hash)(clientId)}`;
}
//  make telegram okx wallet TWA url
function getTelegramWalletTWAUrl(connectParam, redirectStr) {
    let base64Content = {
        okxconnect: "",
        redirect: "",
        extraparams: ""
    };
    if (connectParam) {
        base64Content.okxconnect = connectParam;
    }
    if (redirectStr) {
        base64Content.redirect = redirectStr;
    }
    let base64ContentStr = JSON.stringify(base64Content);
    const utf8Array = new TextEncoder().encode(base64ContentStr);
    const base64Encoded = btoa(String.fromCharCode(...utf8Array));
    const urlSafeBase64 = (0, utils_1.toSafeBase64FromBase64)(base64Encoded);
    (0, log_1.logDebug)('[TWA] open link:', base64Content, base64Encoded);
    if (connectParam || redirectStr) {
        if (!isInTMA()) {
            // return `http://localhost:5173?tgWebAppStartParam=${urlSafeBase64}`
            if ((0, constants_1.getTestTwaUrl)()) {
                return `${(0, constants_1.getTestTwaUrl)()}?tgWebAppStartParam=${urlSafeBase64}`;
            } else {
                return `tg://resolve?domain=${constants_1.tgwalletName}&appname=${constants_1.tgwalletAppName}&startapp=${urlSafeBase64}`;
            }
        } else {
            if ((0, constants_1.getTestTgTwaUrl)()) {
                return `${(0, constants_1.getTestTgTwaUrl)()}?startapp=${urlSafeBase64}`;
            } else {
                return `https://t.me/${constants_1.tgwalletName}/start?startapp=${urlSafeBase64}`;
            }
        }
    }
    if (!isInTMA()) {
        // return "http://localhost:5173"
        if ((0, constants_1.getTestTwaUrl)()) {
            return `${(0, constants_1.getTestTwaUrl)()}`;
        } else {
            return `tg://resolve?domain=${constants_1.tgwalletName}&appname=${constants_1.tgwalletAppName}`;
        }
    } else {
        if ((0, constants_1.getTestTgTwaUrl)()) {
            return `${(0, constants_1.getTestTgTwaUrl)()}`;
        } else {
            return `https://t.me/${constants_1.tgwalletName}/start`;
        }
    }
}
//  open TWA url in telegram
function openOKXTMAWalletlinkWithFallback(twaDeepLink) {
    var _a, _b, _c, _d, _e;
    (0, log_1.logDebug)('[TWA] open link:', twaDeepLink, "isInTMA ==> ", isInTMA());
    if (!isInTMA()) {
        if ((0, constants_1.getTestTwaUrl)()) {
            window.open(twaDeepLink, '_blank');
        } else {
            window.open(twaDeepLink, '_self');
        }
    } else {
        if ((_b = (_a = getWindow()) === null || _a === void 0 ? void 0 : _a.Telegram) === null || _b === void 0 ? void 0 : _b.WebApp) {
            (_e = (_d = (_c = getWindow()) === null || _c === void 0 ? void 0 : _c.Telegram) === null || _d === void 0 ? void 0 : _d.WebApp) === null || _e === void 0 ? void 0 : _e.openTelegramLink(twaDeepLink);
        } else {
            (0, tma_api_1.sendOpenTelegramLink)(twaDeepLink);
        }
    }
}
/**
 * Returns true if the app is running in TMA.
 */ function urlSafeDecode(urlencoded) {
    try {
        urlencoded = urlencoded.replace(/\+/g, '%20');
        return decodeURIComponent(urlencoded);
    } catch (e) {
        return urlencoded;
    }
}
function urlParseQueryString(queryString) {
    let params = {};
    if (!queryString.length) {
        return params;
    }
    let queryStringParams = queryString.split('&');
    let i, param, paramName, paramValue;
    for(i = 0; i < queryStringParams.length; i++){
        param = queryStringParams[i].split('=');
        paramName = urlSafeDecode(param[0]);
        paramValue = param[1] == null ? null : urlSafeDecode(param[1]);
        params[paramName] = paramValue;
    }
    return params;
}
function urlParseHashParams(locationHash) {
    locationHash = locationHash.replace(/^#/, '');
    let params = {};
    if (!locationHash.length) {
        return params;
    }
    if (locationHash.indexOf('=') < 0 && locationHash.indexOf('?') < 0) {
        params._path = urlSafeDecode(locationHash);
        return params;
    }
    let qIndex = locationHash.indexOf('?');
    if (qIndex >= 0) {
        let pathParam = locationHash.substr(0, qIndex);
        params._path = urlSafeDecode(pathParam);
        locationHash = locationHash.substr(qIndex + 1);
    }
    let query_params = urlParseQueryString(locationHash);
    for(let k in query_params){
        params[k] = query_params[k];
    }
    return params;
}
let initParams = {};
try {
    let locationHash = location.hash.toString();
    initParams = urlParseHashParams(locationHash);
} catch (e) {}
let tmaPlatform = 'unknown';
if (initParams === null || initParams === void 0 ? void 0 : initParams.tgWebAppPlatform) {
    tmaPlatform = (_a = initParams.tgWebAppPlatform) !== null && _a !== void 0 ? _a : 'unknown';
}
if (tmaPlatform === 'unknown') {
    const window1 = getWindow();
    tmaPlatform = (_d = (_c = (_b = window1 === null || window1 === void 0 ? void 0 : window1.Telegram) === null || _b === void 0 ? void 0 : _b.WebApp) === null || _c === void 0 ? void 0 : _c.platform) !== null && _d !== void 0 ? _d : 'unknown';
}
function isInTMA() {
    var _a;
    return tmaPlatform !== 'unknown' || !!((_a = getWindow()) === null || _a === void 0 ? void 0 : _a.TelegramWebviewProxy);
}
/**
 * Returns true if the app is running in the Telegram browser.
 */ function isInTelegramBrowser() {
    var _a;
    const isTelegramWebview = !!((_a = getWindow()) === null || _a === void 0 ? void 0 : _a.TelegramWebview);
    return (isInTMA() || isTelegramWebview) && tmaPlatform === 'unknown';
}
function getOKXLink(connectRequest, useMini = false, tmaReturnUrl) {
    (0, log_1.logDebug)(`url  getOKXLink() called connectRequest==> ${JSON.stringify(connectRequest)}  useMini=> ${useMini}  tmaReturnUrl==> ${tmaReturnUrl}`);
    if (useMini) {
        var encodeTGParams = encodeTWAConnectURLParams(connectRequest);
        return getTelegramWalletTWAUrl(encodeTGParams, tmaReturnUrl !== null && tmaReturnUrl !== void 0 ? tmaReturnUrl : "back");
    } else {
        if ((0, utils_1.useShortLink)()) {
            return getAppWalletShortDeepLink(connectRequest.topic, connectRequest.clientId);
        } else {
            const base64Encoded = encodeConnectParams(connectRequest);
            return `${protocol_1.standardDeeplink}?param=${base64Encoded}`;
        }
    }
}
}}),
"[project]/node_modules/@okxconnect/core/src/utils/call-for-success.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.callForSuccess = callForSuccess;
exports.delay = delay;
/**
 * Function to call ton api until we get response.
 * Because ton network is pretty unstable we need to make sure response is final.
 * @param {T} fn - function to call
 * @param {CallForSuccessOptions} [options] - optional configuration options
 */ function callForSuccess(fn, options) {
    return __awaiter(this, void 0, void 0, function*() {
        var _a, _b;
        const attempts = (_a = options === null || options === void 0 ? void 0 : options.attempts) !== null && _a !== void 0 ? _a : 3;
        const delayMs = (_b = options === null || options === void 0 ? void 0 : options.delayMs) !== null && _b !== void 0 ? _b : 800;
        if (typeof fn !== 'function') {
            throw new Error(`Expected a function, got ${typeof fn}`);
        }
        let i = 0;
        let lastError;
        while(i < attempts){
            try {
                return yield fn();
            } catch (err) {
                lastError = err;
                i++;
                if (i < attempts) {
                    yield delay(delayMs);
                }
            }
        }
        throw lastError;
    });
}
/**
 * Delays the execution of code for a specified number of milliseconds.
 * @param {number} timeout - The number of milliseconds to delay the execution.
 * @param {DelayOptions} [options] - Optional configuration options for the delay.
 * @return {Promise<void>} - A promise that resolves after the specified delay, or rejects if the delay is aborted.
 */ function delay(timeout, options) {
    return __awaiter(this, void 0, void 0, function*() {
        return new Promise((resolve, reject)=>{
            var _a, _b;
            if ((_a = options === null || options === void 0 ? void 0 : options.signal) === null || _a === void 0 ? void 0 : _a.aborted) {
                reject(new Error('Delay aborted'));
                return;
            }
            const timeoutId = setTimeout(()=>resolve(), timeout);
            (_b = options === null || options === void 0 ? void 0 : options.signal) === null || _b === void 0 ? void 0 : _b.addEventListener('abort', ()=>{
                clearTimeout(timeoutId);
                reject(new Error('Delay aborted'));
            });
        });
    });
}
}}),
"[project]/node_modules/@okxconnect/core/src/utils/reportconstants.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Report_WalletType_Key = exports.Report_Proceed_QRCode_Click = exports.Report_ChooseType_Download_Click = exports.Report_ChooseType_ConnectWallet_Click = exports.Report_Proceed_Retry_Click = exports.Report_ChooseType_ConnectWallet_View = exports.Report_Loading_ConnectWallet_View = exports.Report_Proceed_QRCode_View = exports.Report_Proceed_Proceed_View = void 0;
exports.Report_Proceed_Proceed_View = "OKXConnectSDK_Proceed_Proceed_View";
exports.Report_Proceed_QRCode_View = "OKXConnectSDK_Proceed_QRCode_View";
exports.Report_Loading_ConnectWallet_View = "OKXConnectSDK_Loading_ConnectWallet_View";
exports.Report_ChooseType_ConnectWallet_View = "OKXConnectSDK_ChooseType_ConnectWallet_View";
exports.Report_Proceed_Retry_Click = "OKXConnectSDK_Proceed_Retry_Click";
exports.Report_ChooseType_ConnectWallet_Click = "OKXConnectSDK_ChooseType_ConnectWallet_Click";
exports.Report_ChooseType_Download_Click = "OKXConnectSDK_ChooseType_Download_Click";
exports.Report_Proceed_QRCode_Click = "OKXConnectSDK_Proceed_QRCode_Click";
exports.Report_WalletType_Key = 'wallet_type';
}}),
"[project]/node_modules/@okxconnect/core/src/utils/request.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.checkMetaData = checkMetaData;
const protocol_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/protocol/index.js [app-ssr] (ecmascript)");
function checkMetaData(dappMetaData) {
    if (!dappMetaData) {
        throw new protocol_1.OKXConnectError(protocol_1.OKX_CONNECT_ERROR_CODES.BAD_REQUEST_ERROR, "You have to specify a `dappMetaData`in the options.");
    }
    if (!dappMetaData.name) {
        throw new protocol_1.OKXConnectError(protocol_1.OKX_CONNECT_ERROR_CODES.BAD_REQUEST_ERROR, "dappName is required");
    }
    if (!dappMetaData.icon) {
        throw new protocol_1.OKXConnectError(protocol_1.OKX_CONNECT_ERROR_CODES.BAD_REQUEST_ERROR, "icon is required");
    }
    return true;
}
}}),
"[project]/node_modules/@okxconnect/core/src/utils/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.checkMetaData = exports.versionCompare = exports.isBrowser = exports.isOS = exports.isMobileUserAgent = exports.openDeeplinkWithFallback = exports.openLinkBlank = exports.openLink = exports.useShortLink = exports.toSafeBase64FromBase64 = exports.isValidObject = exports.isIos = exports.base64decode = exports.base64encode = exports.splitToUint8Arrays = exports.concatUint8Arrays = exports.toHexString = exports.hexToByteArray = exports.getOKXLink = exports.openOKXUniversalLink = exports.getAppWalletShortDeepLink = exports.encodeTWAConnectURLParams = exports.encodeConnectParams = exports.openOKXTMAWalletlinkWithFallback = exports.getTelegramWalletTWAUrl = exports.getAppWalletDeepLink = exports.encodeTelegramUrlParameters = exports.isTelegramUrl = exports.openOKXDeeplinkWithFallback = exports.openOKXDeeplink = exports.getUniversalLink = exports.safeJsonStringify = exports.safeJsonParse = exports.getDefaultReporter = exports.reportEvent = exports.reportLog = exports.logWarning = exports.logError = exports.logDebug = exports.callForSuccess = void 0;
var call_for_success_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/call-for-success.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "callForSuccess", {
    enumerable: true,
    get: function() {
        return call_for_success_1.callForSuccess;
    }
});
var log_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/log.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "logDebug", {
    enumerable: true,
    get: function() {
        return log_1.logDebug;
    }
});
Object.defineProperty(exports, "logError", {
    enumerable: true,
    get: function() {
        return log_1.logError;
    }
});
Object.defineProperty(exports, "logWarning", {
    enumerable: true,
    get: function() {
        return log_1.logWarning;
    }
});
Object.defineProperty(exports, "reportLog", {
    enumerable: true,
    get: function() {
        return log_1.reportLog;
    }
});
Object.defineProperty(exports, "reportEvent", {
    enumerable: true,
    get: function() {
        return log_1.reportEvent;
    }
});
Object.defineProperty(exports, "getDefaultReporter", {
    enumerable: true,
    get: function() {
        return log_1.getDefaultReporter;
    }
});
__exportStar(__turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/reportconstants.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/report.js [app-ssr] (ecmascript)"), exports);
var safejson_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/safejson.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "safeJsonParse", {
    enumerable: true,
    get: function() {
        return safejson_1.safeJsonParse;
    }
});
Object.defineProperty(exports, "safeJsonStringify", {
    enumerable: true,
    get: function() {
        return safejson_1.safeJsonStringify;
    }
});
var url_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/url.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "getUniversalLink", {
    enumerable: true,
    get: function() {
        return url_1.getUniversalLink;
    }
});
Object.defineProperty(exports, "openOKXDeeplink", {
    enumerable: true,
    get: function() {
        return url_1.openOKXDeeplink;
    }
});
Object.defineProperty(exports, "openOKXDeeplinkWithFallback", {
    enumerable: true,
    get: function() {
        return url_1.openOKXDeeplinkWithFallback;
    }
});
Object.defineProperty(exports, "isTelegramUrl", {
    enumerable: true,
    get: function() {
        return url_1.isTelegramUrl;
    }
});
Object.defineProperty(exports, "encodeTelegramUrlParameters", {
    enumerable: true,
    get: function() {
        return url_1.encodeTelegramUrlParameters;
    }
});
Object.defineProperty(exports, "getAppWalletDeepLink", {
    enumerable: true,
    get: function() {
        return url_1.getAppWalletDeepLink;
    }
});
Object.defineProperty(exports, "getTelegramWalletTWAUrl", {
    enumerable: true,
    get: function() {
        return url_1.getTelegramWalletTWAUrl;
    }
});
Object.defineProperty(exports, "openOKXTMAWalletlinkWithFallback", {
    enumerable: true,
    get: function() {
        return url_1.openOKXTMAWalletlinkWithFallback;
    }
});
Object.defineProperty(exports, "encodeConnectParams", {
    enumerable: true,
    get: function() {
        return url_1.encodeConnectParams;
    }
});
Object.defineProperty(exports, "encodeTWAConnectURLParams", {
    enumerable: true,
    get: function() {
        return url_1.encodeTWAConnectURLParams;
    }
});
Object.defineProperty(exports, "getAppWalletShortDeepLink", {
    enumerable: true,
    get: function() {
        return url_1.getAppWalletShortDeepLink;
    }
});
Object.defineProperty(exports, "openOKXUniversalLink", {
    enumerable: true,
    get: function() {
        return url_1.openOKXUniversalLink;
    }
});
Object.defineProperty(exports, "getOKXLink", {
    enumerable: true,
    get: function() {
        return url_1.getOKXLink;
    }
});
var utils_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/utils.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "hexToByteArray", {
    enumerable: true,
    get: function() {
        return utils_1.hexToByteArray;
    }
});
Object.defineProperty(exports, "toHexString", {
    enumerable: true,
    get: function() {
        return utils_1.toHexString;
    }
});
Object.defineProperty(exports, "concatUint8Arrays", {
    enumerable: true,
    get: function() {
        return utils_1.concatUint8Arrays;
    }
});
Object.defineProperty(exports, "splitToUint8Arrays", {
    enumerable: true,
    get: function() {
        return utils_1.splitToUint8Arrays;
    }
});
Object.defineProperty(exports, "base64encode", {
    enumerable: true,
    get: function() {
        return utils_1.base64encode;
    }
});
Object.defineProperty(exports, "base64decode", {
    enumerable: true,
    get: function() {
        return utils_1.base64decode;
    }
});
Object.defineProperty(exports, "isIos", {
    enumerable: true,
    get: function() {
        return utils_1.isIos;
    }
});
Object.defineProperty(exports, "isValidObject", {
    enumerable: true,
    get: function() {
        return utils_1.isValidObject;
    }
});
Object.defineProperty(exports, "toSafeBase64FromBase64", {
    enumerable: true,
    get: function() {
        return utils_1.toSafeBase64FromBase64;
    }
});
Object.defineProperty(exports, "useShortLink", {
    enumerable: true,
    get: function() {
        return utils_1.useShortLink;
    }
});
var web_api_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/web-api.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "openLink", {
    enumerable: true,
    get: function() {
        return web_api_1.openLink;
    }
});
Object.defineProperty(exports, "openLinkBlank", {
    enumerable: true,
    get: function() {
        return web_api_1.openLinkBlank;
    }
});
Object.defineProperty(exports, "openDeeplinkWithFallback", {
    enumerable: true,
    get: function() {
        return web_api_1.openDeeplinkWithFallback;
    }
});
Object.defineProperty(exports, "isMobileUserAgent", {
    enumerable: true,
    get: function() {
        return web_api_1.isMobileUserAgent;
    }
});
Object.defineProperty(exports, "isOS", {
    enumerable: true,
    get: function() {
        return web_api_1.isOS;
    }
});
Object.defineProperty(exports, "isBrowser", {
    enumerable: true,
    get: function() {
        return web_api_1.isBrowser;
    }
});
var tma_api_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/tma-api.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "versionCompare", {
    enumerable: true,
    get: function() {
        return tma_api_1.versionCompare;
    }
});
var request_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/request.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "checkMetaData", {
    enumerable: true,
    get: function() {
        return request_1.checkMetaData;
    }
});
}}),
"[project]/node_modules/@okxconnect/core/src/utils/report.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OKXReporter = exports.OKXReportSide = exports.OKXReportType = exports.versionStr = void 0;
const cross_fetch_1 = __importDefault(__turbopack_require__("[project]/node_modules/cross-fetch/dist/node-ponyfill.js [app-ssr] (ecmascript)"));
const log_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/log.js [app-ssr] (ecmascript)");
const url_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/url.js [app-ssr] (ecmascript)");
const utils_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/index.js [app-ssr] (ecmascript)");
const localforage_1 = __importDefault(__turbopack_require__("[project]/node_modules/localforage/dist/localforage.js [app-ssr] (ecmascript)"));
const tweetnacl_1 = __importDefault(__turbopack_require__("[project]/node_modules/tweetnacl/nacl-fast.js [app-ssr] (ecmascript)"));
exports.versionStr = '1.6.1';
const reportApiList = [
    'https://www.okx.com/dappstat/wallet-connect',
    'https://www.okx.ac/dappstat/wallet-connect'
];
const reportCacheKey = 'OKX_RP_CK';
const reportUUIDKey = 'OKX_RP_UUID_CK';
const MAX_LIMIT_REPORTCOUNT = 100;
const DEFAULT_HTTP_HEADERS = {
    Accept: "*/*",
    "Content-Type": "text/plain"
};
const DEFAULT_HTTP_METHOD = "POST";
const DEFAULT_FETCH_OPTS = {
    headers: DEFAULT_HTTP_HEADERS,
    method: DEFAULT_HTTP_METHOD
};
exports.OKXReportType = {
    PAGE_IN: 'page_in',
    PAGE_OUT: 'page_out',
    CLICK: 'click',
    LOG: 'log'
};
exports.OKXReportSide = {
    DAPP: 'dapp',
    WALLET: 'wallet'
};
class IReporter {
}
const fetchWithTimeout = (url, options, timeout = 5000)=>{
    const controller = new AbortController();
    const signal = controller.signal;
    const fetchPromise = (0, cross_fetch_1.default)(url, Object.assign(Object.assign({}, options), {
        signal
    }));
    const timeoutPromise = new Promise((_, reject)=>setTimeout(()=>{
            controller.abort();
            reject(new Error('Request timed out'));
        }, timeout));
    return Promise.race([
        fetchPromise,
        timeoutPromise
    ]);
};
const fetchListWithTimeout = (urls_1, ...args_1)=>__awaiter(void 0, [
        urls_1,
        ...args_1
    ], void 0, function*(urls, options = {}, timeout = 5000) {
        for (const url of urls){
            try {
                const controller = new AbortController();
                const signal = controller.signal;
                const fetchPromise = (0, cross_fetch_1.default)(url, Object.assign(Object.assign({}, options), {
                    signal
                }));
                const timeoutPromise = new Promise((_, reject)=>setTimeout(()=>{
                        controller.abort();
                        reject(new Error('Request timed out'));
                    }, timeout));
                const response = yield Promise.race([
                    fetchPromise,
                    timeoutPromise
                ]);
                if (response.ok) {
                    return response;
                }
                if (response.status == 502) {
                    console.error(`Fetch error status 502`, url);
                    return response;
                }
            } catch (error) {
                console.error(`Fetch error for ${url}:`, error);
            }
        }
        console.error(`'All fetch attempts failed.'`);
        throw new Error('All fetch attempts failed.');
    });
class OKXReporter {
    constructor(){
        this.currentSide = exports.OKXReportSide.DAPP;
        this.currentVersion = exports.versionStr;
        this.storage = localforage_1.default.createInstance({
            name: "OKXReporter"
        });
        this.recordList = new Array();
        this.currentUUID = (0, utils_1.toHexString)(tweetnacl_1.default.randomBytes(16));
    }
    configVersionAndSide(version, side, appname) {
        this.currentVersion = version;
        this.currentSide = side;
        this.appName = appname;
    }
    get recordCacheKey() {
        return reportCacheKey + "@" + this.appName;
    }
    get reportPlatform() {
        if ((0, utils_1.isMobileUserAgent)()) {
            if ((0, utils_1.isIos)()) {
                return 'iOS';
            } else {
                return 'android';
            }
        } else {
            return 'pc';
        }
    }
    beginReport() {
        return __awaiter(this, void 0, void 0, function*() {
            this.startErrorCatching();
            let records = yield this.storage.getItem(this.recordCacheKey);
            let uuid = yield this.storage.getItem(reportUUIDKey);
            if (uuid) {
                this.currentUUID = uuid;
            } else {
                this.storage.setItem(reportUUIDKey, this.currentUUID);
            }
            if (records) {
                this.recordList = records;
                (0, log_1.logDebug)('resume records from cache length: ', this.recordList.length);
                yield this.sendCachedRecords();
            }
        });
    }
    startErrorCatching() {
        let window = (0, url_1.getWindow)();
        if (window) {
            (0, log_1.logDebug)('begin capture console error');
        // window.onerror = (event: Event | string, source?: string, lineno?: number, colno?: number, error?: Error) => {
        //     logDebug('capture error info:', error, source)
        //     this.markRecord(error?.message+'/'+error?.name+'/'+error?.stack, OKXReportType.LOG, '', this.currentSide)
        // }
        }
    }
    cachedErrors() {
        return this.recordList;
    }
    sendRecord(record) {
        return __awaiter(this, void 0, void 0, function*() {
            return new Promise((resolve, reject)=>__awaiter(this, void 0, void 0, function*() {
                    try {
                        const body = JSON.stringify(record);
                        (0, log_1.logDebug)('[REPORT] record: ', body);
                        const res = yield fetchListWithTimeout(reportApiList, Object.assign(Object.assign({}, DEFAULT_FETCH_OPTS), {
                            body: body
                        }));
                        (0, log_1.logDebug)('[REPORT] get rsp:', res);
                        if (res && res.status && res.status == 200) {
                            this.recordList = this.recordList.filter((item)=>{
                                return item.timestamp != record.timestamp || item.content != record.content;
                            });
                            yield this.storage.setItem(this.recordCacheKey, this.recordList);
                            resolve(true);
                        } else {
                            reject(false);
                        }
                    } catch (e) {
                        (0, log_1.logDebug)('send record error:', e);
                        resolve(true);
                    // reject(e)
                    }
                }));
        });
    }
    sendRecordContent(content, type, action) {
        return __awaiter(this, void 0, void 0, function*() {
            var _a, _b, _c, _d;
            let path = (_a = (0, url_1.getWindow)()) === null || _a === void 0 ? void 0 : _a.location.pathname;
            let location = (_b = (0, url_1.getWindow)()) === null || _b === void 0 ? void 0 : _b.location.origin;
            if (path && location) {
                location = location + path;
            }
            let language = (_c = (0, url_1.getWindow)()) === null || _c === void 0 ? void 0 : _c.navigator.language;
            let ua = (_d = (0, url_1.getWindow)()) === null || _d === void 0 ? void 0 : _d.navigator.userAgent;
            let platform = this.reportPlatform;
            let reportItem = {
                uuid: this.currentUUID,
                version: this.currentVersion,
                content: content,
                action: action,
                side: this.currentSide,
                timestamp: new Date().getTime(),
                url: location,
                lang: language,
                type: type,
                platform: platform,
                "user-agent": ua
            };
            yield this.markRecordItem(reportItem);
            yield this.sendRecord(reportItem);
        });
    }
    sendCachedRecords() {
        return __awaiter(this, void 0, void 0, function*() {
            return new Promise((resolve, reject)=>__awaiter(this, void 0, void 0, function*() {
                    let sendList = this.recordList.map((record)=>this.sendRecord(record));
                    (0, log_1.logDebug)('[REPORT] submit & clean recorded caches begin @', new Date().toUTCString());
                    Promise.allSettled(sendList).then((results)=>{
                        (0, log_1.logDebug)('[REPORT] submit & clean recorded caches ends @', new Date().toUTCString());
                        let keepIndex = [];
                        results.forEach((result, index)=>{
                            if (result.status == "rejected") {
                                keepIndex.push(index);
                            }
                        });
                        this.recordList = this.recordList.filter((_, index)=>!keepIndex.includes(index));
                        this.storage.setItem(this.recordCacheKey, this.recordList).then(function(value) {
                            resolve();
                        }).catch(function(err) {
                            reject(err);
                        });
                    });
                }));
        });
    }
    markRecordItem(item) {
        return __awaiter(this, void 0, void 0, function*() {
            this.recordList.push(item);
            if (this.recordList.length > MAX_LIMIT_REPORTCOUNT) {
                let offset = this.recordList.length - MAX_LIMIT_REPORTCOUNT;
                this.recordList.splice(0, offset);
            }
            return new Promise((resolve, reject)=>{
                this.storage.setItem(this.recordCacheKey, this.recordList).then(function(value) {
                    resolve(item);
                }).catch(function(err) {
                    reject(err);
                });
            });
        });
    }
    markRecord(content, type, action, side) {
        return __awaiter(this, void 0, void 0, function*() {
            var _a, _b, _c, _d;
            let path = (_a = (0, url_1.getWindow)()) === null || _a === void 0 ? void 0 : _a.location.pathname;
            let location = (_b = (0, url_1.getWindow)()) === null || _b === void 0 ? void 0 : _b.location.origin;
            if (path && location) {
                location = location + path;
            }
            let language = (_c = (0, url_1.getWindow)()) === null || _c === void 0 ? void 0 : _c.navigator.language;
            let platform = this.reportPlatform;
            let ua = (_d = (0, url_1.getWindow)()) === null || _d === void 0 ? void 0 : _d.navigator.userAgent;
            let reportItem = {
                uuid: this.currentUUID,
                version: this.currentVersion,
                content: content,
                action: action,
                side: side,
                timestamp: new Date().getTime(),
                url: location,
                lang: language,
                type: type,
                platform: platform,
                "user-agent": ua
            };
            return yield this.markRecordItem(reportItem);
        });
    }
}
exports.OKXReporter = OKXReporter;
}}),
"[project]/node_modules/@okxconnect/core/package.json (json)": ((__turbopack_context__) => {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_export_value__(JSON.parse("{\"name\":\"@okxconnect/core\",\"version\":\"1.6.1\",\"description\":\"OKX Connect core\",\"main\":\"./src/index.js\",\"keywords\":[\"OKXConnect\",\"OKX Connect\"],\"scripts\":{\"build\":\"npx tsc\",\"local\":\"yarn install && npx tsc\",\"remove\":\"rm -rf ./src  && rm -rf ./node_modules\"},\"author\":\"OKX Wallet\",\"license\":\"MIT\",\"dependencies\":{\"@stablelib/ed25519\":\"^1.0.2\",\"@stablelib/random\":\"^1.0.1\",\"@stablelib/sha256\":\"1.0.1\",\"core-js\":\"2.6.12\",\"cross-fetch\":\"^4.0.0\",\"crypto-js\":\"^4.2.0\",\"eventemitter3\":\"^5.0.1\",\"isutf8\":\"^4.0.0\",\"localforage\":\"^1.10.0\",\"multiformats\":\"9.4.2\",\"process\":\"^0.11.10\",\"tweetnacl\":\"^1.0.3\",\"tweetnacl-util\":\"^0.15.1\",\"ua-parser-js\":\"^1.0.35\",\"uint8arrays\":\"3.1.0\"},\"devDependencies\":{\"@types/crypto-js\":\"^4.2.2\",\"@types/ua-parser-js\":\"^0.7.36\",\"assert\":\"^2.1.0\",\"eslint\":\"^9.7.0\",\"events\":\"^3.3.0\",\"jest\":\"^29.7.0\",\"ts-loader\":\"^9.5.1\",\"typescript\":\"^5.5.2\"}}"));}}),
"[project]/node_modules/@okxconnect/core/src/utils/log.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getDefaultReporter = getDefaultReporter;
exports.logDebug = logDebug;
exports.logError = logError;
exports.logWarning = logWarning;
exports.reportEvent = reportEvent;
exports.reportLog = reportLog;
const debug = false;
const forceReport = false;
const report_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/report.js [app-ssr] (ecmascript)");
const defaultReporter = new report_1.OKXReporter();
function getDefaultReporter() {
    return defaultReporter;
}
const packageJson = __turbopack_require__("[project]/node_modules/@okxconnect/core/package.json (json)");
const version = packageJson.version;
function logDebug(...args) {
    if (typeof console != 'undefined') {
        try {
            if (debug || (window === null || window === void 0 ? void 0 : window.okxLogDebug)) {
                console.log(`[OKX_CONNECT_SDK] ${version} `, ...args);
            }
        } catch (_a) {}
    }
}
function logError(...args) {
    if (typeof console != 'undefined') {
        try {
            if (debug || (window === null || window === void 0 ? void 0 : window.okxLogDebug)) {
                console.error(`[OKX_CONNECT_SDK] ${version} `, ...args);
            }
            if ("TURBOPACK compile-time truthy", 1) {
                let content = '';
                content += [
                    ...args
                ].reduce((result, item)=>{
                    if (typeof item == 'string') {
                        result += ',' + item;
                    } else if (typeof item == 'object') {
                        result += JSON.stringify(item);
                    }
                });
                defaultReporter.sendRecordContent(content, report_1.OKXReportType.LOG, '');
            }
        } catch (_a) {}
    }
}
function logWarning(...args) {
    if (typeof console != 'undefined') {
        try {
            if (debug || (window === null || window === void 0 ? void 0 : window.okxLogDebug)) {
                console.warn(`[OKX_CONNECT_SDK] ${version} `, ...args);
            }
        } catch (_a) {}
    }
}
function reportEvent(type, action, content) {
    return __awaiter(this, void 0, void 0, function*() {
        yield defaultReporter.sendRecordContent(content, type, action);
    });
}
function reportLog(content_1) {
    return __awaiter(this, arguments, void 0, function*(content, action = 'default') {
    // await defaultReporter.sendRecordContent(content, OKXReportType.LOG, action)
    });
}
}}),
"[project]/node_modules/@okxconnect/core/src/utils/safejson.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.safeJsonParse = safeJsonParse;
exports.safeJsonStringify = safeJsonStringify;
const log_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/log.js [app-ssr] (ecmascript)");
const JSONStringify = (data)=>JSON.stringify(data, (_, value)=>typeof value === "bigint" ? value.toString() + "n" : value);
/*
  Function to parse JSON.
  If JSON has values in our custom format BigInt (strings with "n" character at the end), we just parse them to BigInt values.
  If JSON has big number values, but not in our custom format, we copy it, and in a copy we convert those values to our custom format,
  then parse them to BigInt values.
  Other values (not big numbers and not our custom format BigInt values) are not affected and parsed as native JSON.parse() would parse them.
*/ const JSONParse = (json)=>{
    /*
      Big numbers are found and marked using Regex with this condition:
      Number's length is bigger than 16 || Number's length is 16 and any numerical digit of the number is greater than that of the Number.MAX_SAFE_INTEGER
      Additionally, it skips values that are strings (between double quotes).
      */ // prettier-ignore
    // eslint-disable-next-line no-useless-escape
    const numbersBiggerThanMaxInt = /:(\b\d{17,}|\b(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))(?=[,\}\]]|$)/g;
    const serializedData = json.replace(numbersBiggerThanMaxInt, (match, group)=>`:"${group}n"`);
    try {
        return JSON.parse(serializedData, (_, value)=>{
            const isCustomFormatBigInt = typeof value === "string" && value.match(/^\d+n$/);
            if (isCustomFormatBigInt) return BigInt(value.substring(0, value.length - 1));
            return value;
        });
    } catch (e) {
        return JSON.parse(json);
    }
};
function safeJsonParse(value) {
    if (typeof value !== "string") {
        (0, log_1.logDebug)(value);
        throw new Error(`Cannot safe json parse value of type ${typeof value}`);
    }
    try {
        return JSONParse(value);
    } catch (e) {
        // eslint-disable-next-line no-console
        console.error("safeJsonParse error:", e);
        return value;
    }
}
function safeJsonStringify(value) {
    return typeof value === "string" ? value : JSONStringify(value) || "";
}
}}),
"[project]/node_modules/@okxconnect/core/src/utils/stringUtils.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.okxfromString = okxfromString;
exports.okxtoString = okxtoString;
exports.alloc = alloc;
exports.allocUnsafe = allocUnsafe;
const basics_1 = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/basics.js [app-ssr] (ecmascript)");
const log_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/log.js [app-ssr] (ecmascript)");
function okxfromString(string, encoding = 'utf8') {
    const base = BASES[encoding];
    (0, log_1.logDebug)("okxfromstring ====> ");
    if (!base) {
        throw new Error(`Unsupported encoding "${encoding}"`);
    }
    return base.decoder.decode(`${base.prefix}${string}`);
}
function okxtoString(array, encoding = 'utf8') {
    const base = BASES[encoding];
    (0, log_1.logDebug)("okxtoString ====> ");
    if (!base) {
        throw new Error(`Unsupported encoding "${encoding}"`);
    }
    return base.encoder.encode(array).substring(1);
}
function alloc(size = 0) {
    return new Uint8Array(size);
}
function allocUnsafe(size = 0) {
    return new Uint8Array(size);
}
function createCodec(name, prefix, encode, decode) {
    return {
        name,
        prefix,
        encoder: {
            name,
            prefix,
            encode
        },
        decoder: {
            decode
        }
    };
}
const string = createCodec('utf8', 'u', (buf)=>{
    const decoder = new TextDecoder('utf8');
    return 'u' + decoder.decode(buf);
}, (str)=>{
    const encoder = new TextEncoder();
    return encoder.encode(str.substring(1));
});
const ascii = createCodec('ascii', 'a', (buf)=>{
    let result = 'a';
    for(let i = 0; i < buf.length; i++){
        let bufNum = buf[i];
        if (bufNum && String.fromCharCode(bufNum)) {
            result += String.fromCharCode(bufNum);
        }
    }
    return result;
}, (str)=>{
    str = str.substring(1);
    const buf = allocUnsafe(str.length);
    for(let i = 0; i < str.length; i++){
        buf[i] = str.charCodeAt(i);
    }
    return buf;
});
const BASES = Object.assign({
    utf8: string,
    'utf-8': string,
    hex: basics_1.bases.base16,
    latin1: ascii,
    ascii: ascii,
    binary: ascii
}, basics_1.bases);
}}),
"[project]/node_modules/@okxconnect/core/src/utils/utils.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isValidObject = exports.RANDOM_LENGTH = exports.isBrowser = exports.resolveLocalStorage = exports.hasLocalStorage = exports.hasBuiltInWebSocket = exports.resolveWebSocketImplementation = void 0;
exports.hexToByteArray = hexToByteArray;
exports.toHexString = toHexString;
exports.concatUint8Arrays = concatUint8Arrays;
exports.splitToUint8Arrays = splitToUint8Arrays;
exports.base64encode = base64encode;
exports.base64decode = base64decode;
exports.checkWSUrl = checkWSUrl;
exports.hashKey = hashKey;
exports.generateRandomBytes32 = generateRandomBytes32;
exports.generateTopic = generateTopic;
exports.isIos = isIos;
exports.getLastSixMd5Hash = getLastSixMd5Hash;
exports.toSafeBase64FromBase64 = toSafeBase64FromBase64;
exports.useShortLink = useShortLink;
const tweetnacl_1 = __importDefault(__turbopack_require__("[project]/node_modules/tweetnacl/nacl-fast.js [app-ssr] (ecmascript)"));
const tweetnacl_util_1 = __importDefault(__turbopack_require__("[project]/node_modules/tweetnacl-util/nacl-util.js [app-ssr] (ecmascript)"));
const to_string_1 = __turbopack_require__("[project]/node_modules/uint8arrays/cjs/src/to-string.js [app-ssr] (ecmascript)");
const sha256_1 = __turbopack_require__("[project]/node_modules/@stablelib/sha256/lib/sha256.js [app-ssr] (ecmascript)");
const safejson_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/safejson.js [app-ssr] (ecmascript)");
const log_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/log.js [app-ssr] (ecmascript)");
const stringUtils_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/stringUtils.js [app-ssr] (ecmascript)");
const crypto_js_1 = __importDefault(__turbopack_require__("[project]/node_modules/crypto-js/index.js [app-ssr] (ecmascript)"));
const BASE16 = "base16";
function hexToByteArray(hexString) {
    if (hexString.length % 2 !== 0) {
        throw new Error(`Cannot convert ${hexString} to bytesArray`);
    }
    const result = new Uint8Array(hexString.length / 2);
    for(let i = 0; i < hexString.length; i += 2){
        result[i / 2] = parseInt(hexString.slice(i, i + 2), 16);
    }
    return result;
}
function toHexString(byteArray) {
    let hexString = '';
    byteArray.forEach((byte)=>{
        hexString += ('0' + (byte & 0xff).toString(16)).slice(-2);
    });
    return hexString;
}
function concatUint8Arrays(buffer1, buffer2) {
    const mergedArray = new Uint8Array(buffer1.length + buffer2.length);
    mergedArray.set(buffer1);
    mergedArray.set(buffer2, buffer1.length);
    return mergedArray;
}
function splitToUint8Arrays(array, index) {
    if (index >= array.length) {
        throw new Error('Index is out of buffer');
    }
    const subArray1 = array.slice(0, index);
    const subArray2 = array.slice(index);
    return [
        subArray1,
        subArray2
    ];
}
function encodeUint8Array(value, urlSafe) {
    const encoded = tweetnacl_util_1.default.encodeBase64(value);
    if (!urlSafe) {
        return encoded;
    }
    return encodeURIComponent(encoded);
}
function decodeToUint8Array(value, urlSafe) {
    if (urlSafe) {
        value = decodeURIComponent(value);
    }
    return tweetnacl_util_1.default.decodeBase64(value);
}
function base64encode(value, urlSafe) {
    let uint8Array;
    if (value instanceof Uint8Array) {
        uint8Array = value;
    } else {
        if (typeof value !== 'string') {
            value = (0, safejson_1.safeJsonStringify)(value);
        }
        uint8Array = tweetnacl_util_1.default.decodeUTF8(value);
    }
    return encodeUint8Array(uint8Array, urlSafe);
}
function base64decode(value, urlSafe) {
    const decodedUint8Array = decodeToUint8Array(value, urlSafe);
    return {
        toString () {
            return tweetnacl_util_1.default.encodeUTF8(decodedUint8Array);
        },
        toObject () {
            try {
                return (0, safejson_1.safeJsonParse)(tweetnacl_util_1.default.encodeUTF8(decodedUint8Array));
            } catch (e) {
                return null;
            }
        },
        toUint8Array () {
            return decodedUint8Array;
        }
    };
}
function checkWSUrl(url) {
    const match = url.match(new RegExp(/^\w+:/, "gi"));
    if (!match || !match.length) {
        return false;
    }
    let scheme = match[0];
    if (scheme === undefined) {
        return false;
    }
    return new RegExp("^wss?:").test(scheme);
}
const resolveWebSocketImplementation = ()=>{
    if (typeof WebSocket !== "undefined") {
        return WebSocket;
    } else if (typeof global !== "undefined" && typeof global.WebSocket !== "undefined") {
        return global.WebSocket;
    } else if (typeof window !== "undefined" && typeof window.WebSocket !== "undefined") {
        return window.WebSocket;
    } else if (typeof self !== "undefined" && typeof self.WebSocket !== "undefined") {
        return self.WebSocket;
    }
    return WebSocket;
//
// return require("ws");
};
exports.resolveWebSocketImplementation = resolveWebSocketImplementation;
const hasBuiltInWebSocket = ()=>typeof WebSocket !== "undefined" || typeof global !== "undefined" && typeof global.WebSocket !== "undefined" || typeof window !== "undefined" && typeof window.WebSocket !== "undefined" || typeof self !== "undefined" && typeof self.WebSocket !== "undefined";
exports.hasBuiltInWebSocket = hasBuiltInWebSocket;
const hasLocalStorage = ()=>typeof global !== "undefined" && typeof global.localStorage !== "undefined" || typeof window !== "undefined" && typeof window.localStorage !== "undefined";
exports.hasLocalStorage = hasLocalStorage;
const resolveLocalStorage = ()=>{
    if (typeof global !== "undefined" && typeof global.localStorage !== "undefined") {
        return global.localStorage;
    } else if (typeof window !== "undefined" && typeof window.localStorage !== "undefined") {
        return window.localStorage;
    }
    return localStorage;
};
exports.resolveLocalStorage = resolveLocalStorage;
const isBrowser = ()=>typeof window !== "undefined";
exports.isBrowser = isBrowser;
exports.RANDOM_LENGTH = 32;
function hashKey(key, encode = BASE16) {
    (0, log_1.logDebug)(`hash key called ${key}`);
    const result = (0, sha256_1.hash)((0, stringUtils_1.okxfromString)(key, encode));
    return (0, to_string_1.toString)(result, encode);
}
function generateRandomBytes32() {
    return tweetnacl_1.default.randomBytes(exports.RANDOM_LENGTH);
}
function generateTopic() {
    let randomBytes32 = generateRandomBytes32();
    (0, log_1.logDebug)(`generate topic called ${randomBytes32}`);
    return hashKey((0, to_string_1.toString)(randomBytes32, BASE16));
}
const isValidObject = (obj)=>Object.getPrototypeOf(obj) === Object.prototype && Object.keys(obj).length;
exports.isValidObject = isValidObject;
function isIos() {
    const userAgent = navigator.userAgent;
    const maxTouchPoints = navigator.maxTouchPoints || 0;
    //  iPhoneiPod  iPad
    const isIOSDevice = /iPad|iPhone|iPod/.test(userAgent) && !window.MSStream;
    //  iPadOS 13 
    const isIPadOS = userAgent.includes('Mac') && maxTouchPoints > 1;
    (0, log_1.logDebug)(`utils isIos >>>isIOSDevice: ${isIOSDevice}    >> isIPadOS: ${isIPadOS}`);
    //  iOS  iPadOS  true
    return isIOSDevice || isIPadOS;
}
function getLastSixMd5Hash(input) {
    //  MD5 
    const hash = crypto_js_1.default.MD5(input).toString();
    // 
    return hash.slice(-6);
}
function toSafeBase64FromBase64(base64) {
    return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function useShortLink() {
    return !!window.useShortLink;
}
}}),
"[project]/node_modules/@okxconnect/core/src/connect/storage.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function() {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o) {
            var ar = [];
            for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
            for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
    };
}();
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Storage = void 0;
const storageconstants_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/connect/storageconstants.js [app-ssr] (ecmascript)");
const tweetnacl_1 = __importDefault(__turbopack_require__("[project]/node_modules/tweetnacl/nacl-fast.js [app-ssr] (ecmascript)"));
const utils_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/utils.js [app-ssr] (ecmascript)");
const utils_2 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/index.js [app-ssr] (ecmascript)");
const log = __importStar(__turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/log.js [app-ssr] (ecmascript)"));
const utils_3 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/index.js [app-ssr] (ecmascript)");
const crypto_js_1 = __turbopack_require__("[project]/node_modules/crypto-js/index.js [app-ssr] (ecmascript)");
class Storage {
    constructor(subKey, beforeKey = undefined){
        const localStorage1 = (0, utils_1.resolveLocalStorage)();
        // 0. check and upgrade beforeKey
        log.logDebug('------ update before cache ------');
        if (beforeKey) {
            this.checkAndUpgradeCache(beforeKey, subKey);
        }
        // 1. load data from local storage
        this.storeKey = '';
        this.cipherIV = '';
        this.subKey = subKey;
        log.logDebug('--------get current local storage --------');
        log.logDebug(localStorage1);
        const cacheStr = localStorage1.getItem(Storage.cacheKey + subKey);
        if (typeof cacheStr === "undefined" || cacheStr === null) {
            log.logDebug("with no cache");
            this.cache = {};
            return;
        }
        log.logDebug(cacheStr);
        if ((cacheStr === null || cacheStr === void 0 ? void 0 : cacheStr.length) > 0) {
            var cacheObj = (0, utils_2.safeJsonParse)(cacheStr);
            this.cache = cacheObj;
        }
        log.logDebug(`get cache obj: ${this.cache}`);
        if (typeof this.cache === 'undefined' || this.cache == null) {
            this.cache = {};
        }
    }
    checkAndUpgradeCache(fromCacheKey, toCacheKey) {
        if (fromCacheKey && fromCacheKey.length > 0 && toCacheKey && toCacheKey.length > 0) {
            // 1. get all infos from from-cache-key
            log.logDebug('--------get current local storage --------');
            log.logDebug(localStorage);
            const cacheStr = localStorage.getItem(Storage.cacheKey + fromCacheKey);
            if (typeof cacheStr === "undefined" || cacheStr === null) {
                log.logDebug("no pre cache content");
                return;
            }
            log.logDebug(cacheStr);
            if ((cacheStr === null || cacheStr === void 0 ? void 0 : cacheStr.length) > 0) {
                // 2. save to to-cache-key
                log.logDebug("write in cache content: ", fromCacheKey, '->', toCacheKey);
                localStorage.setItem(Storage.cacheKey + toCacheKey, cacheStr);
                // 3. clean from item
                log.logDebug("clean in cache content: ", fromCacheKey);
                localStorage.removeItem(Storage.cacheKey + fromCacheKey);
            }
        } else {
            log.logDebug('no pre cache key:', fromCacheKey);
        }
    }
    saveContent(content, key, id = '-') {
        let item = {
            id: id,
            timestamp: Date.now().toString(),
            content: content
        };
        this.saveItem(item, key);
    }
    saveItem(item, key) {
        let localKey = Storage.cacheKey + this.subKey;
        const localStorage1 = (0, utils_1.resolveLocalStorage)();
        log.logDebug(this.cache);
        log.logDebug(`get cache obj: ${this.cache}, ${key}, ${item}`);
        this.cache[key] = item;
        let totalCacheStr = (0, utils_2.safeJsonStringify)(this.cache);
        log.logDebug(`STORAGE: ${key} @ ${this.cache}`);
        localStorage1.setItem(localKey, totalCacheStr);
    }
    getItem(key) {
        log.logDebug(`STORAGE >> getItem: ${key} @ ${this.cache}`);
        return this.cache[key];
    }
    getCachedPBKDF2InfoKey() {
        var _a, _b, _c, _d;
        const pwLen = 32;
        const saltLen = 24;
        if (this.storeKey.length > 0 && ((_a = this.cipherIV) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            return {
                pw: this.storeKey,
                iv: this.cipherIV
            };
        }
        let salt = (_b = this.getItem(storageconstants_1.OKXCONNECTOR_STORAGER_CRYPTO_SALT)) === null || _b === void 0 ? void 0 : _b.content;
        if (!salt) {
            salt = (0, utils_1.toHexString)(tweetnacl_1.default.randomBytes(saltLen));
            this.saveContent(salt, storageconstants_1.OKXCONNECTOR_STORAGER_CRYPTO_SALT);
        }
        let pw = (_c = this.getItem(storageconstants_1.OKXCONNECTOR_STORAGE_CRYPTO_PASSWORD)) === null || _c === void 0 ? void 0 : _c.content;
        if (!pw) {
            pw = (0, utils_1.toHexString)(tweetnacl_1.default.randomBytes(pwLen));
            this.saveContent(pw, storageconstants_1.OKXCONNECTOR_STORAGE_CRYPTO_PASSWORD);
        }
        let cipherIV = (_d = this.getItem(storageconstants_1.OKXCONNECTOR_STORAGE_CRYPTO_CIPHERIV)) === null || _d === void 0 ? void 0 : _d.content;
        if (!cipherIV) {
            // let ivBuffer = Buffer.from(nacl.randomBytes(16))
            let ivBuffer = tweetnacl_1.default.randomBytes(16);
            cipherIV = (0, utils_1.toHexString)(ivBuffer);
            this.saveContent(cipherIV, storageconstants_1.OKXCONNECTOR_STORAGE_CRYPTO_CIPHERIV);
        }
        this.cipherIV = cipherIV;
        this.storeKey = (0, crypto_js_1.PBKDF2)(pw, salt, {
            iterations: 10
        }).toString();
        return {
            pw: this.storeKey,
            iv: this.cipherIV
        };
    }
    encryptStoreMsg(msg, key) {
        (0, utils_3.logDebug)(`encryptStoreMsg  encryptStoreMsg start ${Date.now()}`);
        let storeInfo = this.getCachedPBKDF2InfoKey();
        (0, utils_3.logDebug)(`encryptStoreMsg  encryptStoreMsg mid ${Date.now()}`);
        var result = crypto_js_1.AES.encrypt(msg, storeInfo.pw).toString();
        this.saveContent(result, key);
        (0, utils_3.logDebug)(`encryptStoreMsg  encryptStoreMsg end ${Date.now()}`);
    }
    getAndDecrypt(key) {
        (0, utils_3.logDebug)(`encryptStoreMsg  getAndDecrypt start ${Date.now()}`);
        let item = this.getItem(key);
        if (item && item.content) {
            let storeInfo = this.getCachedPBKDF2InfoKey();
            (0, utils_3.logDebug)(`encryptStoreMsg  getAndDecrypt mid ${Date.now()}`);
            let result = crypto_js_1.AES.decrypt(item.content, storeInfo.pw).toString(crypto_js_1.enc.Utf8);
            (0, utils_3.logDebug)(`encryptStoreMsg  getAndDecrypt end ${Date.now()}`);
            return result;
        }
        return null;
    }
    clearCache(key = undefined) {
        if (key === undefined) {
            // clean all
            this.cache = {};
            let localKey = Storage.cacheKey + this.subKey;
            localStorage.setItem(localKey, '');
        } else {
            let localKey = Storage.cacheKey + this.subKey;
            const localStorage1 = (0, utils_1.resolveLocalStorage)();
            log.logDebug(this.cache);
            this.cache[key] = null;
            let totalCacheStr = (0, utils_2.safeJsonStringify)(this.cache);
            log.logDebug(`STORAGE: clean key ${key} @ ${this.cache}`);
            localStorage1.setItem(localKey, totalCacheStr);
        }
    }
}
exports.Storage = Storage;
Storage.cacheKey = 'OKXStorageKey';
}}),
"[project]/node_modules/@okxconnect/core/src/connect/connect.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function() {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o) {
            var ar = [];
            for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
            for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
    };
}();
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OKXWalletConnector = void 0;
const constants_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/connect/constants.js [app-ssr] (ecmascript)");
const storageconstants_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/connect/storageconstants.js [app-ssr] (ecmascript)");
const storage_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/connect/storage.js [app-ssr] (ecmascript)");
const utils_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/index.js [app-ssr] (ecmascript)");
const utils_2 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/utils.js [app-ssr] (ecmascript)");
const eventemitter3_1 = __turbopack_require__("[project]/node_modules/eventemitter3/index.js [app-ssr] (ecmascript)");
const log = __importStar(__turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/log.js [app-ssr] (ecmascript)"));
const protocol_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/protocol/index.js [app-ssr] (ecmascript)");
const report_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/report.js [app-ssr] (ecmascript)");
const WS = (0, utils_2.resolveWebSocketImplementation)();
class OKXWalletConnector {
    constructor(url){
        this.events = new eventemitter3_1.EventEmitter();
        this.state = constants_1.ConnectorState.InitState;
        this.selectedUrlIndex = 0;
        // reconnect
        this.retryCount = 0;
        // default timeout limit: 8 sec
        this.timeOutLimit = 8000;
        if (!(0, utils_2.checkWSUrl)(url)) {
            throw new Error(`CONNECTOR: invalid url ${url}`);
        }
        this.url = url;
        this.heartbeatTimer = null;
        this.connectionTimeoutTimer = null;
        this.connectURLStorage = new storage_1.Storage(storageconstants_1.OKXCONNECTOR_CACHE_KEY + storageconstants_1.OKXCONNECTOR_CACHE_KEY);
    }
    get connecting() {
        return this.state == constants_1.ConnectorState.Connecting;
    }
    // ------------------------------------------------------
    onPayload(e) {
        if (typeof e.data === "undefined") return;
        log.logDebug('get received data');
        log.logDebug(e);
        if (typeof e.data === "string") {
            let rsp = e.data;
            if (rsp === "pong") {
                log.logDebug(`CONNECT: receive pong ${Date.now().toString()}`);
                return;
            }
        }
        this.events.emit("payload", e.data);
    }
    onClose(event) {
        var _a;
        log.logDebug('socket get closed: ', (_a = this.socket) === null || _a === void 0 ? void 0 : _a.url, event.code);
        this.socket = undefined;
        this.events.emit("close", event);
    }
    onError(id, e) {
        const payload = {
            id: id,
            msg: e.toString()
        };
        this.events.emit("payload", payload);
    }
    onopen(socket) {
        socket.onmessage = (event)=>this.onPayload(event);
        socket.onclose = (event)=>this.onClose(event);
        this.socket = socket;
        this.state = constants_1.ConnectorState.Connected;
        this.events.emit("open");
    }
    // ------------------------------------------------------
    emitError(errorEvent) {
        this.events.emit("fail", errorEvent);
    }
    // ------------------------------------------------------
    heartbeat() {
        return __awaiter(this, void 0, void 0, function*() {
            if (this.heartbeatTimer) {
                clearTimeout(this.heartbeatTimer);
            }
            if (this.state != constants_1.ConnectorState.Connected && this.state != constants_1.ConnectorState.OnError) {
                log.logDebug('heart beat close');
                return;
            }
            if (!this.socket) {
                log.logDebug('socket not exist');
                if (this.state == constants_1.ConnectorState.Connected || this.state == constants_1.ConnectorState.OnError) {
                    log.logDebug('socket reconnect by heartbeat');
                    try {
                        yield this.tryRegistOpen();
                    } catch (e) {
                        log.logError('regist open failed');
                        this.heartbeatTimer = setTimeout(this.heartbeat.bind(this), 5000);
                    }
                }
                return;
            }
            if (this.socket.readyState !== WebSocket.OPEN) {
                log.logDebug('socket not ready');
                if (this.state == constants_1.ConnectorState.Connected || this.state == constants_1.ConnectorState.OnError) {
                    log.logDebug('socket reconnect by heartbeat with state', this.state, this.socket.readyState);
                    try {
                        yield this.tryRegistOpen();
                    } catch (e) {
                        log.logError('regist open failed');
                        this.heartbeatTimer = setTimeout(this.heartbeat.bind(this), 5000);
                    }
                }
                return;
            }
            log.logDebug(`send ping heart beat: ${Date.now().toString()}, ${this.socket}`);
            this.socket.send("ping");
            this.heartbeatTimer = setTimeout(this.heartbeat.bind(this), 5000);
        });
    }
    registOpen(url = this.url, inRetry = false) {
        if (!(0, utils_2.checkWSUrl)(url)) {
            throw new Error(`CONNECTOR: invalid url ${url}`);
        }
        this.url = url;
        if (!inRetry) {
            log.logDebug('Connection connect:', this.url, new Date().toUTCString());
        }
        this.state = constants_1.ConnectorState.Connecting;
        const origin = new URLSearchParams(url).get("origin");
        return new Promise((resolve, reject)=>{
            const socket = new WS(url, []);
            log.logDebug('Connection connect Begin:', this.url, new Date().toUTCString());
            this.startTimeOutTimer(socket);
            if ((0, utils_2.hasBuiltInWebSocket)()) {
                log.logDebug('Add socket error handler');
                socket.onerror = ()=>{
                    reject(new Error('socket error'));
                    socket.close();
                };
            } else {
                log.logDebug('Add socket error handler');
                socket.on("error", ()=>{
                    reject(new Error('socket error'));
                    socket.close();
                });
            }
            socket.onopen = ()=>{
                log.logDebug('socket opened');
                this.resetTimeOutTimer(constants_1.OKXCONNECTOR_WS_URL_PENDING_CLOSE_CODE.FINISHED);
                this.onopen(socket);
                this.heartbeat();
                resolve(socket);
            };
        });
    }
    checkMaxRetry() {
        log.logDebug('current retry count:', this.retryCount, 'of', constants_1.OKXCONNECTOR_WS_URL_LIST.length);
        return this.retryCount > constants_1.OKXCONNECTOR_WS_URL_LIST.length * 3;
    }
    connectionTryNext() {
        return __awaiter(this, void 0, void 0, function*() {
            if (!this.checkMaxRetry()) {
                //TODO: mark descent
                this.retryCount += 1;
                let nextUrl = this.getNextSelectUrl();
                log.logDebug('Connection retry:', nextUrl, new Date().toUTCString());
                return this.registOpen(nextUrl, true);
            } else {
                log.logDebug('Max Connection retry ', this.retryCount, new Date().toUTCString());
            }
        });
    }
    startTimeOutTimer(socket) {
        if (this.connectionTimeoutTimer) {
            this.resetTimeOutTimer(constants_1.OKXCONNECTOR_WS_URL_PENDING_CLOSE_CODE.CANCELED);
        }
        this.pendingSocket = socket;
        this.connectionTimeoutTimer = setTimeout(()=>{
            if (this.pendingSocket) {
                this.resetTimeOutTimer(constants_1.OKXCONNECTOR_WS_URL_PENDING_CLOSE_CODE.TIME_OUT);
            }
        }, this.timeOutLimit);
    }
    resetTimeOutTimer(code) {
        var _a;
        // 1. cancel connecting pending sockets
        if (code == constants_1.OKXCONNECTOR_WS_URL_PENDING_CLOSE_CODE.TIME_OUT) {
            // 2. remove timer
            clearTimeout(this.connectionTimeoutTimer);
            (_a = this.pendingSocket) === null || _a === void 0 ? void 0 : _a.close();
            this.pendingSocket = undefined;
            log.reportEvent(report_1.OKXReportType.LOG, 'timeout', this.retryCount.toString());
            throw new Error('socket timeout');
        } else {
            this.pendingSocket = undefined;
            // 2. remove timer
            clearTimeout(this.connectionTimeoutTimer);
        }
    }
    cacheSuccessUrlSelect() {
        this.connectURLStorage.saveContent(this.selectedUrlIndex.toString(), storageconstants_1.OKXCONNECTOR_CACHE_KEY);
    }
    // private getSuccessUrlSelect(): string {
    //     let selectIndex = this.connectURLStorage.getItem(OKXCONNECTOR_CACHE_KEY)?.content
    //     let index = 0
    //     if (selectIndex) {
    //         index = Number(selectIndex)
    //     }
    //     this.selectedUrlIndex = index
    //     return OKXCONNECTOR_WS_URL_LIST[index]
    // }
    getNextSelectUrl() {
        this.selectedUrlIndex += 1;
        this.selectedUrlIndex = this.selectedUrlIndex % constants_1.OKXCONNECTOR_WS_URL_LIST.length;
        return constants_1.OKXCONNECTOR_WS_URL_LIST[this.selectedUrlIndex];
    }
    // ------------------------------------------------------
    onVisibleChanged() {
        return __awaiter(this, void 0, void 0, function*() {
            if (document.visibilityState === 'visible') {
                // check and restore
                log.logDebug(`get changed ${this.state}, ${this.socket}`);
                if (this.state == constants_1.ConnectorState.Connected && typeof this.socket === "undefined") {
                    log.logDebug('CONNECTION need reopen');
                    try {
                        yield this.tryRegistOpen();
                    } catch (e) {
                        log.logError('regist open failed');
                    }
                    return;
                }
            }
        });
    }
    tryRegistOpen() {
        return __awaiter(this, arguments, void 0, function*(url = this.url) {
            if (this.connecting) {
                log.logDebug('tryRegistOpen => connecting state');
                return new Promise((resolve, reject)=>{
                    this.events.once('fail', (e)=>{
                        log.logDebug('tryRegistOpen => connecting fail listener', e);
                        return reject(e);
                    });
                    this.events.once("open", ()=>{
                        if (typeof this.socket == "undefined") {
                            return reject(new Error("Connect lost"));
                        }
                        return resolve(this.socket);
                    });
                });
            }
            log.logDebug('tryRegistOpen => try registOpen until retry limit is hit');
            let inRetry = false;
            while(!this.checkMaxRetry() && !this.socket){
                try {
                    log.logDebug('tryRegistOpen => call registOpen, try count:', this.retryCount, inRetry);
                    yield this.registOpen(url, inRetry);
                } catch (err) {
                    log.logDebug('tryRegistOpen => registOpen failed', err);
                    this.retryCount += 1;
                    url = this.getNextSelectUrl();
                    inRetry = true;
                }
            }
            log.logDebug('tryRegistOpen => exit while loop', this.retryCount, this.socket);
            if (!this.socket && this.checkMaxRetry()) {
                log.logDebug('tryRegistOpen => failed to open a socket', this.retryCount, this.socket);
                this.retryCount = 0;
                this.state = constants_1.ConnectorState.OnError;
                this.emitError(new Error('tryRegistOpen failed'));
                throw new protocol_1.OKXConnectError(protocol_1.OKX_CONNECT_ERROR_CODES.CONNECTION_ERROR, "Failed to connect");
            }
        });
    }
    connect() {
        return __awaiter(this, void 0, void 0, function*() {
            try {
                yield this.tryRegistOpen();
                // listener for reconnect
                document.removeEventListener('visibilitychange', this.onVisibleChanged.bind(this));
                document.addEventListener('visibilitychange', this.onVisibleChanged.bind(this));
            } catch (e) {
                log.logDebug('connect => failed to connect', e);
                throw e;
            }
        });
    }
    disconnect() {
        return __awaiter(this, void 0, void 0, function*() {
            this.state = constants_1.ConnectorState.Disconnected;
            return new Promise((resolve, reject)=>{
                if (typeof this.socket === "undefined") {
                    // reject(new Error("CONNECTION closed"))
                    resolve();
                    return;
                }
                this.socket.onclose = (event)=>{
                    this.onClose(event);
                    resolve();
                };
                this.socket.close();
                if (this.heartbeatTimer) {
                    clearTimeout(this.heartbeatTimer);
                }
            });
        });
    }
    currentStatus() {
        return {
            state: this.state,
            url: this.url
        };
    }
    // event will be jsonstr
    /// @params Promise
    /// @params success/failed callback
    addListener(event, decrypt, success, failed) {
        if (this.listenPayloadHandler) {
            this.events.removeListener("payload", this.listenPayloadHandler);
        }
        this.listenPayloadHandler = (e)=>{
            var _a;
            log.logDebug(`<<< get payload ${e}`);
            let parsedEvent = (0, utils_1.safeJsonParse)(e);
            // parse the data to chose success or failed
            if (parsedEvent.params && parsedEvent.params.data) {
                let rawMsg = (_a = parsedEvent.params.data) === null || _a === void 0 ? void 0 : _a.message;
                if (rawMsg) {
                    try {
                        let msg = decrypt(rawMsg);
                        if (msg === undefined) {
                            log.logDebug(`CONNECT: decrypt undefined`);
                            failed(event, 'Decrypt undefined');
                        } else {
                            success(event, msg);
                        }
                    } catch (e) {
                        log.logDebug(`CONNECT: decrypt failed: ${e}`);
                        failed(event, e.message);
                    }
                }
            }
        };
        this.events.on("payload", this.listenPayloadHandler);
        if (this.failHandler) {
            this.events.removeListener("fail", this.failHandler);
        }
        this.failHandler = (e)=>{
            if (e) {
                log.logDebug(`CONNECT failed: ${e}`);
                failed(event, e.message);
            } else {
                failed(event, "Unkonow error");
            }
        };
        this.events.on("fail", this.failHandler);
    }
    addPackageParse(callback) {
        if (this.payloadHandler) {
            this.events.removeListener("payload", this.payloadHandler);
        }
        this.payloadHandler = (e)=>__awaiter(this, void 0, void 0, function*() {
                // parse the data to chose success or failed
                log.logDebug(`CONNECTION @[${new Date().toUTCString()}] <<<< received e:${e}`);
                let param = (0, utils_1.safeJsonParse)(e);
                yield callback(param);
            });
        this.events.on("payload", this.payloadHandler);
    }
    once(event, listener) {
        this.events.once(event, listener);
    }
    off(event, listener) {
        this.events.off(event, listener);
    }
    removeListener(event, listener) {
        this.events.removeListener(event, listener);
    }
    send(doLogin, payload) {
        return __awaiter(this, void 0, void 0, function*() {
            try {
                if (typeof this.socket === "undefined") {
                    log.logDebug(`>>> send payload undefined ${payload}`);
                    // this.socket = await this.registOpen();
                    yield doLogin();
                }
                log.logDebug(`CONNECTION @[${new Date().toUTCString()}]>>> send payload ${(0, utils_1.safeJsonStringify)(payload)}`);
                if (this.socket) {
                    this.socket.send((0, utils_1.safeJsonStringify)(payload));
                }
            } catch (e) {
                this.onError(payload.id, e);
            }
        });
    }
    getMsgPayloadFromHistory(msg) {
        return __awaiter(this, void 0, void 0, function*() {
            if (typeof msg === "undefined") return;
            let tmpMsg = {
                params: {
                    data: msg
                }
            };
            let jsonstr = (0, utils_1.safeJsonStringify)(msg);
            log.logDebug('get received data from history');
            log.logDebug(jsonstr);
            jsonstr = (0, utils_1.safeJsonStringify)(tmpMsg);
            this.events.emit("payload", jsonstr);
        });
    }
    onOpen(callback) {
        if (this.openHandler) {
            this.events.removeListener("open", this.openHandler);
        }
        this.openHandler = ()=>__awaiter(this, void 0, void 0, function*() {
                log.logDebug(`CONNECTION @[${new Date().toUTCString()}] >>> ws opened: `);
                yield callback();
            });
        this.events.on("open", this.openHandler);
        this.cacheSuccessUrlSelect();
    }
}
exports.OKXWalletConnector = OKXWalletConnector;
}}),
"[project]/node_modules/@okxconnect/core/src/connect/commands.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CONNECT_METHOD_BATCH_FETCHMSG = exports.CONNECT_METHOD_FETCHMSG = exports.CONNECT_METHOD_RECEIVE = exports.CONNECT_METHOD_UNSUB = exports.CONNECT_METHOD_SUB = exports.CONNECT_METHOD_PUBLISH = exports.CONNECT_METHOD_LOGIN = exports.CONNECT_METHOD_PUSH = void 0;
// --------------- ws methods -------------
exports.CONNECT_METHOD_PUSH = "push";
exports.CONNECT_METHOD_LOGIN = "login";
exports.CONNECT_METHOD_PUBLISH = "publish";
exports.CONNECT_METHOD_SUB = "subscribe";
exports.CONNECT_METHOD_UNSUB = "unsubscribe";
exports.CONNECT_METHOD_RECEIVE = "receive";
exports.CONNECT_METHOD_FETCHMSG = "fetchMessages";
exports.CONNECT_METHOD_BATCH_FETCHMSG = "batchFetchMessages";
}}),
"[project]/node_modules/@okxconnect/core/src/connect/jwtconstants.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OKXCONNECTOR_JWT_TTL = exports.OKXCONNECTOR_JWT_WALLET_SIDE = exports.OKXCONNECTOR_JWT_SIDE = void 0;
exports.OKXCONNECTOR_JWT_SIDE = "wallet";
exports.OKXCONNECTOR_JWT_WALLET_SIDE = "dapp";
exports.OKXCONNECTOR_JWT_TTL = 86400000;
}}),
"[project]/node_modules/@okxconnect/core/src/crypto/crypto.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SessionCrypto = void 0;
const tweetnacl_1 = __importDefault(__turbopack_require__("[project]/node_modules/tweetnacl/nacl-fast.js [app-ssr] (ecmascript)"));
const utils_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/utils.js [app-ssr] (ecmascript)");
class SessionCrypto {
    constructor(keyPair = undefined){
        this.nonceLength = 24;
        this.sessionKeyPair = keyPair ? this.createKeypairFromString(keyPair) : this.createKeypair();
    }
    createKeypair() {
        return tweetnacl_1.default.box.keyPair();
    }
    createKeypairFromString(keyPair) {
        return {
            publicKey: (0, utils_1.hexToByteArray)(keyPair.publicKey),
            secretKey: (0, utils_1.hexToByteArray)(keyPair.secretKey)
        };
    }
    createNonce() {
        return tweetnacl_1.default.randomBytes(this.nonceLength);
    }
    get keyPair() {
        return this.sessionKeyPair;
    }
    // dapp :
    // base64(hexnonce+)
    encrypt(message, receiverPublicKey) {
        const encodedMessage = new TextEncoder().encode(message);
        const nonce = this.createNonce();
        const encrypted = tweetnacl_1.default.box(encodedMessage, nonce, (0, utils_1.hexToByteArray)(receiverPublicKey), this.keyPair.secretKey);
        let concatInfo = (0, utils_1.concatUint8Arrays)(nonce, encrypted);
        var hexResult = (0, utils_1.toHexString)(concatInfo);
        var encodedResult = new TextEncoder().encode(hexResult);
        return (0, utils_1.base64encode)(encodedResult, false);
    }
    // 
    // hex
    // base64nonce+)
    encryptWallet(message, receiverPublicKey) {
        const encodedMessage = new TextEncoder().encode(message);
        const nonce = this.createNonce();
        const encrypted = tweetnacl_1.default.box(encodedMessage, nonce, (0, utils_1.hexToByteArray)(receiverPublicKey), this.keyPair.secretKey);
        let concatInfo = (0, utils_1.concatUint8Arrays)(nonce, encrypted);
        return (0, utils_1.base64encode)(concatInfo, false);
    }
    // dapp 
    // base64(split(nonce+))
    decrypt(message, senderPublicKey) {
        let base64Content = (0, utils_1.base64decode)(message, true);
        let messageByteArray = base64Content.toUint8Array();
        const [nonce, internalMessage] = (0, utils_1.splitToUint8Arrays)(messageByteArray, this.nonceLength);
        const decrypted = tweetnacl_1.default.box.open(internalMessage, nonce, (0, utils_1.hexToByteArray)(senderPublicKey), this.keyPair.secretKey);
        if (!decrypted) {
            throw new Error(`Decryption error: \n message: ${message.toString()} \n sender pubkey: ${senderPublicKey.toString()} \n keypair pubkey: ${(0, utils_1.toHexString)(this.keyPair.publicKey)} \n keypair secretkey: ${(0, utils_1.toHexString)(this.keyPair.secretKey)}`);
        }
        return new TextDecoder().decode(decrypted);
    }
    // dapp 
    // base64(hextoByte(split(nonce+)))
    decryptWallet(message, senderPublicKey) {
        let base64Content = (0, utils_1.base64decode)(message, true);
        let messageByteArray = (0, utils_1.hexToByteArray)(base64Content.toString());
        const [nonce, internalMessage] = (0, utils_1.splitToUint8Arrays)(messageByteArray, this.nonceLength);
        const decrypted = tweetnacl_1.default.box.open(internalMessage, nonce, (0, utils_1.hexToByteArray)(senderPublicKey), this.keyPair.secretKey);
        if (!decrypted) {
            throw new Error(`Decryption error: \n message: ${message.toString()} \n sender pubkey: ${senderPublicKey.toString()} \n keypair pubkey: ${(0, utils_1.toHexString)(this.keyPair.publicKey)} \n keypair secretkey: ${(0, utils_1.toHexString)(this.keyPair.secretKey)}`);
        }
        return new TextDecoder().decode(decrypted);
    }
    stringifyKeypair() {
        return {
            publicKey: (0, utils_1.toHexString)(this.keyPair.publicKey),
            secretKey: (0, utils_1.toHexString)(this.keyPair.secretKey)
        };
    }
}
exports.SessionCrypto = SessionCrypto;
}}),
"[project]/node_modules/@okxconnect/core/src/connect/jwt.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function() {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o) {
            var ar = [];
            for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
            for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
    };
}();
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MULTICODEC_ED25519_LENGTH = exports.MULTICODEC_ED25519_HEADER = exports.MULTICODEC_ED25519_BASE = exports.MULTICODEC_ED25519_ENCODING = exports.DID_METHOD = exports.DID_PREFIX = exports.DID_DELIMITER = exports.KEY_PAIR_SEED_LENGTH = exports.DATA_ENCODING = exports.JSON_ENCODING = exports.JWT_ENCODING = exports.JWT_DELIMITER = exports.JWT_IRIDIUM_TYP = exports.JWT_IRIDIUM_ALG = exports.JWTHeaderType = void 0;
exports.generateKeyPair = generateKeyPair;
exports.decodeJSON = decodeJSON;
exports.encodeJSON = encodeJSON;
exports.encodeIss = encodeIss;
exports.decodeIss = decodeIss;
exports.encodeSig = encodeSig;
exports.decodeSig = decodeSig;
exports.encodeData = encodeData;
exports.decodeData = decodeData;
exports.encodeJWT = encodeJWT;
exports.decodeJWT = decodeJWT;
exports.signJWT = signJWT;
exports.verifyJWT = verifyJWT;
const ed25519 = __importStar(__turbopack_require__("[project]/node_modules/@stablelib/ed25519/lib/ed25519.js [app-ssr] (ecmascript)"));
const safejson_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/safejson.js [app-ssr] (ecmascript)");
const utils_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/utils.js [app-ssr] (ecmascript)");
const tweetnacl_1 = __importDefault(__turbopack_require__("[project]/node_modules/tweetnacl/nacl-fast.js [app-ssr] (ecmascript)"));
const log = __importStar(__turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/log.js [app-ssr] (ecmascript)"));
const stringUtils_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/stringUtils.js [app-ssr] (ecmascript)");
exports.JWTHeaderType = "dapp";
exports.JWT_IRIDIUM_ALG = "EdDSA";
exports.JWT_IRIDIUM_TYP = "JWT";
exports.JWT_DELIMITER = ".";
exports.JWT_ENCODING = "base64url";
exports.JSON_ENCODING = "utf8";
exports.DATA_ENCODING = "utf8";
exports.KEY_PAIR_SEED_LENGTH = 32;
exports.DID_DELIMITER = ":";
exports.DID_PREFIX = "did";
exports.DID_METHOD = "key";
exports.MULTICODEC_ED25519_ENCODING = "base58btc";
exports.MULTICODEC_ED25519_BASE = "z";
exports.MULTICODEC_ED25519_HEADER = "K36";
exports.MULTICODEC_ED25519_LENGTH = 32;
function generateKeyPair() {
    // let local_seed = randomBytes(KEY_PAIR_SEED_LENGTH)
    // return ed25519.generateKeyPairFromSeed(local_seed);
    return tweetnacl_1.default.sign.keyPair();
}
function decodeJSON(str) {
    return (0, safejson_1.safeJsonParse)((0, stringUtils_1.okxtoString)((0, stringUtils_1.okxfromString)(str, exports.JWT_ENCODING), exports.JSON_ENCODING));
}
function encodeJSON(val) {
    return (0, stringUtils_1.okxtoString)((0, stringUtils_1.okxfromString)((0, safejson_1.safeJsonStringify)(val), exports.JSON_ENCODING), exports.JWT_ENCODING);
}
function encodeIss(publicKey) {
    log.logDebug(`publicKey: ${(0, utils_1.toHexString)(publicKey)}`);
    var publicKeyStr = (0, stringUtils_1.okxtoString)(publicKey, exports.MULTICODEC_ED25519_ENCODING);
    return [
        exports.DID_PREFIX,
        exports.DID_METHOD,
        publicKeyStr
    ].join(exports.DID_DELIMITER);
}
function decodeIss(issuer) {
    const [prefix, method, multicodec] = issuer.split(exports.DID_DELIMITER);
    if (prefix !== exports.DID_PREFIX || method !== exports.DID_METHOD) {
        throw new Error(`Issuer must be a DID with method "key"`);
    }
    if (multicodec === undefined) {
        throw new Error('multicodec is undefined');
    }
    const publicKey = (0, stringUtils_1.okxfromString)(multicodec, exports.MULTICODEC_ED25519_ENCODING);
    if (publicKey === undefined || publicKey.length !== exports.MULTICODEC_ED25519_LENGTH) {
        throw new Error(`Issuer must be a public key with length 32 bytes`);
    }
    return publicKey;
}
// ---------- Signature ----------------------------------------------- //
function encodeSig(bytes) {
    return (0, stringUtils_1.okxtoString)(bytes, exports.JWT_ENCODING);
}
function decodeSig(encoded) {
    return (0, stringUtils_1.okxfromString)(encoded, exports.JWT_ENCODING);
}
// ---------- Data ----------------------------------------------- //
function encodeData(params) {
    return (0, stringUtils_1.okxfromString)([
        encodeJSON(params.header),
        encodeJSON(params.payload)
    ].join(exports.JWT_DELIMITER), exports.DATA_ENCODING);
}
function decodeData(data) {
    var _a, _b;
    const params = (0, stringUtils_1.okxtoString)(data, exports.DATA_ENCODING).split(exports.JWT_DELIMITER);
    const header = decodeJSON((_a = params[0]) !== null && _a !== void 0 ? _a : '{}');
    const payload = decodeJSON((_b = params[1]) !== null && _b !== void 0 ? _b : '{}');
    return {
        header,
        payload
    };
}
// ---------- JWT ----------------------------------------------- //
function encodeJWT(params) {
    return [
        encodeJSON(params.header),
        encodeJSON(params.payload),
        encodeSig(params.signature)
    ].join(exports.JWT_DELIMITER);
}
function decodeJWT(jwt) {
    var _a, _b, _c;
    const params = jwt.split(exports.JWT_DELIMITER);
    const header = decodeJSON((_a = params[0]) !== null && _a !== void 0 ? _a : '{}');
    const payload = decodeJSON((_b = params[1]) !== null && _b !== void 0 ? _b : '{}');
    const signature = decodeSig((_c = params[2]) !== null && _c !== void 0 ? _c : '{}');
    const data = (0, stringUtils_1.okxfromString)(params.slice(0, 2).join(exports.JWT_DELIMITER), exports.DATA_ENCODING);
    return {
        header,
        payload,
        signature,
        data
    };
}
function signJWT(sub_1, aud_1, ttl_1, keyPair_1) {
    return __awaiter(this, arguments, void 0, function*(sub, aud, ttl, keyPair, iat = Math.floor(Date.now())) {
        const header = {
            alg: exports.JWT_IRIDIUM_ALG,
            typ: exports.JWT_IRIDIUM_TYP
        };
        const iss = encodeIss(keyPair.publicKey);
        const exp = iat + ttl;
        const act = "authenticate user";
        const payload = {
            iss,
            sub,
            aud,
            act,
            iat,
            exp
        };
        const data = encodeData({
            header,
            payload
        });
        // const signature = ed25519.sign(keyPair.secretKey, data);
        log.logDebug(`get sec kp: ${keyPair.secretKey} {${keyPair.secretKey.length}}`);
        const signature = tweetnacl_1.default.sign.detached(data, keyPair.secretKey);
        return encodeJWT({
            header,
            payload,
            signature
        });
    });
}
function verifyJWT(jwt) {
    return __awaiter(this, void 0, void 0, function*() {
        const { header, payload, data, signature } = decodeJWT(jwt);
        if (header.alg !== exports.JWT_IRIDIUM_ALG || header.typ !== exports.JWT_IRIDIUM_TYP) {
            throw new Error("JWT must use EdDSA algorithm");
        }
        const publicKey = decodeIss(payload.iss);
        return ed25519.verify(publicKey, data, signature);
    });
}
}}),
"[project]/node_modules/@okxconnect/core/src/connect/connectionManager.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function() {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o) {
            var ar = [];
            for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
            for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
    };
}();
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ConnectionManager = void 0;
const connect_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/connect/connect.js [app-ssr] (ecmascript)");
const commands_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/connect/commands.js [app-ssr] (ecmascript)");
const storageconstants_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/connect/storageconstants.js [app-ssr] (ecmascript)");
const jwtconstants_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/connect/jwtconstants.js [app-ssr] (ecmascript)");
const constants_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/connect/constants.js [app-ssr] (ecmascript)");
const eventemitter3_1 = __turbopack_require__("[project]/node_modules/eventemitter3/index.js [app-ssr] (ecmascript)");
const storage_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/connect/storage.js [app-ssr] (ecmascript)");
const utils_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/utils.js [app-ssr] (ecmascript)");
const crypto_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/crypto/crypto.js [app-ssr] (ecmascript)");
const jwt_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/connect/jwt.js [app-ssr] (ecmascript)");
const safejson_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/safejson.js [app-ssr] (ecmascript)");
const log = __importStar(__turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/log.js [app-ssr] (ecmascript)"));
const log_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/log.js [app-ssr] (ecmascript)");
const report_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/report.js [app-ssr] (ecmascript)");
const url_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/url.js [app-ssr] (ecmascript)");
class ConnectionManager {
    constructor(appname = undefined){
        this.events = new eventemitter3_1.EventEmitter();
        // local storage
        this.connectStorage = new storage_1.Storage(storageconstants_1.OKXCONNECTOR_CACHE_KEY_DAPP + appname, storageconstants_1.OKXCONNECTOR_CACHE_KEY_DAPP);
        this.crypto = new crypto_1.SessionCrypto();
        let inTMA = (0, url_1.isInTMA)();
        (0, log_1.logDebug)('do init:', inTMA);
        log.reportLog('connection manager do init');
        if (inTMA) {
            // recovery from cache
            const keyPairInfo = this.getCachedCryptoKeyPair();
            (0, log_1.logDebug)('use same pk:', keyPairInfo);
            this.crypto = new crypto_1.SessionCrypto(keyPairInfo);
        }
        this.jwtKeyPair = this.getCachedJWTKeyPair();
        this.saveJWTKeyPair(this.jwtKeyPair);
        // wss connection
        this.connector = new connect_1.OKXWalletConnector(constants_1.OKXCONNECTOR_WS_URL_1);
        this.packageId = Date.now();
        // connection state
        this.connectedWalletPK = '';
        this.currentTopic = '';
        log.logDebug(`this.connectedWalletPK  constructor   ${this.connectedWalletPK}`);
    }
    refreshPackageId() {
        this.packageId = Date.now();
    }
    saveCryptoKeyPair(keyPair) {
        let cacheInfo = (0, safejson_1.safeJsonStringify)(keyPair);
        // encrypt kp
        this.connectStorage.encryptStoreMsg(cacheInfo, storageconstants_1.OKXCONNECTOR_CRYPTO_KEY);
    }
    getCachedCryptoKeyPair() {
        // decrypt kp
        const kp = this.connectStorage.getAndDecrypt(storageconstants_1.OKXCONNECTOR_CRYPTO_KEY);
        const content = kp;
        if (typeof content == 'string') {
            log.logDebug('get cached crypto key:');
            log.logDebug(content);
            let keyPairInfo = (0, safejson_1.safeJsonParse)(content);
            return keyPairInfo;
        } else {
            this.connectStorage.clearCache();
        }
        return null;
    }
    saveJWTKeyPair(keyPair) {
        var strkeyPair = {
            publicKey: (0, utils_1.toHexString)(keyPair.publicKey),
            secretKey: (0, utils_1.toHexString)(keyPair.secretKey)
        };
        log.logDebug('save jwt kp');
        let cacheInfo = (0, safejson_1.safeJsonStringify)(strkeyPair);
        log.logDebug(cacheInfo);
        // encrypt jwt kp
        this.connectStorage.encryptStoreMsg(cacheInfo, storageconstants_1.OKXCONNECTOR_JWT_KEY);
    }
    getCachedJWTKeyPair() {
        const kp = this.connectStorage.getAndDecrypt(storageconstants_1.OKXCONNECTOR_JWT_KEY);
        const content = kp;
        if (typeof content == 'string') {
            // TODO: decrypt jwt kp
            log.logDebug('get cached jwt kp:');
            log.logDebug(content);
            let strKeyPairInfo = (0, safejson_1.safeJsonParse)(content);
            log.logDebug('save jwt kp');
            log.logDebug(strKeyPairInfo);
            var keyPair = {
                publicKey: (0, utils_1.hexToByteArray)(strKeyPairInfo.publicKey),
                secretKey: (0, utils_1.hexToByteArray)(strKeyPairInfo.secretKey)
            };
            return keyPair;
        } else {
            return (0, jwt_1.generateKeyPair)();
        }
    }
    isWalletPKReady() {
        log.logDebug(`isWalletPKReady  ===> ${this.connectedWalletPK}`);
        return this.connectedWalletPK.length > 0;
    }
    makeJWT(topic) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield (0, jwt_1.signJWT)(topic, jwtconstants_1.OKXCONNECTOR_JWT_SIDE, jwtconstants_1.OKXCONNECTOR_JWT_TTL, this.jwtKeyPair);
        });
    }
    parsePackage(input_1) {
        return __awaiter(this, arguments, void 0, function*(input, ignoreACK = false) {
            var _a, _b, _c, _d, _e;
            this.events.emit(input.id, input);
            // send back ACK
            if (!ignoreACK) {
                yield this.sendACK(input.id, true);
                let topic = (_a = this.connectStorage.getItem(storageconstants_1.OKXCONNECTOR_TOKEN_CACHE)) === null || _a === void 0 ? void 0 : _a.content;
                if (topic) {
                    let inputObj = input;
                    if ((_c = (_b = inputObj.params) === null || _b === void 0 ? void 0 : _b.data) === null || _c === void 0 ? void 0 : _c.messageId) {
                        this.refreshPackageId();
                        yield this.sendReceive(this.packageId.toString(), (_e = (_d = inputObj.params) === null || _d === void 0 ? void 0 : _d.data) === null || _e === void 0 ? void 0 : _e.messageId, topic);
                    }
                }
            }
        });
    }
    restoreConnect(topic) {
        return __awaiter(this, void 0, void 0, function*() {
            log.reportLog('connection manager restore connection');
            log.logDebug(`connectionManager  restoreConenct   ${topic}`);
            if (typeof topic !== 'string' || topic.length === 0) {
                throw new Error('CONNECTION: invalid topic');
            }
            log.logDebug(`connectionManager  restoreConenct   disconnect`);
            yield this.disconnect(true);
            this.connectStorage.saveContent(topic, storageconstants_1.OKXCONNECTOR_TOKEN_CACHE);
            log.logDebug(`connectionManager  restoreConenct   conect`);
            yield this.connect(true);
        });
    }
    getConnectInfo() {
        var topic = (0, utils_1.generateTopic)();
        log.logDebug(`generate topic token: ${topic}`);
        log.reportLog('connection manager generate connection info');
        this.currentTopic = topic;
        const info = {
            channelId: topic,
            clientId: this.crypto.stringifyKeypair().publicKey
        };
        return info;
    }
    connect() {
        return __awaiter(this, arguments, void 0, function*(fromRestore = false) {
            this.timeLog = new Date().getTime();
            (0, log_1.logDebug)("ConnectTime---enter->", this.timeLog);
            log.reportLog('connection manager begin connect');
            let lastConnectId = this.connectStorage.getItem(storageconstants_1.OKXCONNECTOR_TOKEN_CACHE);
            //1. generate topic & jwt
            var topic = this.currentTopic;
            log.logDebug(`generate topic token: ${topic}`);
            // crypto keypair
            if (fromRestore) {
                if (typeof lastConnectId !== 'undefined' && lastConnectId !== null) {
                    log.logDebug(`read last connect id: ${lastConnectId}`);
                    topic = lastConnectId.content;
                }
                var cachedSenderPublicKey = this.connectStorage.getItem(storageconstants_1.OKXCONNECTOR_CRYPTO_SENDER_PK_CACHE);
                if (cachedSenderPublicKey) {
                    this.connectedWalletPK = cachedSenderPublicKey.content;
                    (0, log_1.logDebug)(`connectionManager connect() this.connectedWalletPK : ${this.connectedWalletPK}`);
                }
                log.reportLog('connection manager do restore connection');
            }
            if (fromRestore) {
                // recovery from cache
                const keyPairInfo = this.getCachedCryptoKeyPair();
                if (keyPairInfo) {
                    this.crypto = new crypto_1.SessionCrypto(keyPairInfo);
                }
            }
            log.logDebug(`use crypto client id: ${this.crypto.stringifyKeypair().publicKey}`);
            // cache topic
            this.connectStorage.saveContent(topic, storageconstants_1.OKXCONNECTOR_TOKEN_CACHE);
            var jwtToken = yield this.makeJWT(topic);
            log.logDebug(`generate jwt token: ${jwtToken}`);
            this.connectStorage.saveContent(jwtToken, 'jwt');
            return new Promise((resolve, reject)=>{
                // 1. when websocket opened
                this.connector.onOpen(()=>__awaiter(this, void 0, void 0, function*() {
                        log.logDebug(`1. connector on open`);
                        log.reportLog('1. connect ws open');
                        const timeOne = new Date().getTime();
                        (0, log_1.logDebug)("ConnectTime---open->", timeOne - this.timeLog);
                        //2. send jwt to login
                        this.events.once(this.packageId.toString(), (rsp)=>__awaiter(this, void 0, void 0, function*() {
                                // ack
                                if (rsp && rsp.error) {
                                    log.logError('failed when login');
                                    log.reportLog('2. connect login failed');
                                    yield this.connector.disconnect();
                                    var error = new Error();
                                    error.message = rsp.error.message;
                                    error.name = rsp.error.code.toString();
                                    // throw error
                                    reject(error);
                                }
                                //3. send subscribe
                                this.refreshPackageId();
                                this.events.once(this.packageId.toString(), (rsp)=>__awaiter(this, void 0, void 0, function*() {
                                        // ack
                                        if (rsp && rsp.error) {
                                            log.logError('failed when subscribe');
                                            log.reportLog('3. connect subscribe failed');
                                            yield this.connector.disconnect();
                                            var error = new Error();
                                            error.message = rsp.error.message;
                                            error.name = rsp.error.code.toString();
                                            // throw error
                                            reject(error);
                                        }
                                        this.refreshPackageId();
                                        log.logDebug(`4. subscribe callback then send fetch: ${this.packageId}`);
                                        log.reportLog('4. subscribe callback then send fetch');
                                        const timeF = new Date().getTime();
                                        (0, log_1.logDebug)("ConnectTime--subscribe callback->", timeF - this.timeLog);
                                        // 4. fetch messages
                                        yield this.sendFetchAndConsumeMessages(this.packageId.toString(), topic);
                                        resolve();
                                    }));
                                log.logDebug(`3. login callback then send subscribe: ${this.packageId}`);
                                log.reportLog('3. connect subscribe failed');
                                const timeTh = new Date().getTime();
                                (0, log_1.logDebug)("ConnectTime---login callback->", timeTh - this.timeLog);
                                yield this.connector.send(()=>__awaiter(this, void 0, void 0, function*() {
                                        log.logDebug('CONNECT: reconnect before send');
                                        yield this.connector.connect().catch((err)=>{
                                            (0, log_1.logDebug)('ConnectionManager connect error', err);
                                            reject(err);
                                        });
                                    }), {
                                    id: this.packageId.toString(),
                                    jsonrpc: constants_1.CONNECT_JSONRPC_VER,
                                    method: commands_1.CONNECT_METHOD_SUB,
                                    params: {
                                        topic: topic
                                    }
                                });
                            }));
                        log.logDebug(`2. login called`);
                        log.reportLog('2. connection manager connect call login');
                        yield this.connector.send(()=>__awaiter(this, void 0, void 0, function*() {
                                log.logDebug('CONNECT: reconnect before send');
                                yield this.connector.connect().catch((err)=>{
                                    (0, log_1.logDebug)('ConnectionManager connect error', err);
                                    reject(err);
                                });
                            }), {
                            id: this.packageId.toString(),
                            jsonrpc: constants_1.CONNECT_JSONRPC_VER,
                            method: commands_1.CONNECT_METHOD_LOGIN,
                            params: {
                                token: jwtToken
                            }
                        });
                        // 4. listen when dapp back to front, receive wallet public key
                        this.connector.addPackageParse((event)=>{
                            var _a;
                            log.logDebug(`connect: parse package`);
                            log.logDebug(event);
                            if (!("params" in event) || !("data" in event["params"])) {
                                this.parsePackage(event, true);
                                return;
                            }
                            let rawMsg = (_a = event.params.data) === null || _a === void 0 ? void 0 : _a.message;
                            if (typeof rawMsg !== 'undefined') {
                                rawMsg = rawMsg.replace(/'/g, '"');
                                let parsedMessage = (0, safejson_1.safeJsonParse)(rawMsg);
                                if (typeof parsedMessage !== 'string' && "clientId" in parsedMessage && parsedMessage.clientId && parsedMessage.clientId.length > 0) {
                                    this.connectedWalletPK = parsedMessage.clientId;
                                    log.logDebug(`this.connectedWalletPK  addPackageParse   ${this.connectedWalletPK}`);
                                    // exchange sender public key
                                    // cache wallet public key
                                    this.connectStorage.saveContent(this.connectedWalletPK, storageconstants_1.OKXCONNECTOR_CRYPTO_SENDER_PK_CACHE);
                                    // cache crypto keypair
                                    this.saveCryptoKeyPair(this.crypto.stringifyKeypair());
                                }
                            }
                            // ignore receive echo
                            this.parsePackage(event, event.method === commands_1.CONNECT_METHOD_RECEIVE);
                        });
                    }));
                this.connector.connect().catch((err)=>{
                    (0, log_1.logDebug)('ConnectionManager connect error', err);
                    reject(err);
                });
            });
        });
    }
    disconnect() {
        return __awaiter(this, arguments, void 0, function*(fromRestore = false) {
            yield this.connector.disconnect();
            log.reportLog('connect disconnect');
            //clean cached topic
            //public key
            this.connectStorage.clearCache(storageconstants_1.OKXCONNECTOR_TOKEN_CACHE);
            if (!fromRestore) {
                this.connectStorage.clearCache(storageconstants_1.OKXCONNECTOR_CRYPTO_SENDER_PK_CACHE);
                this.connectedWalletPK = '';
                (0, log_1.logDebug)(`connectionManager disconnect() this.connectedWalletPK : ${this.connectedWalletPK}`);
            }
        });
    }
    addListener(event, success, fail) {
        this.connector.addListener((0, safejson_1.safeJsonStringify)(event), (rawMsg)=>{
            rawMsg = rawMsg.replace(/'/g, '"');
            log.logDebug(`addListener ===> ${rawMsg}`);
            if (typeof rawMsg !== 'undefined') {
                var msgObj = (0, safejson_1.safeJsonParse)(rawMsg);
                var msg = msgObj.message;
                let result;
                if (msg.trimStart().startsWith('{')) {
                    result = msg;
                } else {
                    if (msgObj.clientId && msgObj.clientId.length > 0) {
                        this.connectedWalletPK = msgObj.clientId;
                        this.connectStorage.saveContent(this.connectedWalletPK, storageconstants_1.OKXCONNECTOR_CRYPTO_SENDER_PK_CACHE);
                        log.logDebug(`this.connectedWalletPK  addListener   ${this.connectedWalletPK}`);
                        log.logDebug(`this.cryptoKey  addListener   ${(0, utils_1.toHexString)(this.crypto.keyPair.publicKey)}`);
                        // cache crypto keypair
                        this.saveCryptoKeyPair(this.crypto.stringifyKeypair());
                    }
                    result = this.crypto.decrypt(msg, this.connectedWalletPK);
                }
                log.logDebug(`addListener ===> ${result}`);
                return result;
            }
            return undefined;
        }, success, fail);
    }
    sendRaw(msg) {
        return __awaiter(this, void 0, void 0, function*() {
            log.logDebug(`message send =====> ${msg}`);
            log.reportLog('connect send raw msg');
            let message = msg;
            log.logDebug(`message send =====encrypt message.length>>>> ${message.length}`);
            // only one topic
            let topic = this.connectStorage.getItem(storageconstants_1.OKXCONNECTOR_TOKEN_CACHE);
            log.logDebug(`message send =====topic>>>> ${topic === null || topic === void 0 ? void 0 : topic.content}`);
            this.refreshPackageId();
            const payload = {
                id: this.packageId.toString(),
                method: commands_1.CONNECT_METHOD_PUBLISH,
                jsonrpc: constants_1.CONNECT_JSONRPC_VER,
                params: {
                    message: {
                        topic: topic === null || topic === void 0 ? void 0 : topic.content,
                        message: message,
                        ttl: constants_1.OKXCONNECTOR_MESSAGE_TTL
                    }
                } // crypted
            };
            this.events.once(this.packageId.toString(), (rsp)=>__awaiter(this, void 0, void 0, function*() {
                    // ack
                    if (rsp && rsp.error) {
                        log.logError(`@${new Date().toUTCString()} >>> failed when send msg`);
                    } else if (rsp && !rsp.error) {
                        log.logDebug(`CONNECTION @[${new Date().toUTCString()}] >>> send msg with id ${this.packageId} successed`);
                    }
                }));
            yield this.connector.send(()=>__awaiter(this, void 0, void 0, function*() {
                    log.logDebug('CONNECT: reconnect before send');
                    return yield this.connector.connect();
                }), payload);
            return this.packageId;
        });
    }
    send(msg_1) {
        return __awaiter(this, arguments, void 0, function*(msg, ttl = constants_1.OKXCONNECTOR_MESSAGE_TTL) {
            // make send msg payload
            log.logDebug(`message send =====> ${msg}`);
            log.reportLog('connect send msg');
            if (!this.isWalletPKReady()) {
                // channel not ready
                throw new Error('connection not finish');
            }
            let message = this.crypto.encrypt(msg, this.connectedWalletPK);
            log.logDebug(`message send =====encrypt message.length>>>> ${message.length}`);
            log.reportEvent(report_1.OKXReportType.LOG, 'msg_size', message.length.toString());
            // only one topic
            let topic = this.connectStorage.getItem(storageconstants_1.OKXCONNECTOR_TOKEN_CACHE);
            log.logDebug(`message send =====topic>>>> ${topic === null || topic === void 0 ? void 0 : topic.content}`);
            this.refreshPackageId();
            const payload = {
                id: this.packageId.toString(),
                method: commands_1.CONNECT_METHOD_PUBLISH,
                jsonrpc: constants_1.CONNECT_JSONRPC_VER,
                params: {
                    message: {
                        topic: topic === null || topic === void 0 ? void 0 : topic.content,
                        message: message,
                        ttl: ttl
                    }
                } // crypted
            };
            this.events.once(this.packageId.toString(), (rsp)=>__awaiter(this, void 0, void 0, function*() {
                    // ack
                    if (rsp && rsp.error) {
                        log.logError(`@${new Date().toUTCString()} >>> failed when send msg`);
                    } else if (rsp && !rsp.error) {
                        log.logDebug(`CONNECTION @[${new Date().toUTCString()}] >>> send msg with id ${this.packageId} successed`);
                    }
                }));
            yield this.connector.send(()=>__awaiter(this, void 0, void 0, function*() {
                    log.logDebug('CONNECT: reconnect before send');
                    return yield this.connector.connect();
                }), payload);
            return this.packageId;
        });
    }
    sendACK(msgId_1, success_1) {
        return __awaiter(this, arguments, void 0, function*(msgId, success, reason = undefined) {
            if (success === true) {
                const payload = {
                    id: msgId,
                    jsonrpc: constants_1.CONNECT_JSONRPC_VER,
                    result: true
                };
                yield this.connector.send(()=>__awaiter(this, void 0, void 0, function*() {
                        log.logDebug('CONNECT: reconnect before send');
                        return yield this.connector.connect();
                    }), payload);
            } else if (reason) {
                const payload = {
                    id: msgId,
                    jsonrpc: constants_1.CONNECT_JSONRPC_VER,
                    error: {
                        code: reason.code,
                        message: reason.message
                    }
                };
                yield this.connector.send(()=>__awaiter(this, void 0, void 0, function*() {
                        log.logDebug('CONNECT: reconnect before send');
                        return yield this.connector.connect();
                    }), payload);
            }
        });
    }
    // send receive
    sendReceive(msgId, messageId, topic) {
        return __awaiter(this, void 0, void 0, function*() {
            const payload = {
                id: msgId,
                jsonrpc: constants_1.CONNECT_JSONRPC_VER,
                method: commands_1.CONNECT_METHOD_RECEIVE,
                params: {
                    data: {
                        messageId: messageId,
                        topic: topic
                    }
                }
            };
            yield this.connector.send(()=>__awaiter(this, void 0, void 0, function*() {
                    log.logDebug('CONNECT: reconnect before send');
                    return yield this.connector.connect();
                }), payload);
        });
    }
    sendConnectSessionInfo(msgId, messageId, topic, params) {
        return __awaiter(this, void 0, void 0, function*() {});
    }
    // send receive
    // 1. fetch all 
    // 2. send back receive
    // 3. check has more, if so, repeat from 1st step
    sendFetchAndConsumeMessages(msgId, topic) {
        return __awaiter(this, void 0, void 0, function*() {
            //1. send fetch
            this.events.once(msgId, (fetchedMessages)=>__awaiter(this, void 0, void 0, function*() {
                    var _a, _b;
                    //2. consume received messages
                    if (fetchedMessages.result) {
                        var hasMore = fetchedMessages.result.hasMore;
                        var receivedMsgs = fetchedMessages.result.data;
                        if (receivedMsgs) {
                            for(let i = 0; i < receivedMsgs.length; i++){
                                let msg = receivedMsgs[i];
                                if (msg && msg.topic == topic) {
                                    let messageId = msg.messageId;
                                    log.reportLog('5. get fetch result');
                                    yield this.connector.getMsgPayloadFromHistory(msg);
                                    // send receive command to relay server
                                    this.refreshPackageId();
                                    yield this.sendReceive(this.packageId.toString(), messageId, topic);
                                }
                            }
                        }
                        // 3. check hasmore
                        if (hasMore) {
                            this.refreshPackageId();
                            yield this.sendFetchAndConsumeMessages(this.packageId.toString(), topic);
                        }
                    } else {
                        log.logDebug(`CONNECT: get error rsp ${(_a = fetchedMessages.error) === null || _a === void 0 ? void 0 : _a.code} : ${(_b = fetchedMessages.error) === null || _b === void 0 ? void 0 : _b.message}`);
                    }
                }));
            log.logDebug('5. send fetch more');
            log.reportLog('5. send fetch more');
            const timeFive = new Date().getTime();
            (0, log_1.logDebug)("ConnectTime---5->", timeFive - this.timeLog);
            const payload = {
                id: msgId,
                jsonrpc: constants_1.CONNECT_JSONRPC_VER,
                method: commands_1.CONNECT_METHOD_FETCHMSG,
                params: {
                    data: {
                        topic: topic
                    }
                }
            };
            yield this.connector.send(()=>__awaiter(this, void 0, void 0, function*() {
                    log.logDebug('CONNECT: reconnect before send');
                    return yield this.connector.connect();
                }), payload);
        });
    }
    cleanCache() {
        return __awaiter(this, void 0, void 0, function*() {
            log.reportLog('connection cache clean called');
            this.connectStorage.clearCache();
        });
    }
    saveSessionContent(key, data) {
        if (!data) {
            this.connectStorage.clearCache(storageconstants_1.OKXCONNECTOR_SESSION_PREFIX_KEY + key);
        }
        let jsonData = (0, safejson_1.safeJsonStringify)(data);
        this.connectStorage.encryptStoreMsg(jsonData, storageconstants_1.OKXCONNECTOR_SESSION_PREFIX_KEY + key);
    }
    getSessionContent(key) {
        let jsonStr = this.connectStorage.getAndDecrypt(storageconstants_1.OKXCONNECTOR_SESSION_PREFIX_KEY + key);
        if (jsonStr) {
            let object = (0, safejson_1.safeJsonParse)(jsonStr);
            return object;
        }
        return undefined;
    }
    getCurrentConnectionReady() {
        return this.isWalletPKReady();
    }
}
exports.ConnectionManager = ConnectionManager;
}}),
"[project]/node_modules/@okxconnect/core/src/connect/walletConnectionConstants.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.WalletConnectionManagerEvent = exports.WalletConnectionManagerTopicInfoCacheKey = void 0;
exports.WalletConnectionManagerTopicInfoCacheKey = "wcmtic";
exports.WalletConnectionManagerEvent = {
    RECEIVE_REQUEST: "payload"
};
}}),
"[project]/node_modules/@okxconnect/core/src/connect/walletConnectionManager.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function() {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o) {
            var ar = [];
            for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
            for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
    };
}();
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.WalletConnectionManager = void 0;
const connect_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/connect/connect.js [app-ssr] (ecmascript)");
const commands_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/connect/commands.js [app-ssr] (ecmascript)");
const storageconstants_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/connect/storageconstants.js [app-ssr] (ecmascript)");
const jwtconstants_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/connect/jwtconstants.js [app-ssr] (ecmascript)");
const constants_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/connect/constants.js [app-ssr] (ecmascript)");
const walletConnectionConstants_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/connect/walletConnectionConstants.js [app-ssr] (ecmascript)");
const eventemitter3_1 = __turbopack_require__("[project]/node_modules/eventemitter3/index.js [app-ssr] (ecmascript)");
const storage_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/connect/storage.js [app-ssr] (ecmascript)");
const utils_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/utils.js [app-ssr] (ecmascript)");
const crypto_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/crypto/crypto.js [app-ssr] (ecmascript)");
const jwt_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/connect/jwt.js [app-ssr] (ecmascript)");
const safejson_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/safejson.js [app-ssr] (ecmascript)");
const log = __importStar(__turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/log.js [app-ssr] (ecmascript)"));
const log_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/log.js [app-ssr] (ecmascript)");
const utils_2 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/index.js [app-ssr] (ecmascript)");
class WalletConnectionManager {
    constructor(){
        this.events = new eventemitter3_1.EventEmitter();
        this.communicateEvents = new eventemitter3_1.EventEmitter();
        log.logDebug('connect manager construct');
        // local storage
        this.connectStorage = new storage_1.Storage(storageconstants_1.OKXCONNECTOR_CACHE_KEY);
        // this.crypto = new SessionCrypto()
        this.jwtKeyPair = this.getCachedJWTKeyPair();
        this.saveJWTKeyPair(this.jwtKeyPair);
        // wss connection
        this.connector = new connect_1.OKXWalletConnector(constants_1.OKXCONNECTOR_WS_URL_1);
        this.packageId = Date.now();
        // connection state
        this.sessionCryptoInfoMap = new Map();
        // log.logDebug(`this.connectedWalletPK  constructor   ${this.connectedWalletPK}`)
        this.inLogin = false;
        this.isLogined = false;
    }
    refreshPackageId(offset = 0) {
        this.packageId = Date.now() + offset;
    }
    saveCryptoKeyPair(topicId, keyPair) {
        let cacheInfo = (0, safejson_1.safeJsonStringify)(keyPair);
        // encrypt kp
        this.connectStorage.encryptStoreMsg(cacheInfo, storageconstants_1.OKXCONNECTOR_CRYPTO_KEY + topicId);
    }
    getCachedCryptoKeyPair(topicId) {
        // decrypt kp
        const kp = this.connectStorage.getAndDecrypt(storageconstants_1.OKXCONNECTOR_CRYPTO_KEY + topicId);
        const content = kp;
        if (typeof content == 'string') {
            log.logDebug('get cached crypto key:');
            log.logDebug(content);
            let keyPairInfo = (0, safejson_1.safeJsonParse)(content);
            return keyPairInfo;
        } else {
            this.connectStorage.clearCache();
        }
        return null;
    }
    saveJWTKeyPair(keyPair) {
        var strkeyPair = {
            publicKey: (0, utils_1.toHexString)(keyPair.publicKey),
            secretKey: (0, utils_1.toHexString)(keyPair.secretKey)
        };
        log.logDebug('save jwt kp');
        let cacheInfo = (0, safejson_1.safeJsonStringify)(strkeyPair);
        log.logDebug(cacheInfo);
        // encrypt jwt kp
        this.connectStorage.encryptStoreMsg(cacheInfo, storageconstants_1.OKXCONNECTOR_JWT_KEY);
        log.logDebug('after save jwt kp');
    }
    getCachedJWTKeyPair() {
        const kp = this.connectStorage.getAndDecrypt(storageconstants_1.OKXCONNECTOR_JWT_KEY);
        const content = kp;
        if (typeof content == 'string') {
            // TODO: decrypt jwt kp
            log.logDebug('get cached jwt kp:');
            log.logDebug(content);
            let strKeyPairInfo = (0, safejson_1.safeJsonParse)(content);
            log.logDebug('save jwt kp');
            log.logDebug(strKeyPairInfo);
            var keyPair = {
                publicKey: (0, utils_1.hexToByteArray)(strKeyPairInfo.publicKey),
                secretKey: (0, utils_1.hexToByteArray)(strKeyPairInfo.secretKey)
            };
            return keyPair;
        } else {
            return (0, jwt_1.generateKeyPair)();
        }
    }
    isTopicPublicKeyExist(topicId) {
        log.logDebug(`isTopicPublicKeyExist  ===> ${topicId}`);
        return this.sessionCryptoInfoMap.get(topicId);
    }
    makeJWT(timestampStr) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield (0, jwt_1.signJWT)(timestampStr, jwtconstants_1.OKXCONNECTOR_JWT_WALLET_SIDE, jwtconstants_1.OKXCONNECTOR_JWT_TTL, this.jwtKeyPair);
        });
    }
    parseInternalMsg(internalMsg) {
        try {
            let internalObj = (0, safejson_1.safeJsonParse)(internalMsg);
            let origin = internalObj['ivur-igbfft-ptjip'];
            if (origin && origin.length > 0) {
                let originContent = (0, utils_2.base64decode)(origin, true);
                return originContent.toString();
            }
        } catch (error) {
            log.logError('parse internal msg', error);
        }
    }
    updateClientId(topic, clientId) {
        let sessionInfo = this.sessionCryptoInfoMap.get(topic);
        (0, log_1.logDebug)('updateClientId', sessionInfo, topic, clientId);
        if (sessionInfo && clientId && clientId.length > 0) {
            if (sessionInfo.cid) {
                // check
                let lastCheck = (0, utils_1.getLastSixMd5Hash)(clientId);
                if (sessionInfo.cid == lastCheck) {
                    sessionInfo.dappPublicKey = clientId;
                } else {
                    log.logError('cid check failed', sessionInfo, topic, clientId);
                }
            } else {
                sessionInfo.dappPublicKey = clientId;
            }
            // 
            this.syncCacheSessionInfo();
        }
        return false;
    }
    parsePackage(topic_1, input_1) {
        return __awaiter(this, arguments, void 0, function*(topic, input, ignoreACK = false) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
            this.events.emit(input.id, input);
            // emit event
            let sessionInfo = this.sessionCryptoInfoMap.get(topic);
            log.logDebug('get sessionInfo for decrypt topic:', topic);
            log.logDebug('get sessionInfo for decrypt:', input.id, topic, sessionInfo, this.sessionCryptoInfoMap);
            if (sessionInfo && input.params.data) {
                if ((_a = input.params.data) === null || _a === void 0 ? void 0 : _a.message) {
                    // try parse internal message
                    if ((_b = input.params.data) === null || _b === void 0 ? void 0 : _b.isInternalData) {
                        let inner_message = (_c = input.params.data) === null || _c === void 0 ? void 0 : _c.message;
                        let inner_topic = (_d = input.params.data) === null || _d === void 0 ? void 0 : _d.topic;
                        let originContent = this.parseInternalMsg(inner_message);
                        (0, log_1.logDebug)('parse internal origin: ', originContent);
                        if (originContent && originContent.length > 0) {
                            this.communicateEvents.emit("origin", originContent, inner_topic);
                        }
                    } else {
                        // try parse message base64
                        try {
                            let message = (_e = input.params.data) === null || _e === void 0 ? void 0 : _e.message;
                            if (message.trimStart().startsWith('{')) {
                                let messageObj = (0, safejson_1.safeJsonParse)(message);
                                if (messageObj.method) {
                                    if (messageObj.method == 'session_info') {
                                        let sessionInfoString = messageObj.params.sessionInfo;
                                        let base64Content = (0, utils_2.base64decode)(sessionInfoString, false);
                                        (0, log_1.logDebug)("wallet connection manager requset base64Content:", base64Content);
                                        (0, log_1.logDebug)("base64Content:" + base64Content);
                                        let inner_connection = base64Content.toObject();
                                        this.updateClientId(topic, inner_connection.clientId);
                                    }
                                    (0, log_1.logDebug)('<<< parse raw msg:', topic, messageObj);
                                    this.communicateEvents.emit(topic, message);
                                }
                            } else {
                                let message = sessionInfo.crypto.decryptWallet((_f = input.params.data) === null || _f === void 0 ? void 0 : _f.message, sessionInfo.dappPublicKey);
                                (0, log_1.logDebug)('<<< receive msg:', topic, message);
                                this.communicateEvents.emit(topic, message);
                            }
                        } catch (error) {
                            let message = sessionInfo.crypto.decryptWallet((_g = input.params.data) === null || _g === void 0 ? void 0 : _g.message, sessionInfo.dappPublicKey);
                            (0, log_1.logDebug)('<<< receive msg:', topic, message);
                            this.communicateEvents.emit(topic, message);
                        }
                    }
                } else {}
            }
            // send back ACK
            if (!ignoreACK) {
                yield this.sendACK(input.id, true);
                if (topic) {
                    let inputObj = input;
                    if ((_j = (_h = inputObj.params) === null || _h === void 0 ? void 0 : _h.data) === null || _j === void 0 ? void 0 : _j.messageId) {
                        this.refreshPackageId();
                        yield this.sendReceive(this.packageId.toString(), (_l = (_k = inputObj.params) === null || _k === void 0 ? void 0 : _k.data) === null || _l === void 0 ? void 0 : _l.messageId, topic);
                    }
                }
            }
        });
    }
    recovrySessionInfoFromCache() {
        // get topic ids and keys from session
        // WalletConnectionCryptoCacheMap
        // {[topicId]: {cryptoKeypair: {publicKey:string, secretKey:string}, dappPublicKey:clientId}}
        let jsonStr = this.connectStorage.getAndDecrypt(walletConnectionConstants_1.WalletConnectionManagerTopicInfoCacheKey);
        log.logDebug('get cached sessionInfos:', jsonStr);
        if (jsonStr) {
            let cacheMap = (0, safejson_1.safeJsonParse)(jsonStr);
            for(let topicId in cacheMap){
                let topicItem = cacheMap[topicId];
                log.logDebug('make topicItem:', topicItem);
                let cryptoItem = {
                    topic: topicId,
                    crypto: new crypto_1.SessionCrypto({
                        publicKey: topicItem.cryptoKeyPair.publicKey,
                        secretKey: topicItem.cryptoKeyPair.secretKey
                    }),
                    dappPublicKey: topicItem.dappPublicKey,
                    cid: topicItem.cid
                };
                this.sessionCryptoInfoMap.set(topicId, cryptoItem);
            }
        }
        log.logDebug('get cached sessionInfos map:', this.sessionCryptoInfoMap);
    }
    syncCacheSessionInfo() {
        let cacheMap = {};
        for (let [topicId, cryptoItem] of this.sessionCryptoInfoMap){
            log.logDebug('for each Keys', topicId);
            if (cryptoItem) {
                cacheMap[topicId] = {
                    cryptoKeyPair: cryptoItem.crypto.stringifyKeypair(),
                    dappPublicKey: cryptoItem.dappPublicKey,
                    cid: cryptoItem.cid
                };
            }
        }
        let jsonData = (0, safejson_1.safeJsonStringify)(cacheMap);
        log.logDebug('sync cache sessionInfos:', jsonData);
        this.connectStorage.encryptStoreMsg(jsonData, walletConnectionConstants_1.WalletConnectionManagerTopicInfoCacheKey);
    }
    cacheSessionInfo(topic, sessionInfo, sync = true) {
        let dappPublicKey = sessionInfo.dappPublicKey;
        // 1. search dapp public related topic ids
        let duplicatedTopics = [];
        for (let [topicId, cryptoItem] of this.sessionCryptoInfoMap){
            log.logDebug('for each Keys', topicId);
            if (cryptoItem.dappPublicKey == dappPublicKey) {
                log.logDebug('duplicated dapp public key:', topicId, dappPublicKey);
                duplicatedTopics.push(topicId);
            }
        }
        for (let [topicId, cryptoItem] of this.sessionCryptoInfoMap){
            if (duplicatedTopics.includes(topicId)) {
                this.sessionCryptoInfoMap.delete(topicId);
            }
        }
        // discard useless topics
        log.logDebug('cleaned connect session cache:', this.sessionCryptoInfoMap);
        // 2. remove previous connected topic ids
        // 3. write in current topic
        this.sessionCryptoInfoMap.set(topic, sessionInfo);
        // TODO: search domain info and then delete 
        log.logDebug('cache sessionInfo:', topic, sessionInfo, this.sessionCryptoInfoMap);
        if (sync) {
            this.syncCacheSessionInfo();
        }
        return duplicatedTopics;
    }
    // add and subscribe topic
    appendTopic(topic, sessionPublicKey, cid) {
        return __awaiter(this, void 0, void 0, function*() {
            (0, log_1.logDebug)('4.1. get append Topic:', topic);
            // 1. check if connected
            return new Promise((resolve, reject)=>__awaiter(this, void 0, void 0, function*() {
                    if (!this.isLogined) {
                        var error = new Error();
                        error.message = "connection is not logined";
                        error.name = "append error";
                        // throw error
                        reject(error);
                        return;
                    }
                    // 2. subscribe topic and session public key
                    let cryptoItem = {
                        topic: topic,
                        crypto: new crypto_1.SessionCrypto(),
                        dappPublicKey: sessionPublicKey ? sessionPublicKey : "",
                        cid: cid
                    };
                    let duplicatedTopics = this.cacheSessionInfo(topic, cryptoItem, false);
                    // make sure cache session info before subscribe
                    yield this.subscribeTopics(Array.from([
                        topic
                    ]));
                    this.refreshPackageId();
                    log.logDebug(`5. subscribe callback then fetch append message: ${this.packageId}, ${topic}`);
                    log.reportLog(`5. subscribe callback then fetch append message`);
                    const timeF = new Date().getTime();
                    (0, log_1.logDebug)("Append --subscribe callback->", timeF - this.timeLog);
                    resolve(duplicatedTopics);
                }));
        });
    }
    confirmAppendingTopics() {
        this.syncCacheSessionInfo();
    }
    connect() {
        return __awaiter(this, void 0, void 0, function*() {
            this.timeLog = new Date().getTime();
            (0, log_1.logDebug)("[Wallet] ConnectTime---enter->", this.timeLog);
            log.reportLog('wallet connect connect called');
            // 0. get cached topics and infos
            let timestampStr = Date.now().toString();
            var jwtToken = yield this.makeJWT(timestampStr);
            log.logDebug(`generate jwt token: ${jwtToken}`);
            this.connectStorage.saveContent(jwtToken, 'jwt');
            this.recovrySessionInfoFromCache();
            // 1.
            return new Promise((resolve, reject)=>{
                // 1. when websocket opened
                this.inLogin = true;
                this.connector.onOpen(()=>__awaiter(this, void 0, void 0, function*() {
                        log.logDebug(`1. connector on open`);
                        log.reportLog('1. wallet connect connect on open');
                        const timeOne = new Date().getTime();
                        (0, log_1.logDebug)("ConnectTime---open->", timeOne - this.timeLog);
                        //2. send jwt to login
                        this.events.once(this.packageId.toString(), (rsp)=>__awaiter(this, void 0, void 0, function*() {
                                // ack
                                if (rsp && rsp.error) {
                                    log.logError('failed when login');
                                    yield this.connector.disconnect();
                                    var error = new Error();
                                    error.message = rsp.error.message;
                                    error.name = rsp.error.code.toString();
                                    // throw error
                                    reject(error);
                                } else {
                                    this.isLogined = true;
                                    resolve();
                                    // 3. subscribe cached topics
                                    log.logDebug('3. subscribe cached topics', this.sessionCryptoInfoMap);
                                    log.reportLog('3. wallet connect connect subscribe cached topics');
                                    if (this.sessionCryptoInfoMap.size > 0) {
                                        yield this.subscribeTopics(Array.from(this.sessionCryptoInfoMap.keys()));
                                    }
                                }
                            }));
                        log.logDebug(`2. login called`);
                        log.reportLog('2. wallet connect login called');
                        yield this.connector.send(()=>__awaiter(this, void 0, void 0, function*() {
                                log.logDebug('CONNECT: reconnect before send');
                                return yield this.connector.connect();
                            }), {
                            id: this.packageId.toString(),
                            jsonrpc: constants_1.CONNECT_JSONRPC_VER,
                            method: commands_1.CONNECT_METHOD_LOGIN,
                            params: {
                                token: jwtToken
                            }
                        });
                    }));
                this.connector.connect().catch((err)=>{
                    (0, log_1.logDebug)('WalletConnectionManager connect error', err);
                    reject(err);
                });
                // add callback
                this.connector.addPackageParse((event)=>{
                    var _a, _b;
                    log.logDebug(`connect: parse package`);
                    log.logDebug(event);
                    if (!("params" in event) || !("data" in event["params"])) {
                        this.parsePackage("", event, true);
                        return;
                    }
                    // ignore receive echo
                    if ((_a = event.params.data) === null || _a === void 0 ? void 0 : _a.topic) {
                        this.parsePackage((_b = event.params.data) === null || _b === void 0 ? void 0 : _b.topic, event, event.method === commands_1.CONNECT_METHOD_RECEIVE);
                    }
                });
            // this.connector.addListener(safeJsonStringify(event), (rawMsg: string)=> {
            //    rawMsg = rawMsg.replace(/'/g, '"')
            //    log.logDebug(`addListener ===> ${rawMsg}`)
            //    if (typeof rawMsg !== 'undefined') {
            //       var msgObj = safeJsonParse(rawMsg)
            //       var msg = msgObj.message
            //       let crypto = 
            //       var result = this.crypto.decrypt(msg, this.connectedWalletPK)
            //       log.logDebug(`addListener ===> ${result}`)
            //       return result
            //    }
            //    return undefined
            // }, ()=>{
            //    // emit success
            // }, ()=>{
            //    // emit fail
            // })
            });
        });
    }
    // topic session
    // approveclientId
    getSessionPublicKey(topicId) {
        if (this.isTopicPublicKeyExist(topicId)) {
            let item = this.sessionCryptoInfoMap.get(topicId);
            if (item) {
                return (0, utils_1.toHexString)(item.crypto.keyPair.publicKey);
            }
        }
        return undefined;
    }
    getCurrentCachedTopicIdList() {
        return Array.from(this.sessionCryptoInfoMap.keys());
    }
    disconnect() {
        return __awaiter(this, arguments, void 0, function*(fromRestore = false) {
            yield this.connector.disconnect();
            //clean cached topic
            //public key
            this.connectStorage.clearCache(storageconstants_1.OKXCONNECTOR_TOKEN_CACHE);
            if (!fromRestore) {
                this.connectStorage.clearCache(storageconstants_1.OKXCONNECTOR_CRYPTO_SENDER_PK_CACHE);
            }
        });
    }
    send(topic_1, msg_1) {
        return __awaiter(this, arguments, void 0, function*(topic, msg, needPublicKey = false, ttl = constants_1.OKXCONNECTOR_MESSAGE_TTL, useRaw = false) {
            var _a, _b;
            // make send msg payload
            log.logDebug(`message send =====> ${msg}`);
            if (!this.isTopicPublicKeyExist(topic)) {
                // channel not ready
                throw new Error('connection not finish');
            }
            let connectedDappPK = (_a = this.sessionCryptoInfoMap.get(topic)) === null || _a === void 0 ? void 0 : _a.dappPublicKey;
            let cryptoObject = (_b = this.sessionCryptoInfoMap.get(topic)) === null || _b === void 0 ? void 0 : _b.crypto;
            let messageObj = undefined;
            if (useRaw) {
                messageObj = {
                    message: msg
                };
            }
            if (cryptoObject && connectedDappPK && !useRaw) {
                let message = cryptoObject.encryptWallet(msg, connectedDappPK);
                messageObj = {
                    message: message
                };
            }
            if (messageObj) {
                if (needPublicKey && cryptoObject) {
                    messageObj.clientId = (0, utils_1.toHexString)(cryptoObject.keyPair.publicKey);
                // let privateKey = toHexString(cryptoObject.keyPair.secretKey)
                // log.logDebug(`message send use dapp publicKey =====> ${connectedDappPK}`)
                // log.logDebug(`message send use publicKey =====> ${messageObj.clientId}`)
                // log.logDebug(`message send use secretKey =====> ${privateKey}`)
                }
                this.refreshPackageId();
                const payload = {
                    id: this.packageId.toString(),
                    method: commands_1.CONNECT_METHOD_PUBLISH,
                    jsonrpc: constants_1.CONNECT_JSONRPC_VER,
                    params: {
                        message: {
                            topic: topic,
                            message: (0, safejson_1.safeJsonStringify)(messageObj),
                            ttl: ttl
                        }
                    } // crypted
                };
                this.events.once(this.packageId.toString(), (rsp)=>__awaiter(this, void 0, void 0, function*() {
                        // ack
                        if (rsp && rsp.error) {
                            log.logError(`@${new Date().toUTCString()} >>> failed when send msg`);
                        } else if (rsp && !rsp.error) {
                            log.logDebug(`CONNECTION @[${new Date().toUTCString()}] >>> send msg with id ${this.packageId} successed`);
                        }
                    }));
                yield this.connector.send(()=>__awaiter(this, void 0, void 0, function*() {
                        log.logDebug('CONNECT: reconnect before send');
                        return yield this.connector.connect();
                    }), payload);
                return this.packageId;
            }
        });
    }
    sendACK(msgId_1, success_1) {
        return __awaiter(this, arguments, void 0, function*(msgId, success, reason = undefined) {
            if (success === true) {
                const payload = {
                    id: msgId,
                    jsonrpc: constants_1.CONNECT_JSONRPC_VER,
                    result: true
                };
                yield this.connector.send(()=>__awaiter(this, void 0, void 0, function*() {
                        log.logDebug('CONNECT: reconnect before send');
                        return yield this.connector.connect();
                    }), payload);
            } else if (reason) {
                const payload = {
                    id: msgId,
                    jsonrpc: constants_1.CONNECT_JSONRPC_VER,
                    error: {
                        code: reason.code,
                        message: reason.message
                    }
                };
                yield this.connector.send(()=>__awaiter(this, void 0, void 0, function*() {
                        log.logDebug('CONNECT: reconnect before send');
                        return yield this.connector.connect();
                    }), payload);
            }
        });
    }
    // send receive
    sendReceive(msgId, messageId, topic) {
        return __awaiter(this, void 0, void 0, function*() {
            const payload = {
                id: msgId,
                jsonrpc: constants_1.CONNECT_JSONRPC_VER,
                method: commands_1.CONNECT_METHOD_RECEIVE,
                params: {
                    data: {
                        messageId: messageId,
                        topic: topic
                    }
                }
            };
            yield this.connector.send(()=>__awaiter(this, void 0, void 0, function*() {
                    log.logDebug('CONNECT: reconnect before send');
                    return yield this.connector.connect();
                }), payload);
        });
    }
    sendUnsubscribe(topic) {
        return __awaiter(this, void 0, void 0, function*() {
            // TODO: make disconnect payload
            yield this.connector.send(()=>__awaiter(this, void 0, void 0, function*() {
                    log.logDebug('CONNECT: reconnect before send');
                    return yield this.connector.connect();
                }), {
                id: this.packageId.toString(),
                jsonrpc: constants_1.CONNECT_JSONRPC_VER,
                method: commands_1.CONNECT_METHOD_UNSUB,
                params: {
                    topic: topic
                }
            });
            // remove topicId
            this.sessionCryptoInfoMap.delete(topic);
            this.syncCacheSessionInfo();
        });
    }
    // send receive
    // 1. fetch all 
    // 2. send back receive
    // 3. check has more, if so, repeat from 1st step
    sendFetchAndConsumeMessages(msgId, topic) {
        return __awaiter(this, void 0, void 0, function*() {
            //1. send fetch
            this.events.once(msgId, (fetchedMessages)=>__awaiter(this, void 0, void 0, function*() {
                    var _a, _b;
                    //2. consume received messages
                    if (fetchedMessages.result) {
                        var hasMore = fetchedMessages.result.hasMore;
                        var receivedMsgs = fetchedMessages.result.data;
                        if (receivedMsgs) {
                            for(let i = 0; i < receivedMsgs.length; i++){
                                let msg = receivedMsgs[i];
                                if (msg && msg.topic == topic) {
                                    let messageId = msg.messageId;
                                    yield this.connector.getMsgPayloadFromHistory(msg);
                                    // send receive command to relay server
                                    this.refreshPackageId();
                                    yield this.sendReceive(this.packageId.toString(), messageId, topic);
                                }
                            }
                        }
                        // 3. check hasmore
                        if (hasMore) {
                            this.refreshPackageId();
                            yield this.sendFetchAndConsumeMessages(this.packageId.toString(), topic);
                        }
                    } else {
                        log.logDebug(`CONNECT: get error rsp ${(_a = fetchedMessages.error) === null || _a === void 0 ? void 0 : _a.code} : ${(_b = fetchedMessages.error) === null || _b === void 0 ? void 0 : _b.message}`);
                    }
                }));
            log.logDebug('5. send fetch more');
            const timeFive = new Date().getTime();
            (0, log_1.logDebug)("ConnectTime---5->", timeFive - this.timeLog);
            const payload = {
                id: msgId,
                jsonrpc: constants_1.CONNECT_JSONRPC_VER,
                method: commands_1.CONNECT_METHOD_FETCHMSG,
                params: {
                    data: {
                        topic: topic
                    }
                }
            };
            yield this.connector.send(()=>__awaiter(this, void 0, void 0, function*() {
                    log.logDebug('CONNECT: reconnect before send');
                    return yield this.connector.connect();
                }), payload);
        });
    }
    sendBatchFetchAndConsumeMessages(packageId, topicIdList) {
        return __awaiter(this, void 0, void 0, function*() {
            //1. send fetch
            this.events.once(packageId, (fetchedMessages)=>__awaiter(this, void 0, void 0, function*() {
                    var _a, _b;
                    //2. consume received messages
                    if (fetchedMessages.result) {
                        var hasMore = fetchedMessages.result.hasMore;
                        var receivedMsgs = fetchedMessages.result.data;
                        if (receivedMsgs) {
                            for(let i = 0; i < receivedMsgs.length; i++){
                                let msg = receivedMsgs[i];
                                if (msg && msg.topic) {
                                    let messageId = msg.messageId;
                                    yield this.connector.getMsgPayloadFromHistory(msg);
                                    // send receive command to relay server
                                    this.refreshPackageId(i);
                                    yield this.sendReceive(this.packageId.toString(), messageId, msg.topic);
                                }
                            }
                        }
                        // 3. check hasmore
                        if (hasMore) {
                            this.refreshPackageId();
                            yield this.sendBatchFetchAndConsumeMessages(this.packageId.toString(), topicIdList);
                        }
                    } else {
                        log.logDebug(`CONNECT: get error rsp ${(_a = fetchedMessages.error) === null || _a === void 0 ? void 0 : _a.code} : ${(_b = fetchedMessages.error) === null || _b === void 0 ? void 0 : _b.message}`);
                    }
                }));
            log.logDebug('5. send fetch more');
            log.reportLog('5. send fetch more');
            const timeFive = new Date().getTime();
            (0, log_1.logDebug)("ConnectTime---5->", timeFive - this.timeLog);
            const payload = {
                id: packageId,
                jsonrpc: constants_1.CONNECT_JSONRPC_VER,
                method: commands_1.CONNECT_METHOD_BATCH_FETCHMSG,
                params: {
                    topics: topicIdList,
                    withInternalData: true
                }
            };
            yield this.connector.send(()=>__awaiter(this, void 0, void 0, function*() {
                    log.logDebug('CONNECT: reconnect before send');
                    yield this.connector.connect();
                }), payload);
        });
    }
    cleanCache() {
        return __awaiter(this, void 0, void 0, function*() {
            this.connectStorage.clearCache();
        });
    }
    saveSessionContent(key, data) {
        if (!data) {
            this.connectStorage.clearCache(storageconstants_1.OKXCONNECTOR_SESSION_PREFIX_KEY + key);
        }
        let jsonData = (0, safejson_1.safeJsonStringify)(data);
        this.connectStorage.encryptStoreMsg(jsonData, storageconstants_1.OKXCONNECTOR_SESSION_PREFIX_KEY + key);
    }
    getSessionContent(key) {
        let jsonStr = this.connectStorage.getAndDecrypt(storageconstants_1.OKXCONNECTOR_SESSION_PREFIX_KEY + key);
        if (jsonStr) {
            let object = (0, safejson_1.safeJsonParse)(jsonStr);
            return object;
        }
        return undefined;
    }
    // subscribe then fetch messages for each topics
    subscribeTopics(topicIdList) {
        return __awaiter(this, void 0, void 0, function*() {
            (0, log_1.logDebug)("4. topicid list", topicIdList);
            log.reportLog("4. topicid list");
            this.refreshPackageId();
            const timeF = new Date().getTime();
            (0, log_1.logDebug)("ConnectTime--subscribe callback->", timeF - this.timeLog);
            return new Promise((resolve, reject)=>__awaiter(this, void 0, void 0, function*() {
                    let finishCount = 0;
                    //3. send subscribe
                    for(let idx = 0; idx < topicIdList.length; ++idx){
                        let topicId = topicIdList[idx];
                        this.refreshPackageId(idx);
                        this.events.once(this.packageId.toString(), (rsp)=>__awaiter(this, void 0, void 0, function*() {
                                // ack
                                if (rsp && rsp.error) {
                                    log.logError('failed when subscribe');
                                    yield this.connector.disconnect();
                                    var error = new Error();
                                    error.message = rsp.error.message;
                                    error.name = rsp.error.code.toString();
                                    // reject(error)
                                    finishCount += 1;
                                    if (finishCount == topicIdList.length) {
                                        resolve();
                                    }
                                }
                                this.refreshPackageId(idx);
                                const timeF = new Date().getTime();
                                (0, log_1.logDebug)("ConnectTime--subscribe callback->", timeF - this.timeLog);
                                finishCount += 1;
                                if (finishCount == topicIdList.length) {
                                    // 4. fetch messages
                                    log.logDebug(`5. send fetch msg: ${this.packageId}, ${topicId}`);
                                    yield this.sendBatchFetchAndConsumeMessages(this.packageId.toString(), topicIdList);
                                    resolve();
                                }
                            }));
                        log.logDebug(`3. login callback then send subscribe: ${this.packageId}, ${topicId}`);
                        log.reportLog('3. login callback then send subscribe');
                        const timeTh = new Date().getTime();
                        (0, log_1.logDebug)("ConnectTime---login callback->", timeTh - this.timeLog);
                        yield this.connector.send(()=>__awaiter(this, void 0, void 0, function*() {
                                log.logDebug('CONNECT: reconnect before send');
                                return yield this.connector.connect();
                            }), {
                            id: this.packageId.toString(),
                            jsonrpc: constants_1.CONNECT_JSONRPC_VER,
                            method: commands_1.CONNECT_METHOD_SUB,
                            params: {
                                topic: topicId
                            }
                        });
                    }
                }));
        });
    }
}
exports.WalletConnectionManager = WalletConnectionManager;
}}),
"[project]/node_modules/@okxconnect/core/src/connect/sessionUtils.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.buildNameSpacesByConnectResponse = buildNameSpacesByConnectResponse;
exports.buildRequestAccountNameSpacesByConnectResponse = buildRequestAccountNameSpacesByConnectResponse;
const log_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/log.js [app-ssr] (ecmascript)");
function buildNameSpacesByConnectResponse(connectResponse) {
    let requestAccountNameSpaces = buildRequestAccountNameSpacesByConnectResponse(connectResponse);
    return requestAccountNameSpaces;
}
function buildRequestAccountNameSpacesByConnectResponse(connectResponse) {
    let result = {};
    (0, log_1.logDebug)('buildRequestAccountNameSpacesByConnectResponse start connectResponse>>', JSON.stringify(connectResponse));
    let universalResponse = connectResponse.payload.responses.find((item)=>item.name === 'requestAccounts');
    const tonAddress = connectResponse.payload.responses.find((item)=>item.name === 'ton_addr');
    const tonProof = connectResponse.payload.responses.find((item)=>item.name === 'ton_proof');
    if (tonAddress && !universalResponse) {
        (0, log_1.logDebug)('buildRequestAccountNameSpacesByConnectResponse adapt ton data >>');
        let address = tonAddress.address;
        address = 'ton:' + tonAddress.network + ":" + address;
        let data = {
            ton_addr: tonAddress
        };
        if (tonProof) {
            data.ton_proof = tonProof;
        }
        universalResponse = {
            name: "requestAccounts",
            accounts: [
                {
                    namespace: 'ton',
                    addresses: [
                        address
                    ],
                    methods: [
                        'ton_sendTransaction'
                    ],
                    extra: {},
                    data: data
                }
            ]
        };
    }
    (0, log_1.logDebug)('buildRequestAccountNameSpacesByConnectResponse end universalResponse>>>', JSON.stringify(universalResponse));
    universalResponse.accounts.forEach((item)=>{
        var chains = [];
        var accounts = [];
        item.addresses.forEach((addressItem)=>{
            var addressArr = addressItem.split(":");
            (0, log_1.logDebug)('buildRequestAccountNameSpacesByConnectResponse addressArr>>', addressArr.length);
            if (addressArr.length >= 3) {
                let chain = addressArr.slice(0, 2).join(":");
                chains.push(chain);
                accounts.push(addressItem);
                (0, log_1.logDebug)('buildRequestAccountNameSpacesByConnectResponse chain:>>', chain, "addressItem:", addressItem);
            }
        });
        if (item.data && item.data.ton_addr) {
            item.data.ton_addr.name = 'ton_addr';
        }
        if (item.data && item.data.ton_proof) {
            item.data.ton_proof.name = 'ton_proof';
        }
        result[item.namespace] = {
            chains: chains,
            accounts: accounts,
            methods: item.methods,
            extra: item.extra,
            payload: item.data
        };
        (0, log_1.logDebug)('buildRequestAccountNameSpacesByConnectResponse result>>', JSON.stringify(result));
    });
    return result;
} /*export function buildTonNameSpaceByConnectResponse(connectResponse: ConnectResponseSuccess): Namespaces | undefined {
    const tonAddrItem: TonAddressItemReply = connectResponse.payload.responses.find(
        item => item.name === 'ton_addr'
    ) as TonAddressItemReply;

    const tonProfItem: TonProofItemReply = connectResponse.payload.responses.find(
        item => item.name === 'ton_proof'
    ) as TonProofItemReply;

    if (!tonAddrItem) {
        return undefined
    }

    return {
        NameSpaceKeyTON: {
            chains: [tonAddrItem.network],
            accounts: [],
            methods: connectResponse.payload.wallet.features?.ton,
            payload: {
                tonAccount: {
                    address: tonAddrItem.address,
                    chain: tonAddrItem.network,
                    walletStateInit: tonAddrItem.walletStateInit,
                    publicKey: tonAddrItem.publicKey
                },
                tonProof: tonProfItem
            }
        }
    }
}*/ 
}}),
"[project]/node_modules/@okxconnect/core/src/connect/engine.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Engine = void 0;
const safejson_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/safejson.js [app-ssr] (ecmascript)");
const log_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/log.js [app-ssr] (ecmascript)");
const protocol_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/protocol/index.js [app-ssr] (ecmascript)");
// import {standardDeeplink, tonConnectSdkVersion} from "../../ton/tonsdk/constants/version";
const utils_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/index.js [app-ssr] (ecmascript)");
const utils_2 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/index.js [app-ssr] (ecmascript)");
const sessionUtils_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/connect/sessionUtils.js [app-ssr] (ecmascript)");
const url_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/url.js [app-ssr] (ecmascript)");
class Engine {
    constructor(connectionManager){
        this.pendingRequests = new Map();
        this.disconnectListener = [];
        this.connectionManager = connectionManager;
        // report api begin
        (0, log_1.getDefaultReporter)().beginReport();
        this.connectionManager.addListener("sdk_response", (event, msg)=>{
            var jsonResponse = (0, safejson_1.safeJsonParse)(msg);
            (0, log_1.logDebug)(`Engine ==>> addListener ==> success ==> ${jsonResponse}`);
            this.handleResponse(event, jsonResponse);
        }, function() {});
    }
    addDisconnectListener(disconnecter) {
        this.disconnectListener.push(disconnecter);
    }
    setSessionConnectingListener(sessionConnectingListener) {
        this.sessionConnectingListener = sessionConnectingListener;
    }
    disconnect() {
        (0, log_1.logDebug)('Engine ==>> disconnect');
        this.pendingRequests.clear();
    }
    getRequestId() {
        const requestId = Date.now().toString();
        (0, log_1.logDebug)('Engine ==>> getRequestId ==>', requestId);
        return requestId;
    }
    bindRequestForPromise(requestId, resolve) {
        this.pendingRequests.set(requestId, resolve);
    }
    send(request, requestAnswer, option, ttl) {
        return __awaiter(this, void 0, void 0, function*() {
            (0, log_1.logDebug)('Engine ==>> send  request==>', JSON.stringify(request));
            const requestId = this.getRequestId();
            try {
                let packageId = yield this.connectionManager.send(JSON.stringify(Object.assign(Object.assign({}, request), {
                    requestId: requestId
                })), ttl);
                this.connectionManager.events.once(packageId.toString(), (event)=>{
                    var _a;
                    (0, log_1.logDebug)(`Engine ==> send => onAck => ${(0, safejson_1.safeJsonStringify)(event)}`);
                    if (event && event.result) {
                        (_a = requestAnswer.onAck) === null || _a === void 0 ? void 0 : _a.call(requestAnswer);
                    }
                });
                if (requestAnswer.resolve) {
                    this.bindRequestForPromise(requestId, requestAnswer.resolve);
                }
            } catch (e) {
                return Promise.reject(e);
            }
        });
    }
    sendSession(sessionInfo) {
        return __awaiter(this, void 0, void 0, function*() {
            (0, log_1.logDebug)('[Connect] sendSession called:', sessionInfo);
            const requestId = this.getRequestId();
            let request = {
                method: 'session_info',
                params: {
                    sessionInfo: sessionInfo
                }
            };
            yield this.connectionManager.sendRaw(JSON.stringify(Object.assign(Object.assign({}, request), {
                requestId: requestId
            })));
        // try {
        //     let packageId = await callForSuccess(() =>
        //         , option)
        //     this.connectionManager.events.once(packageId.toString(),(event)=>{
        //         logDebug(`Engine ==> send => onAck => ${safeJsonStringify(event)}`)
        //         if (event && event.result){
        //             requestAnswer.onAck?.()
        //         }
        //     })
        //     if (requestAnswer.resolve){
        //         this.bindRequestForPromise(requestId, requestAnswer.resolve)
        //     }
        // }catch (e) {
        //     return Promise.reject(e)
        // }
        });
    }
    handleResponse(event, response) {
        (0, log_1.logDebug)(`Engine ==>> handleResponse_1  ======>response: ${(0, safejson_1.safeJsonStringify)(response)}`, event);
        if ("requestId" in response) {
            (0, log_1.logDebug)("Engine ==>> handleResponse_2  ===> in response");
            let requestId = response.requestId;
            const resolve = this.pendingRequests.get(requestId);
            if (resolve) {
                (0, log_1.logDebug)("Engine ==>> handleResponse_3  ===> find resolve:", resolve);
                resolve(response);
                // pendingRequestsPromise
                this.pendingRequests.delete(requestId);
            } else {
                (0, log_1.logDebug)("Engine ==>> handleResponse_3  ===> not find resolve:");
                if (response.method === "disconnect") {
                    this.disconnectListener.forEach((listener)=>listener());
                    this.disconnectListener = [];
                    this.disconnect();
                } else if (response.method === "session_connecting") {
                    (0, log_1.logDebug)("Engine ==>> handleResponse_4  ===> sessionConnectingListener");
                    if (this.sessionConnectingListener) {
                        (0, log_1.logDebug)("Engine ==>> handleResponse_4  ===> sessionConnectingListener not null");
                        this.sessionConnectingListener();
                        this.sessionConnectingListener = undefined;
                    }
                }
            }
        }
    }
    restoreconnect(sessionInfo, onConnectResult) {
        return __awaiter(this, void 0, void 0, function*() {
            var _a;
            yield (_a = this.connectionManager) === null || _a === void 0 ? void 0 : _a.restoreConnect(sessionInfo.topic);
            onConnectResult(sessionInfo);
        });
    }
    conect(request, sessionConfig, onConnectResult) {
        return __awaiter(this, void 0, void 0, function*() {
            var _a, _b;
            const connectInfo = this.connectionManager.getConnectInfo();
            const requestId = this.getRequestId();
            let openUniversalLink = (_a = sessionConfig.openUniversalUrl) !== null && _a !== void 0 ? _a : false;
            const connectRequest = {
                protocolVer: Number(protocol_1.tonConnectSdkVersion),
                topic: connectInfo.channelId,
                clientId: connectInfo.clientId,
                requestId: requestId,
                dAppInfo: sessionConfig.dappInfo,
                requests: request
            };
            const connectRequestStr = JSON.stringify(connectRequest);
            const utf8Array = new TextEncoder().encode(connectRequestStr);
            const base64Encoded = btoa(String.fromCharCode(...utf8Array));
            const deeplinkUrl = `${protocol_1.standardDeeplink}?param=${base64Encoded}`;
            (0, log_1.logDebug)('engine ==>> connect ==>>deeplinkUrl:', deeplinkUrl);
            const isIOS = (0, utils_2.isIos)();
            (0, log_1.logDebug)(`engine ==>> connect ==>>isIOS: ${isIOS}   openUniversalLink: ${openUniversalLink}`);
            if (isIOS && openUniversalLink) {
                (0, log_1.logDebug)('bridge-provider ==>> connect_3');
                (0, utils_1.openOKXDeeplinkWithFallback)(deeplinkUrl);
            }
            yield (_b = this.connectionManager) === null || _b === void 0 ? void 0 : _b.disconnect(false);
            this.bindRequestForPromise(requestId, (response)=>{
                let session = this.onConnect(response, sessionConfig, connectInfo.channelId);
                onConnectResult(session, response);
            });
            try {
                yield this.connectionManager.connect();
            } catch (e) {
                (0, log_1.logDebug)('Engine conect error', e);
                throw e;
            }
            if (!isIOS && openUniversalLink) {
                (0, log_1.logDebug)('bridge-provider ==>> connect_4');
                (0, utils_1.openOKXDeeplinkWithFallback)(deeplinkUrl);
            }
            return {
                connectInfo: connectInfo,
                deeplinkUrl: (0, utils_1.getUniversalLink)(deeplinkUrl)
            };
        });
    }
    onConnect(connectResponse, sessionConfig, topic) {
        if (connectResponse.method == "connect") {
            let namespaces = (0, sessionUtils_1.buildNameSpacesByConnectResponse)(connectResponse);
            if (namespaces) {
                let session = {
                    topic: topic,
                    sessionConfig: sessionConfig,
                    namespaces: namespaces
                };
                return session;
            }
        }
        return null;
    }
    universalConnect(request, sessionConfig, connectInfoAndUrl) {
        return __awaiter(this, void 0, void 0, function*() {
            return new Promise((resolve, reject)=>__awaiter(this, void 0, void 0, function*() {
                    var _a, _b, _c, _d;
                    try {
                        (0, log_1.logDebug)("engine universalConnect request :", JSON.stringify(request));
                        (0, log_1.logDebug)("engine universalConnect sessionConfig :", JSON.stringify(sessionConfig));
                        let universalRequest = [];
                        request.forEach((item)=>{
                            let name = item.name;
                            if (name.startsWith("requestAccounts") || name.startsWith("ton")) {
                                universalRequest.push(item);
                            }
                        });
                        (0, log_1.logDebug)("engine universalConnect universalRequest :", JSON.stringify(universalRequest));
                        const connectInfo = this.connectionManager.getConnectInfo();
                        const requestId = this.getRequestId();
                        let openUniversalLink = (_a = sessionConfig.openUniversalUrl) !== null && _a !== void 0 ? _a : false;
                        const universalConnectRequest = {
                            protocolVer: Number(protocol_1.tonConnectSdkVersion),
                            topic: connectInfo.channelId,
                            clientId: connectInfo.clientId,
                            requestId: requestId,
                            dAppInfo: sessionConfig.dappInfo,
                            requests: universalRequest,
                            redirect: (_b = sessionConfig === null || sessionConfig === void 0 ? void 0 : sessionConfig.redirect) !== null && _b !== void 0 ? _b : "none"
                        };
                        const base64Encoded = (0, url_1.encodeConnectParams)(universalConnectRequest);
                        universalConnectRequest.redirect = (_c = sessionConfig === null || sessionConfig === void 0 ? void 0 : sessionConfig.redirect) !== null && _c !== void 0 ? _c : "none";
                        (0, log_1.logDebug)('engine universalConnect ==>>universalConnectRequest:', JSON.stringify(universalConnectRequest));
                        var openOKXLink = "";
                        // open app wallet
                        if (openUniversalLink) {
                            openOKXLink = (0, url_1.getOKXLink)(universalConnectRequest, sessionConfig.useMini, sessionConfig.tmaReturnUrl);
                            (0, log_1.logDebug)('engine universalConnect ==>>openOKXLink:', openOKXLink);
                        }
                        const openMethod = ()=>sessionConfig.useMini ? (0, url_1.openOKXTMAWalletlinkWithFallback)(openOKXLink) : (0, utils_1.useShortLink)() ? (0, utils_1.openOKXUniversalLink)(openOKXLink) : (0, utils_1.openOKXDeeplinkWithFallback)(openOKXLink);
                        (0, log_1.logDebug)('engine universalConnect ==>>openOKXLink:', openOKXLink);
                        const isIOS = (0, utils_2.isIos)();
                        if (isIOS && openUniversalLink) {
                            (0, log_1.logDebug)(`engine universalConnect ==>>isIOS: ${isIOS}   openUniversalLink: ${openUniversalLink}`);
                            openMethod();
                        }
                        yield (_d = this.connectionManager) === null || _d === void 0 ? void 0 : _d.disconnect(false);
                        this.bindRequestForPromise(requestId, (response)=>{
                            var _a, _b, _c, _d;
                            try {
                                let connectResponse = response;
                                if (connectResponse.method == "connect") {
                                    (0, log_1.logDebug)("engin  universalConnect success connectResponse:>>>", JSON.stringify(connectResponse));
                                    let namespaces = (0, sessionUtils_1.buildNameSpacesByConnectResponse)(connectResponse);
                                    if (namespaces) {
                                        let walletName = undefined;
                                        if (((_b = (_a = connectResponse.payload) === null || _a === void 0 ? void 0 : _a.responses) === null || _b === void 0 ? void 0 : _b[0]) && "walletName" in connectResponse.payload.responses[0]) {
                                            walletName = connectResponse.payload.responses[0]['walletName'];
                                        }
                                        let session = {
                                            topic: connectInfo.channelId,
                                            sessionConfig: sessionConfig,
                                            namespaces: namespaces,
                                            wallet: Object.assign(Object.assign({}, (_c = connectResponse.payload) === null || _c === void 0 ? void 0 : _c.wallet), {
                                                walletName: walletName
                                            })
                                        };
                                        let methodsResponse = connectResponse.payload.responses.find((item)=>item.name === 'requestAccounts');
                                        if (methodsResponse && methodsResponse.connectRequestMethods) {
                                            session.signResponse = methodsResponse.connectRequestMethods;
                                        }
                                        (0, log_1.logDebug)("engin  universalConnect success session:>>>", JSON.stringify(session));
                                        resolve(session);
                                    } else {
                                        throw new protocol_1.OKXConnectError(protocol_1.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR);
                                    }
                                } else if (connectResponse.method == "connect_error" && ((_d = connectResponse.payload) === null || _d === void 0 ? void 0 : _d.code)) {
                                    throw new protocol_1.OKXConnectError(connectResponse.payload.code);
                                }
                            } catch (e) {
                                reject(e);
                            }
                        });
                        try {
                            yield this.connectionManager.connect();
                        } catch (e) {
                            (0, log_1.logDebug)('Engine universalConnect error', e);
                            throw e;
                        }
                        if (!isIOS && openUniversalLink) {
                            openMethod();
                        }
                        (0, log_1.logDebug)('engin  universalConnect ==>> connectInfoAndUrl:', connectInfoAndUrl);
                        this.sendSession(base64Encoded);
                        if (connectInfoAndUrl) {
                            const info = {
                                connectRequest: universalConnectRequest,
                                redirect: sessionConfig.redirect,
                                tmaReturnUrl: sessionConfig.tmaReturnUrl
                            };
                            (0, log_1.logDebug)("universalConnect connectInfoAndUrl info :", JSON.stringify(info));
                            connectInfoAndUrl(info);
                        }
                    } catch (error) {
                        (0, log_1.logDebug)("Engine universalConnect catch error", error);
                        reject(error);
                    }
                }));
        });
    }
}
exports.Engine = Engine;
}}),
"[project]/node_modules/@okxconnect/core/src/connect/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Storage = exports.Engine = exports.WalletConnectionManager = exports.ConnectionManager = exports.OKXWalletConnector = void 0;
var connect_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/connect/connect.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "OKXWalletConnector", {
    enumerable: true,
    get: function() {
        return connect_1.OKXWalletConnector;
    }
});
var connectionManager_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/connect/connectionManager.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "ConnectionManager", {
    enumerable: true,
    get: function() {
        return connectionManager_1.ConnectionManager;
    }
});
var walletConnectionManager_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/connect/walletConnectionManager.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "WalletConnectionManager", {
    enumerable: true,
    get: function() {
        return walletConnectionManager_1.WalletConnectionManager;
    }
});
var engine_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/connect/engine.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "Engine", {
    enumerable: true,
    get: function() {
        return engine_1.Engine;
    }
});
var storage_1 = __turbopack_require__("[project]/node_modules/@okxconnect/core/src/connect/storage.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "Storage", {
    enumerable: true,
    get: function() {
        return storage_1.Storage;
    }
});
}}),
"[project]/node_modules/@okxconnect/core/src/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_require__("[project]/node_modules/@okxconnect/core/src/connect/index.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@okxconnect/core/src/protocol/index.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@okxconnect/core/src/utils/index.js [app-ssr] (ecmascript)"), exports);
}}),

};

//# sourceMappingURL=node_modules_%40okxconnect_core_187cf8._.js.map